<?xml version="1.0" encoding="utf-8"?>
<!-- $Id$ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN"
  "http://www.oasis-open.org/docbook/xml/4.1/docbookx.dtd" [
  <!ENTITY % TapestryLinks SYSTEM "../common/TapestryLinks.xml">
  %TapestryLinks;
  
]>
<!-- Conventions:

	Component ids are <varname>
	Java packages and class names are <classname>
	Tapestry component aliases are <classname>

	In-line code snippets use <function>
	Property paths and JavaBeans property names used <varname>
-->
<book>
  <title>Tapestry Contributor's Guide</title>
  <bookinfo>
    <author>
      <firstname>Howard</firstname>
      <surname>Lewis Ship</surname>
    </author>
    <copyright>
      <year>2002</year>
      <year>2003</year>
      <holder>The Apache Software Foundation</holder>
    </copyright>
  </bookinfo>
  
<chapter id="intro">
	<title>Introduction</title>
	
<para>
This document is a guide to developers who want to go
beyond merely developing applications <emphasis>using</emphasis> Tapestry,
and want to extend and improve Tapestry itself.
</para>

<para>
Tapestry has benefitted over the first two years of its 
development from having a focused vision and, predominantly,
a single developer. At the time of this writing, May 2002,
the Tapestry community is truly coming alive, with
new developers contributing fixes, components and documentation.
</para>

<para>
The goal is to maintain the stability of Tapestry even as it
shifts from a one-man-show to a true community effort.  Meanwhile
it is vitally important to not to sacrifice quality in either
code or <emphasis>documentation</emphasis> if Tapestry is to
stay on track.
</para>

<para>
Contributing to Tapestry requires a commitment to produce excellent code, 
examples and documentation.  In fact, proper documentation in JavaDoc and
as updates to the tutorials and manuals represents the
<emphasis>dominant</emphasis> amount of effort when contributing to Tapestry.
</para>


</chapter>  

<chapter id="cvs">
	<title>CVS Access</title>
	
<para>
Tapestry is housed at the &TapestryProjectPage;.  Read-only CVS access is available
to anyone; to have read-write access you must be registered
with SourceForge, and then contact the Tapestry administrator
(<ulink url="mailto:hship@users.sf.net">Howard Lewis Ship</ulink>) to be
added to the list of Tapestry developers.
</para>

<para>
Using Eclipse, obtaining the source code takes only a few steps.   Tapestry
compiles using some libraries from &JBoss; 3.0.0, which must be downloaded first.
</para>

<para>
Eclipse must be configured with the location of JBoss, this is done from the preferences
panel.  A new entry for <literal>JBOSS_DIR</literal> should be added.
</para>

<figure>
	<title>Eclipse: Java Classpath Preferences</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/eclipse-classpath.png" format="PNG"/>
          </imageobject>
        </mediaobject>	
</figure>

<para>
Activate the CVS Repositories view and use the context menu to create a new CVS Repository location.
This raises a panel for defining connection information.  Fill in your own
SourceForge name and password:
</para>

<figure>
	<title>Eclipse: New CVS Repository Location</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/eclipse-add-repository.png" format="PNG"/>
          </imageobject>
        </mediaobject>	
</figure>

<para>
Next, open the new CVS Repository location and navigate down to the Tapestry
module, then use the context menu to checkout the Tapestry project:
</para>


<figure>
	<title>Eclipse: Check Out Project</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/eclipse-check-out-project.png" format="PNG"/>
          </imageobject>
        </mediaobject>	
</figure>

<para>
Eclipse will checkout the latest versions of all the Tapestry code and compile it.
</para>

<para>
You can access the Tapestry repository using command line CVS or other tools, as well.  Details
for using command line CVS are available at the &TapestryProjectPage;.
</para>


</chapter>

<chapter id="building">
	<title>Building Tapestry</title>
	
<para>
Tapestry is built using &Ant; 1.5.  In addition,
Tapestry includes the necessary control files to allow
development using the excellent open-source IDE, &Eclipse;.
</para>

<para>
To perform a full build from the command line, you must have
JDK 1.3 or better installed, as well
as &JBoss; 3.0.0.
</para>

<para>
You must create the file <filename>config/build.properties</filename>
(under the Tapestry root directory).  This file defines a property,
<literal>jboss.dir</literal> that identifies the full pathname
to the JBoss installation.  A sample file is provided.
<tip>
	<para>
	Be sure to use forward slashes for the path name, even
	under Windows.  Using backslashes, the escape character
	in property files, will cause the build to fail, since
	Ant will be using incorrect paths to the libraries obtained
	from the JBoss distribution.
	</para>
</tip>
</para>

<section id="building.subprojects">
	<title>Tapestry Subprojects</title>
	
<para>
The Tapestry source tree contains multiple sub-projects, each in its own subdirectory,
with its own Ant build file and own source code tree.
A root level build file (described in the <link linkend="building.targets">next section</link>)
performs builds over all sub-projects.
</para>

<variablelist>
	<title>Tapestry Sub-Projects</title>
	<varlistentry>
		<term><filename>framework</filename></term>
		<listitem>
		<para>
		Contains the core framework, builds &TapestryFrameworkJar;.
		</para>
		</listitem>
	</varlistentry>
	

	<varlistentry>
		<term><filename>contrib</filename></term>
		<listitem>
		<para>
		Builds &TapestryContribJar;.
		</para>
		</listitem>
	</varlistentry>


	<varlistentry>
		<term><filename>junit</filename></term>
		<listitem>
		<para>
		Builds and runs JUnit tests.
		</para>
		</listitem>
	</varlistentry>


	<varlistentry>
		<term><filename>examples/Tutorial</filename></term>
		<listitem>
		<para>
		Builds <filename>tutorial.war</filename>.
		</para>
		</listitem>
	</varlistentry>


	<varlistentry>
		<term><filename>examples/wap</filename></term>
		<listitem>
		<para>
		Builds <filename>wap.war</filename>, a tiny
		demonstration of WAP support.
		</para>
		</listitem>
	</varlistentry>
	
	
	<varlistentry>
		<term><filename>examples/VlibBeans</filename></term>
		<listitem>
		<para>
		Builds <filename>VlibBeans.jar</filename>, the EJBs used
		by the Virtual Library demonstration.
		</para>
		</listitem>
	</varlistentry>
	

	<varlistentry>
		<term><filename>examples/Vlib</filename></term>
		<listitem>
		<para>
		Builds <filename>Vlib.war</filename>, the presentation
		layer of the Virtual Library demonstration.
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><filename>examples/VlibEAR</filename></term>
		<listitem>
		<para>
		Builds <filename>Vlib.ear</filename> from
		<filename>VlibBeans.jar</filename> and
		<filename>Vlib.war</filename>.
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><filename>doc/src/Tutorial</filename></term>
		<listitem>
		<para>
		Builds the Tapestry Tutorial documentation.
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><filename>doc/src/DevelopersGuide</filename></term>
		<listitem>
		<para>
		Builds the Tapestry Developer's Guide documentation.
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><filename>doc/src/ContributorsGuide</filename></term>
		<listitem>
		<para>
		Builds the this documentation.
		</para>
		</listitem>
	</varlistentry>		
	
	<varlistentry>
		<term><filename>doc/src/ComponentReference</filename></term>
		<listitem>
		<para>
		Builds the component reference documentation.
		</para>
		</listitem>
	</varlistentry>		
</variablelist>

</section>

<section id="building.targets">
	<title>Build Targets</title>
	
<para>
The following Ant build targets are available from the Tapestry root directory:

<variablelist>
    <title>Root Targets</title>
    <varlistentry>
      <term>clean</term>
      <listitem>
        <para>Cleans each sub-project and deletes derived files (such as
        the Tapestry framework JAR and examples).</para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
    	<term>clean-all</term>
    	<listitem>
    	<para>
    	As with <literal>clean</literal>, but also deletes
    	all documentation.
    	</para>
    	</listitem>
    </varlistentry>
    
    <varlistentry>
    	<term>documentation</term>
    	<listitem>
    	<para>
    	Builds all documentation (see notes below).
    	</para>
    	</listitem>
    </varlistentry>

    <varlistentry>
    	<term>install</term>
    	<listitem>
    	<para>
    	Performs a full build, by re-invoking <literal>install</literal>
    	in each sub-project.
    	</para>
    	</listitem>
    </varlistentry>



    <varlistentry>
    	<term>javadoc</term>
    	<listitem>
    	<para>
   		Creates Tapestry API documentation.
    	</para>
    	</listitem>
    </varlistentry>
    
    
    <varlistentry>
    	<term>junit</term>
    	<listitem>
    	<para>
    	Runs all &JUnit; tests.
    	</para>
    	</listitem>
    </varlistentry>

 
       
</variablelist>
		

</para>

</section>

<section id="building.doc-setup">
	<title>Documentation Setup</title>
	
<para>
Tapestry documentation, including this manual, is also generated using Ant.  Documentation
source is in &DocBook; XML format, and uses XSL transformation to generate readable HTML.
Tapestry uses &Saxon; to generate HTML documentation, and
&Fop; to generate PDF documentation.

<itemizedlist>

<listitem>
<para>
Download and unpack the &Saxon; distribution, release 6.5.2 or better.
</para>
</listitem>

<listitem>
<para>
Copy <filename>saxon.jar</filename> into the
Ant <filename>lib</filename> directory.  
</para>
</listitem>

<listitem>
<para>

Update your
<envar>ANT_OPTS</envar> environment variable
to add the following two system properties:

	<itemizedlist>
          <listitem>
            <para>
              -Djavax.xml.parsers.DocumentBuilderFactory=org.apache.crimson.jaxp.DocumentBuilderFactoryImpl
            </para>
          </listitem>
          <listitem>
            <para>
           -Djavax.xml.parsers.SAXParserFactory=org.apache.crimson.jaxp.SAXParserFactoryImpl
            </para>
          </listitem>
	</itemizedlist>


</para>
</listitem>

<listitem>
<para>
Download &Fop; 0.20.4rc and unpack into a permanent directory.
</para>
</listitem>

<listitem>
<para>
Update <filename>config/build.properties</filename> and add
a <literal>fop.dir</literal> entry, identifying the directory
into which you unpacked FOP.  Be sure to use an absolute
path name, and only forward slashes.
</para>
</listitem>

<listitem>
<para>
Get a copy of <ulink url="http://java.sun.com/products/jimi/">JIMI</ulink>
(an imaging package from Sun, needed by FOP to process PNG image files), and
unpack it to temporary directory.
</para>
</listitem>

<listitem>
<para>
Copy <filename>JimiProClasses.zip</filename> into the <filename><replaceable>FOP</replaceable>/lib</filename>
directory.
</para>
</listitem>

</itemizedlist>

</para>

</section>

</chapter>

<chapter id="standards">
	<title>Development Standards</title>
	
<para>
This chapter covers a number of standards, both in code and in procedure, expected by Tapestry contributors.
</para>

<section id="standards.id-symbol">
	<title>Use of &dollar;Id$ Symbol</title>
	
<para>
Every file checked into the CVS repository should have the &dollar;Id$ symbol inside a comment, near the top
of the file.  The <literal>&dollar;Id$</literal> token is expanded by CVS into a useful header, identifying the revision
of the file, date last changed, and name of last user to change the file.
</para>

<para>
For example, the &dollar;Id$ for this document is <literal>$Id$</literal>.
</para>

</section>

<section id="standards.typecomment">
	<title>Type Comment</title>
	
<para>
Each Java file <emphasis>must</emphasis> have a complete and useful type comment.  Type comments
must come after all <literal>import</literal> statements, and before the start of the class.
</para>

<figure>
	<title>Type Comment</title>
<programlisting>
/**
 *  <replaceable>A useful description of the class or interface, especially covering</replaceable>
 *  <replaceable>how it is used, and what other classes or interfaces it interacts with.</replaceable>
 *
 *  @author <replaceable>Your Name</replaceable>
 *  @version &dollar;Id$
 *  @since <replaceable>Version</replaceable>
 *
 **/
</programlisting>	
</figure>

<para>
The <replaceable>Version</replaceable> should be replaced with the numeric version number of
the Tapestry release the type will first appear in.  This is the 
<link linkend="releases">minor release number</link>; for example,
a change introduced in release <literal>2.3-beta-3</literal>
would be identified as <literal>2.3</literal>.
</para>

</section>

<section id="standards.javadoc">
	<title>JavaDoc</title>
	
<para>
All methods should be commented, with the following exceptions:

<itemizedlist>
	<listitem>
	<para>
	Simple accessor methods with no side-effects.
	</para>
	</listitem>	
	
	<listitem>
	<para>
	Methods that are fully described by an interface and
	don't add any additional behaviors.
	</para>
	</listitem>
</itemizedlist>
</para>

<para>
Parameters and return values should be identified.  <literal>@throws</literal>
should identify when any checked exceptions are thrown; additional
<literal>@throws</literal>
entries should describe any runtime exceptions that may also be thrown.
</para>

<para>
Methods should always include a <literal>@since</literal> entry, unless the method
was added as part of a new Java class or interface, in which case
the <literal>@since</literal> for the containing type is sufficient.
Use the same version number as <link linkend="standards.typecomment">type comments</link>
when adding individual methods.
</para>

<para>
Try not to skimp on the comment (it is often best to write the comment before writing any code).
Tapestry has some of the best documentation of any open source project and that should
be maintained.  Remember to try and answer the question <emphasis>why?</emphasis>, which is
always much more interesting and useful than <emphasis>how?</emphasis> or <emphasis>what?</emphasis>.
</para>

<para>
It is appropriate to create JavaDoc comments for variables, even private variables (to at least
provide an <literal>@since</literal> value).
</para>

<para>
Collections (from package <literal>java.util</literal>) should be documented to identify
the type of object stored, and for <classname>Map</classname>
the type of key.  Example: <literal>List of {@link IRender}</literal>, or
<literal>{@link Map} of {@link IBinding} keyed on String name</literal>.
</para>

<para>
When a method returns a collection type, the documentation should indicate if it is safe
for the caller to modify the collection or not.  In general, it is best to always return an immutable
copy of a collection, but for efficiency this is not always reasonable.
</para>

<para>
And don't forget to make liberal use of JavaDoc links (<literal>@link</literal>) which makes the
documentation far eaiser to use.
</para>

<note>
	<title>Javadoc Formatting</title>
	<para>
	The standard for formatting Javadoc comments in Tapestry is to close the comment
	with <literal>**/</literal>.  You should attempt to follow this, especially
	when modifying existing code.
	</para>
</note>

</section>

<section id="standards.java-formatting">
	<title>Java Code Formatting</title>
	
<para>
Ah, a <emphasis>religous issue</emphasis>. The most important things are to be consistent
(an editor that indents code for you is helpful) and to
<emphasis>conform to the existing style</emphasis> when editting someone else's code.
</para>

<para>
Tapestry is formatted using <emphasis>spaces</emphasis> (not tabs), 
and an indent of four.
</para>

<para>
All the code currently in the repository has been formatted using the
Eclipse IDE.  My personal preference is to include a newline before opening braces.
In addition, a maximum line-length of 100 characters has been used.  These
preferences are easy to setup in Eclipse:
</para>

<figure>
	<title>Eclipse: Java Code Formatting Preferences</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/eclipse-java-formatting.png" format="PNG"/>
          </imageobject>
        </mediaobject>	
</figure>

</section>

<section id="standards.naming">
	<title>Naming Conventions</title>

<para>
Standard Java guidelines are expected to be followed.  
Class names are capitalized (example: <classname>MyClass</classname>).
Methodsstart with a lower-case character (example: <literal>myMethod</literal>).
</para>

<para>
Static final variables used as constants
are in upper-case (example: <literal>MY_CONSTANT</literal>).
</para>

<para>
Private member variables (both instance and static) are named with a leading underscore
(example: <literal>_myVariable</literal>).  Public member variables are to be avoided.
</para>

<note>
<title>Naming in transition</title>
<para>
I've resisted the leading underscore syntax for a long time; the rationale behind it
is to make it possible, at a glance, to visually seperate instance variables
from local variables and parameters.  Previously, I've always maintained that
the problem was methods that were too large; lately I've changed
my mind ... the underscore naming helps when debugging and helps avoid
a number of naming collisions.
</para>

<para>
At the time of this writing, 2.1-beta-1, very little of the code used
the new naming.  Over time, mixed in with other bug fixes, renaming will
occur (&Eclipse; helps with this greatly).  New code will be written to conform.
</para>
</note>


<para>
Interfaces in Tapestry are prefixed with the letter 'I' (example: <literal>IRequestCycle</literal>).
Implementations (often in a different package)
strip off the 'I' (example: <literal>RequestCycle</literal>).  Interfaces related to JavaBean events 
do not start with an 'I' (example: <literal>PageDetachListener</literal>).
</para>

<para>
Base classes, classes which are concrete and functional, but often extended, are prefixed with 'Base' (example:
<literal>BaseComponent</literal>).  Abstract classes are prefixed with 'Abstract' (example:
<literal>AbstractEngine</literal>).  Classes which are functional and only rarely subclassed are often
prefixed with 'Default' (example: <literal>DefaultScriptSource</literal>).
</para>

<para>
The base package for the framework JAR (&TapestryFrameworkJar;) is <literal>net.sf.tapestry</literal>.
The base package for the contrib JAR (&TapestryContribJar;) is <literal>net.sf.tapestry.contrib</literal>.
</para>

</section>

</chapter>

<chapter id="releases">
	<title>Tapestry Release Numbering</title>
	
<para>
Tapestry release numbering is relatively simple, as long as you don't look back in time
(the less managable numbering system used through release 2.0.5 is described shortly).
</para>

<para>
Tapestry releases consist of a major version, a minor version and a incremental version.
The pattern 
<literal>
<replaceable>major</replaceable>.<replaceable>minor</replaceable>-<replaceable>incremental</replaceable>-<replaceable>index</replaceable>
</literal>
is used, for example: <literal>2.1</literal>, <literal>2.2-alpha-3</literal>
or <literal>2.3-beta-1</literal>.
</para>

<para>
The major version represents large-scale changes in the framework ... short of translating Tapestry
to another language (say, Python or Ruby), this is not likely to happen again.  Tapestry
is currently in major release 2.
</para>


<para>
The minor version represents the introduction of new functionality and bug fixes
in a stable manner.  <literal>2.1</literal> or <literal>2.2</literal> would be examples
of minor releases.
</para>

<para>
An incremental release represents a transition from one minor release to the next.
Incremental releases are <literal>alpha</literal>, <literal>beta</literal> or
<literal>rc</literal> (release candidate).
Typically, after a major release there will
be a series of alpha, then beta, then rc releases, leading up to 
the next minor release.
A possible sequence is <literal>2.1</literal>, <literal>2.2-alpha-1</literal>,
<literal>2.2-beta-1</literal>, <literal>2.2-rc-1</literal>, <literal>2.2</literal>.
</para>

<para>
Typically, there will be several incremental releases of the same type, numbered from 1 up.
Alpha releases contain significant functionality changes, beta releases represent
bug fixes to those changes (stabilizing the changes), 
and rc (release chandidate) releases are expected
to be stable versions of the next minor release (though any problems can spur further
release candidates).
</para>

<para>
Through Tapestry release 2.0.5, numbering was a bit different.  Under the modern scheme, 
2.0.1 would be named <literal>2.1-alpha-1</literal>, 2.0.2 would be <literal>2.1-alpha-2</literal>,
and 2.0.5 would be <literal>2.1-beta-1</literal>.  Modern release numbering
begins with <literal>2.1-beta-2</literal> (the release immediately following 2.0.5).  
</para>

</chapter>

<chapter id="procedures">
	<title>Development Procedures</title>
	
<para>
This chapter defines procedures for development of Tapestry.  This includes many things not directly
related to coding, such as documentation and interacting with the CVS repository.
</para>

<section id="procedures.deprecation">
	<title>Deprecating methods and classes</title>
	
<para>
Tapestry is being used by a increasingly large community of developers and it is necessary
that they have some stability in their development.
</para>

<para>
To that end, classes and methods must follow a developer-friendly lifecycle.
If a method or class must be deleted, it should be marked as deprecated in one minor release,
and can be removed in the following minor release.
</para>

<para>
For example, a method may be marked as
deprecated in release 2.2-alpha-1.  This change isn't considered 
"real" until release 2.2.  The method can be removed any time after that, say in release 2.3-alpha-3,
and the removal becomes "real" in release 2.3.
</para>

<para>
Don't simply mark a method as deprecated, give the end-developer
the information needed adapt their code.  Use the following template
as part of the Javadoc comment:

<informalexample>
<programlisting>
  @deprecated To be removed in <replaceable>Version</replaceable>.
    Use {@link <replaceable>SomeClass#someMethod(...)</replaceable>} instead.
</programlisting>
</informalexample>
</para>


<para>
It is also important for the changer to make the transition as simple as possible for
the end-developer.  Base classes and default implementations should be changed
to make use of the new API in such as way that, at most, a recompile
of the end-developer's classes is required.
</para>

<para>
Sometimes, changes require a lack of backwards compatibility.  If
a method has to change and the old signature can't be maintained, then
simply change it ... but be sure to document the change in the
Tapestry release notes (<filename>web/new.html</filename>).
</para>


</section>

<section id="procedures.junit">
	<title>JUnit Tests</title>
	
<para>
Where possible, create JUnit tests for your code.  At the time of this writing, there isn't a procedure for
directly testing Tapestry components ... however, you should often be able to test other objects
related to your components, such as helper beans, models, etc.
</para>

<para>
JUnit test source code is placed into the <filename class="directory">junit/src</filename> source tree.
The package name for JUnit tests is <literal>net.sf.tapestry.junit</literal>.
</para>

<para>
Work is underway to allow unit testing of components using
a <emphasis>mock</emphasis> Servlet API, but this will
not be available until Tapestry release 2.3.
</para>

</section>

<section id="procedures.documentation">
	<title>Documentation</title>
	
<para>
Documentation is much harder than coding, but the ongoing success of Tapestry depends on maintaining
the quality of documentation.  Tapestry documentation is written using &DocBook; XML format, using
XSL stylesheets to convert to final documentation.
</para>

<para>
Changes to the framework usually require a change in documentation to the Tapestry Developer's Guide.
</para>
	
</section>

<section id="procedures.component-doc">
	<title>Component Documentation</title>
	
<para>
Although there is limited documentation about components in their component specification file, that documentation
is designed to be a short reminder, not the complete documentation.  Full documentation goes into
the component's Java file, as part of its type comment JavaDoc.
</para>

<para>
Component documentation consists of a table, identifying all the formal parameters of the component.
In addition, a note indicating whether informal parameters are allowed, and if the component may
have a body (that is, wrap other components) is supplied at the end.
</para>

<figure>
	<title>Component Documentation Template</title>
<programlisting>
/**
 *  <replaceable>Type comment documentation ...</replaceable>
 *
 *  &lt;p&gt;&lt;table border=1&gt;
 *  &lt;tr&gt;
 *    &lt;th&gt;Parameter&lt;/th&gt;
 *    &lt;th&gt;Type&lt;/th&gt;
 *    &lt;th&gt;Direction&lt;/th&gt;
 *    &lt;th&gt;Required&lt;/th&gt;
 *    &lt;th&gt;Default&lt;/th&gt;
 *    &lt;th&gt;Description&lt;/th&gt;
 *  &lt;/tr&gt;
 *
 *  &lt;tr&gt;
 *    &lt;td&gt;<replaceable>name</replaceable>&lt;/td&gt;
 *    &lt;td&gt;<replaceable>{@link Type}</replaceable>&lt;/td&gt;
 *    &lt;td&gt;<replaceable>in|out|in-out</replaceable>&lt;/td&gt; <co id="procedures.component-doc.direction"/>
 *    &lt;td&gt;<replaceable>yes|no</replaceable>&lt;/td&gt;
 *    &lt;td&gt;<replaceable>Default value</replaceable>&lt;/td&gt; <co id="procedures.component-doc.default"/>
 *    &lt;td&gt;<replaceable>Full description</replaceable>&lt;/td&gt;
 *  &lt;/tr&gt;
 *
 *  ...
 *
 *  &lt;p&gt;Informal parameters are <replaceable>[not]</replaceable> allowed.  The component
 *  may <replaceable>[not]</replaceable> contain a body.
 *
 *  ...
 *
 **/
</programlisting>
<calloutlist>
	<callout arearefs="procedures.component-doc.direction">
	<para>
	This describes how the component uses its binding.
	<literal>in</literal> indicates the binding is read, but never updated, which is
	the most common case.
	<literal>out</literal> indicates the binding is updated, but not read; this is rare, but
	does apply to some parameters of &Foreach;, for example.
	<literal>in-out</literal> is common used with certain form parameters.
	</para>
	</callout>
	
	<callout arearefs="procedures.component-doc.default">
	<para>
	If the parameter is required, then this is usually specified as &amp;nbsp; (non-breaking space).
	</para>
	</callout>
</calloutlist>
	
</figure>


<para>
Recently, <ulink url="../ComponentReference/index.html">seperate HTML component documentation</ulink>
has been created.  This will be the standard location
for Framework component documentation.  Javadoc for the
component should simply have a link
to the correct Component Reference page.
</para>

<para>
The component reference is simply HTML (at least, for the time being).
There are many examples and a template available, for creating
new reference pages.
</para>

</section>

<section id="procedures.checkin">
	<title>Checkin Procedures</title>
	
<para>
Run JUnit tests before
doing a checkin.
You should always have a SourceForge bug or feature request. 
When checking code in, use the SourceForge request as the checkin comment.
</para>

<example>
	<title>Example checkin comment</title>
<programlisting>
[ 553310 ] Set properties from parameter bindings
</programlisting>
</example>
	
	
<para>
In addition, update the Tapestry release notes, the file <filename>web/new.html</filename>,
to identify the feature request.
</para>

<para>
Be very careful when checking files in that they are checked in with the correct 
keyword substitution type.
Files should be either binary or text; text should be checked in with keyword
expansion turned on (this is the <literal>-kkv</literal> option).
</para>

<para>
When new files are added using Eclipse, it must decide whether they are
binary or text. Eclipse always assumes <emphasis>binary</emphasis>
unless specifically informed that a file is text.  Use the Team preferences
panel to set this.
</para>

<figure>
	<title>Eclipse: Team Preferences</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/eclipse-team-preferences.png" format="PNG"/>
          </imageobject>
        </mediaobject>	
</figure>


</section>

<section id="procedures.examples">
	<title>Creating Examples</title>
	
<para>
In lieu of unit tests, the best way to make sure a new component works (as well as advertise
its existence) is to update the Tapestry Tutorial to include it; typically the Tapestry Workbench.  
The Workbench is very easy to extend with new pages, it also has
the <emphasis>very</emphasis> useful feature for dumping out
the request context on each request which greatly simplifies debugging links and form components.
</para>
	
</section>

</chapter>

</book>
<!-- $Id$ -->

<chapter id="components">
	<title>Tapestry Components</>

<para>
Tapestry components are "black boxes" that are involved with both rendering 
HTML responses and responding to HTTP requests.
</>

<para>
A Tapestry component is defined by its specification.  
The specification is an XML file that defines the type of the component, it parameters, 
the template used by the component, any components embedded within it and 
how they are 'wired up', and (less often) any assets used by the component.
</>

<para>
At runtime, the specification is used to identify and instantiate a class 
for the component.  When the page containing the component is rendered, the 
component will access its HTML template to find the static HTML and embedded 
components it will render.
</>

	<section id="components.params">
		<title>Parameters and Bindings</>

<para>
Tapestry components are designed to work with each other, 
within the context of a page and application.  The process of rendering a page 
is largely about pulling information from a source into a component  
and doing something with it.
</>

<para>
For example, on a welcome page, a component might get the <varname>userName</> property from 
the <varname>visit</> object and insert it into the HTML response.
</>

<para>
Each component has a specific set of parameters.  
Parameters have a name, a type and may be required or optional.
</>

<para>
To developers experienced with Java GUIs, it may appear that Tapestry 
component parameters are the same as JavaBeans properties.  This is not completes true.  
JavaBeans properties are set-and-forget; the designer sets a value 
for the property using a visual editor and the value 
is saved with the bean until it is used at runtime.
</>

<para>
Parameters define the type of value needed, but not the actual value.  
This value is provided by a special object called a binding.  
The binding is responsible for providing the value 
for the parameter as it is needed.
</>

<para>
A binding is a source and sink of data.  A component 
uses a binding to import or export a data value.
</>

<para>
There are two types of bindings:  static and dynamic.  
Static bindings are read-only; the value for the binding is 
specified in the component specification. 
</>

<para>
Dynamic bindings are more prevalent and useful.  A dynamic 
binding uses a JavaBeans property name to retrieve the value when needed 
by the component.  The source of this data is a property of some component.
</>

<para>
In fact, dynamic bindings use something more powerful than just a 
property name, they can use a property path.  
A property path is a series of property names separated by periods.  
We've already seen an example:  <literal>visit.userName</>.  
This is equivalent to the Java code <function>getVisit().getUserName()</>,
except that the actual class of each object is used, 
rather than the declared type of each method<footnote>
<para>In other words, property paths are not typesafe.</para></footnote>.
</>

<para>
Property paths can be very useful, since they can allow a binding to 
'crawl' deeply through an object graph to access the value it needs.  
This frees the components from relying totally on the properties of their container, 
instead they are free to access properties of more distant objects.
</>

<para>
Let's change the example:  now the <varname>visit</> object contains a <varname>user</> property, 
which is an object of class <classname>User</> that has a number of 
properties related to the real-life user (such as name, e-mail, account number, etc.).
</>

<para>
We can still use an <classname>Insert</> component to display the user's name; 
we just have to extend the property path to <literal>visit.user.name</>,
which is approximately equivalent to <function>getVisit().getUser().getName()</>.

	</section>

	<section id="components.embedded">
		<title>Embedded Components</>

<para>
Under Tapestry, it is common to define new components 
by combining existing components.  The existing components are 
embedded in the containing component.
</>

<para>
Each embedded component has an <varname>id</> (an identifying string) 
that must be unique within the containing component.  
Every non-page component is embedded inside some other 
component forming a hierarchy that can get quite deep 
(in real Tapestry applications, some pages have components nested three to five levels deep).
</>

<para>
In some cases, a component will be referenced by its id path.  
This is a series of component ids separated by periods, representing a path from 
the page to a specific component.  The same notation as a property path 
is used, but the information being represented is quite different.
</>

<para>
For example, the id path <literal>border.navbar.homeLink</>
represents the component named <varname>homeLink</>, 
embedded inside a component named <varname>navbar</>, 
embedded inside a component named <varname>border</>, embedded inside some page.
</>

<para>
Tapestry components are "black boxes".  They have a set of parameters that may 
be bound, but their internals, how they are implemented, is not revealed.
</>

<para>
Primitive components may not embed other components, or even 
have a template.  Nearly all the built-in components are primitive; they are 
building blocks for constructing more complex components.
</>

<para>
Alternately, a component may be implemented using a template and embedded components.  
In either case, the names, types or very existence of embedded components is private, 
hidden inside the containing component's "black box".
</>

	</section>

	<section id="components.html-template">
		<title>HTML Templates</>

<para>Nearly all Tapestry components combine static HTML
	<footnote>
		<para>
			The initial relase of Tapestry is specifically oriented around HTML.  Some support for
			non-HTML languages, such as XML, XHTML or WML is already present
			and will be expanded in the future.
		</>
	</>
from a template with additional dynamic content 
(some few components are just dynamic content).  
Often, a Tapestry component embeds other Tapestry components.  
These inner components are referenced in the containing component's template.
</>

<para>
Templates look like standard HTML files, though they are rarely complete 
HTML documents; usually they are snippets.  
In addition, a new element, &jwc-tag; (for Java Web Component), 
is added to represent a component in the HTML template.
</>

<para>
The &jwc-tag; element has two forms:
</>
	


&start-listing;&lt;jwc id="<replaceable>component id</>"&gt;  <replaceable>body</>  &lt;/jwc&gt;&end-listing;

<para>or
</>


&start-listing;&lt;jwc id="<replaceable>component id</>"/&gt;&end-listing;


<para>
The parser used by Tapestry is relatively forgiving about case 
and white space.  Also, the component id can be enclosed in 
double quotes (as above) or single quotes.
</>

<para>
The body listed above can be either static HTML or other Tapestry 
components or both.  Elements in the body of a component are 
wrapped by the containing component.  The containing component controls the 
rendering of the elements it wraps in its body.  For example, 
the &Conditional; component may decide not to 
render its body and the &Foreach; component may render 
its body multiple times.
</>

<para>
Not all Tapestry components should have a body.  
For example, the &TextField; component creates an
<sgmltag class=starttag>input type=text</>
form element and it makes no sense for it to contain anything else.  
Whether a component can have a body (and wrap other elements) is defined in the 
component's specification.
</>

<para>
Tapestry includes a special component, &InsertWrapped;, 
which is used to render the body of a component.  
It makes it easy to create components that wrap other components.
</>

<para>
In many scripting systems, scripting constructs are one-dimensional.... 
they appear at a certain point on the page and dynamically 
insert some content into a stream of HTML that eventually 
ends up on the client web browser.
</>

<para>
Tapestry components are more powerful ... they have open and 
close tags and thus can contain a body.  This body is made up 
of static HTML from the template and other Tapestry components.  The outer component 
wraps the inner elements.
</>

<para>
An example of this is the <classname>Border</> component in the Tapestry Tutorial
	<footnote>
		<para>
			The Border tutorial has changed slightly since this
			was initially written, but the basic ideas still hold.
		</para>
	</footnote>.  
It shows how a component can wrap the entire content of a page.
</>

<figure>
	<title>Border Component</>
	<mediaobject>
		<imageobject>
			<imagedata fileref="images/Border-Screenshot.jpg" format=jpeg>
		</>
	</>
</>




<para>
Here, the <varname>border</> component provides the application title ("Reusable Component Tutorial",
in the title bar of the window), the page title (upper left corner) and navigation 
controls (left side).  The page provides the content in the light gray box in the center. 
In this example, the page content is simply static HTML but in a real application the 
content would include other components.
</>

<para>
The Home page component has the following HTML template:
</>

<figure>
	<title>Home Page HTML Template</>
	<programlisting>
&start-jwc; id="border"&end-jwc;<![CDATA[

Nothing much doing here on the <b>home</b> page.  Visit one of our other fine 
pages.

]]>&close-jwc;</programlisting>
</figure>


<para>
In other words, the <varname>border</>
component gets to produce HTML first.  At some point, the page's content 
(wrapped inside the <varname>border</> component) will be produced.  
Afterwards, the <varname>border</> component will have an opportunity to produce more HTML.
The <classname>Border</> component has a much larger HTML template:
</>

<figure>
	<title>Border component HTML template</>
	<programlisting><![CDATA[
<HTML>
<head>
<title>Reusable Component Tutorial</title>
</head>
<body>
<table border=0 bgcolor=gray cellspacing=0>
  <tr valign=top>
    <td colspan=3 align=left>
      <font size=5 color="White">]]>&start-jwc; id="insertPageTitle"/&end-jwc;<![CDATA[</font>
    </td>
  </tr>
  <tr valign=top>
    <td align=right>
      <font color=white>
]]>&start-jwc; id="e"&end-jwc;<![CDATA[
        <br>]]><emphasis><![CDATA[<jwc id="link"><jwc id="insertName"></jwc>
</jwc>]]></emphasis><![CDATA[
      </font>
    </td>
    <td valign=top bgcolor=silver>
      ]]>&start-jwc; id="wrapped"/&end-jwc;<![CDATA[
    </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td colspan=3>&nbsp;</td>
  </tr>
</table>
</body>
</HTML>
]]></programlisting>
</figure>

<para>
The <classname>Border</> component contains five components:

	<itemizedlist>
		<listitem><para><varname>insertPageTitle</></></>
		<listitem><para><varname>e</></></>
		<listitem><para><varname>link</></></>
		<listitem><para><varname>insertName</></></>
		<listitem><para><varname>wrapped</></></>
	</>
</>

<para>
The <varname>e</> component wraps some static HTML and the 
<varname>link</> component.  The 
<varname>link</> component wraps the <varname>insertName</> component.
</>

<para>
When it comes time to render, Tapestry parses the HTML template and breaks 
them into blocks of static HTML, component starts 
(the &jwc-tag; tag) and component ends (the <sgmltag class=endtag>jwc</> tag).
</>

<para>
The framework determines what each component wraps.  
For components with their own templates, such as <classname>Home</> and 
<classname>Border</>, it figures out what the outer elements are, 
the outermost static HTML and components that aren't wrapped by other components.
</>

<para>
This information turns into a data structure:
</>

<figure>
	<title>Border Component Construction</>
	<mediaobject>
		<imageobject>
			<imagedata fileref="images/Border-Construction.gif" format=gif>
		</>
	</>
</>


<para>
The left side shows how the components are embedded.  
The <classname>Home</> page contains the <varname>border</> component.  
The <varname>border</> component contains the other components.
</>

<para>
The outermost elements for the <classname>Home</> page is 
a list of one item: the  <varname>border</> component.  
There's no text before or after the <varname>border</> component's &jwc-tag; tag, 
and the remaining text in the template is wrapped by the <varname>border</> component.
</>

<para>
The <varname>border</> component is 
more complicated; it has several outer elements, 
representing static HTML text and components.  
The other components don't have templates, 
so they don't have outer elements, but some do wrap other components.
</>

<para>
When it's time to render, the process starts in the <classname>Home</> page, since a page
is always the outermost component. 
It iterates through its outer list, which contains a single element: the
<varname>border</> component.  The process then recursively renders the 
<varname>border</> component.  Its outer list is rendered in order.  
Each component decides where it will render its wrapped elements (if it has any).  
The <varname>e</> component is a &Foreach;; 
it will render its wrapped elements any number of times.
</para>


<para>
Eventually, the process reaches the <varname>wrapped</> component, 
which is of type &InsertWrapped;.  
This is a special component; it jumps up one level to its container (the <varname>border</> component)
and renders the <varname>border</>'s wrapped elements ... the text from the <classname>Home</>
page template.
</>

<para>
It may seem complicated, but ultimately its very natural from a markup language point of view; 
the &jwc-tag; tags continue to act like HTML elements, wrapping around and 
controlling their contents, just exactly like a 
<sgmltag class=starttag>table</>
wraps its <sgmltag class=starttag>tr</>'s or a <sgmltag class=starttag>form</> wraps its 
<sgmltag class=starttag>input</>'s.
</>

	</section>

	<section id="components.localization">
		<title>Localization</>

<para>
Tapestry has built in support for localization, designed to be easy to use.  
Tapestry allows multiple versions of HTML templates and assets (described in a later section) 
to be deployed with the application.
</>

<para>Each client connecting to the application will select a particular <classname>Locale</>. 
When a page for the application is created, the locale is used to select the correct template.  
Locales are defined by the ISO (International Standards Organization).  
A locale consists of a language code (such as 'en' for English, 'de' for German or 'fr' for French) 
and a country code (such as 'AU' for Australia, 'BE' for Belguim, or  'GB' for United Kingdom).
</>

<para>
The base template name is derived from the specification name, 
by changing the '.jwc' extension to '.html.  
For example, component <filename>/com/skunkworx/skunkapp/Banner.jwc</>
will have a base template name of  <filename>/com/skunkworx/skunkapp/Banner.html</>.
This resource name is used as the basis of a search that includes the locale.  
Various suffixes are inserted just before the '.html' extension.
</>

<para>
A French speaking Belgian visitor would provoke the following search:
</>

<itemizedlist>
	<listitem>
		<para>
			<filename>/com/skunkworx/skunkapp/Banner_fr_BE.html</>
		</>
	</>

	<listitem>
		<para>
			<filename>/com/skunkworx/skunkapp/Banner_fr.html</>
		</>
	</>

	<listitem>
		<para>
			<filename>/com/skunkworx/skunkapp/Banner.html</>
		</>
	</>
</>


<para>
The Tapestry framework automatically provides this basic level of support.  
To this, an application could add custom logic to allow the locale to be selected at 
runtime, and to store a user's locale preference (in a cookie, or in some form of profile)
for later visits.
</>

	</section>

	<section id="components.assets">
		<title>Assets</>

<para>
Assets are images (GIF, JPEG, etc.), movies, sounds or other collateral associated 
with a web application.  Assets come in three flavors:  external, internal and private.
</>

<para>
External assets live at an arbitrary URL.  Internal assets use a URL within the 
servlet context hosting the Tapestry application; 
these assets are deployed on the same web server as the application, 
or within the same Web Application Archive (WAR).
</para>

<para>
Private assets come from the Java class path and are 
resources not normally visible to the web server.
</>

<para>
Tapestry uses the assets concept to address two areas:  localization and deployment.
</>

<para>
For localization:  internal and private assets are localized, 
just like HTML templates.  That is, the path name provided is 
used as the basis for a search that takes into account the desired locale.  
External assets can't be localized in this way.
</>

<para>
Private assets allow for easy deployment because the assets are 
packaged with the HTML templates and Java code of the application, 
inside a Java Archive (JAR) file, or within the <filename class=directory>WEB-INF/classes</>
directory of a Web Application Archive (WAR) file.
</>

<para>
Private assets support re-usability; a re-usable component may be 
packaged with supporting assets (typically, image files) and used in any 
Tapestry application without change, and without having to locate, extract or 
otherwise fiddle with those assets.
</>

<para>
The Tapestry framework provides two ways of exposing the assets to the client web browser.
</>

<para>
First, it provides a service that will access the asset dynamically.  
The URL encodes the application servlet and the resource to download, 
and Tapestry framework code will pump the bytes down to the client web browser.  
This is the default behavior (and is most useful during development).
</>

<para>
The second method involves copying the asset out to a directory visible 
to the web server, and creating a URL for it in its final location.  
This requires some extra configuration of the application.  
This method also has some implications when deploying new versions of the web application.  
These are addressed later in this document.
</>

	</section>

	<section id="components.specification">
		<title>Component Specification</>

<para>
The component specification is an XML document.  
This discussion assumes a passing familiarity with XML documents.   
The specification is located inside the running Java VMs class path; 
in a deployed application, it will be a package resource, 
located (along with the Java class files) in the 
<filename class=directory>WEB-INF/classes</> 
directory of the WAR (Web Application Archive).
</>

<para>
These specifications can be somewhat verbose, 
it is strongly advised that a DTD-aware XML editor be used, 
rather than hand editting the files.
</>

		<section>
			<title><sgmltag class=starttag>specification</> element
		
<para>
Component specification files, which use the filename extension <literal>.jwc</>, consist of a
<sgmltag class=starttag>specification</> element.
</>
	
<figure>
	<title>Component specification: <sgmltag class=starttag>specification</> element
<programlisting>
<![CDATA[
<?xml version="1.0"?>
<!DOCTYPE specification PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN"
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">
]]>

&lt;specification 
  allow-body="<replaceable>yes</>|<replaceable>no</>" <co id="components.spec.co.allow-body">
  allow-informal-parameters="<replaceable>yes</>|<replaceable>no</>" <co id="components.spec.co.informal">
  class="<replaceable>java-class</>"&gt; <co id="components.spec.co.java-class">
  
  [ &lt;description ...&gt; ...]
  [ &lt;parameter ...&gt; ...]
  [ &lt;property ...&gt; ...]
  [ &lt;component ...&gt; ...]
  [ &lt;<replaceable>asset</> ...&gt; ...]
&lt;/specification&gt;
</programlisting>
</figure>

<para>
<calloutlist>
  <callout arearefs="components.spec.co.allow-body">
  	<para>
  	Whether the component is allowed to have a body, that is, wrap around other components
  	and static HTML.  The default is 'yes', so this attribute is usually ommitted.
  	</>
  </>
  <callout arearefs="components.spec.co.informal">
  	<para>
  	Whether informal parameters are allowed.  Informal parameters are additional parameters
  	beyond the ones formally defined.  These are typically used with components that map
  	directly to an HTML element, to allow additional HTML attributes to be specified.
  	The default is 'yes', so this attribute is usually ommitted.
  	</>
  </>
  <callout arearefs="components.spec.co.java-class">
	<para>
	The complete class name of the component class, 
	for example, <classname>com.skunkworx.skunkapp.Border</>.
	</>
  </>
 </calloutlist>
</>

<note>
	<title>Versions of the DTD</>
	<para>
	There was an earlier version of the DTD, version 1.0, which is the version
	used with Tapestry Release 1.0.0.  Version 1.1 is more succinct and readable
	than version 1.0 and has a few extra features.  Both versions are supported by
	Tapestry until at least release 1.1.0.
	</>
</>

<para>
As previously described, the specification name is used to find the base 
HTML template name (by replacing the '.jwc' extension with '.html').  
</>

<para>
During development, such resources may be in the developer's work areas, 
but when the application is deployed, they will almost always be distributed inside a 
Java Archive (JAR) file or Web Application Archive (WAR) file.  
This is one of the ways that Tapestry eases deployment.
</>

<para>
The <sgmltag class=starttag>specification</> element wraps around all other elements in
the specification (which are used to defined parameters, embedded components and assets).  The following
sections describe these additional elements.

			</section>

			<section>
				<title><sgmltag class=starttag>description</> element
				
<para>
One or more <sgmltag class=starttag>description</> elements may be included in the specification.  These are descriptions of 
the component's features and behavior, suitable for inclusion in some form of IDE.  Multiple descriptions are used to support
multiple languages.
</>


<figure>
	<title>Component specification: <sgmltag class=starttag>description</> element
	<programlisting>
&lt;description 
  xml:lang="<replaceable>language code</>"&gt; <co id="component.specification.description.lang">
  ... <replaceable>text</> ... 
&lt;/description&gt;
</programlisting>
</figure>

<para>
<calloutlist>
	<callout arearefs="component.specification.description.lang">
	<para>
	The language in which the descriptive text is written. This takes the form
	of a two letter code, defined by the ISO-639 standard.
	</>
	</>
</calloutlist>
</>
<note>
	<title><sgmltag class=starttag>description</> usage
	<para>
	The <sgmltag class=starttag>description</> element is really used for future expansion, towards
	a time when an  integrated HTML / Tapestry Specification editor does exist.  
	Also, a Javadoc doclet may be created that can read
	Tapestry specifications and include them with Javadoc.  In the meantime, descriptions can be used
	like XML comments.
	</>
</>

			</section>

			<section>
				<title><sgmltag class=starttag>parameter</> element</>
				
<para>
This element is used to describe formal parameters used by a component.

<figure>
	<title>Component specification: <sgmltag class=starttag>parameter</> element
	<programlisting>
&lt;parameter
  name="<replaceable>name</>" <co id="components.spec.parameter.name">
  java-class="<replaceable>text</>" <co id="components.spec.parameter.java-class">
  required="<replaceable>yes</>|<replaceable>no</>"&gt; <co id="components.spec.parameter.required">
  [ &lt;description ... &gt; ...] <co id="components.spec.parameter.description">
&lt;/parameter&gt;
</programlisting>
</figure>

<para>
<calloutlist>
	<callout arearefs="components.spec.parameter.name">
		<para>
		Each parameter must have a unique name.  
		Parameter names must start with a letter and may contain letters, numbers 
		and the underscore.
		</>
	</>
	<callout arearefs="components.spec.parameter.java-class">
		<para>
		Identifies the Java class or type that must be provided for the parameter.
		This is for descriptive purposes only, there is no validation by the framework.
		Additionally, most components will do their best to cooerce whatever value
		is given them into a useful type, such as parsing a String into an int.
		</>
		<para>
		The <varname>java-type</> attribute is optional.
	</>
	<callout arearefs="components.spec.parameter.required">
		<para>
		If 'yes', then the parameter must be bound when the page is loaded.  The default, 'no',
		allows a parameter to not be bound.
		</>
		<para>
		Individual components may do a second check, that the bound parameter provides a non-null value.
		</>
	</>
	<callout arearefs="components.spec.parameter.description">
		<para>
		Each parameter is allowed to have its own set of localized descriptions.
		</>
	</>
</calloutlist>
</para>


			</section>

			<section>
				<title><sgmltag class=starttag>component</> element</>

<para>
The <sgmltag class=starttag>component</> element is used to describe an embedded component, a
component with a corresponding &jwc-tag; tag in the containing component's HTML template.
</>

<figure>
	<title>Component specification:<sgmltag class=starttag>component</> element
<programlisting>
&lt;component
  id="<replaceable>id</>" <co id="component.spec.component.id">
  type="<replaceable>type</>" <co id="component.spec.component.type">
  copy-of="<replaceable>id</>"&gt; <co id="component.spec.component.copy-of">
  [ &lt;binding|field-binding|inherited-binding|static-binding ...&gt; ... ]
&lt;/component&gt;
</programlisting>
</figure>

<para>
<calloutlist>
  <callout arearefs="component.spec.component.id">
  	<para>
  	Each component must have a unique identifier within its container.  The <varname>id</>
  	attribute must conform to an XML id:  start with a letter, and contain only letters, numbers
  	and underscores.
  	</>
  </>
  
  <callout arearefs="component.spec.component.type">
  	<para>
  	The component type is either the the complete path to a component specification, or a well known alias.
  	All the components provided with the framework have well known aliases, at it is possible
  	to create additional aliases in the Tapestry application specification.
  	</>
  </>
  
  <callout arearefs="component.spec.component.copy-of">
  	<para>
	Instead of specifying a type, a component may be a copy of one of its siblings.  In this case,
	the new component is created by copying the type and bindings of the existing component.  It is possible
	to specify additional bindings as well.
	</>
	<para>
	The component being copied from must be declared first.
	</>
 </calloutlist>
</para>

	<para>
  	You must specify either the <varname>type</> or <varname>copy-of</> attributes, but not both.
  	</>
  	
<para>
Each component must also have a type.  Types are resource paths for a component 
specification.  Specifications end with '.jwc'.  An example would be 
<filename>/com/skunkworx/skunkapp/Banner.jwc</>.
</>

<para>
Unlike HTML templates, specifications are never localized.
</>

<para>
As a convenience, aliases may be defined for components.  
An alias is a short name that takes the place of the specification resource path.  
All built-in components for Tapestry have aliases, and an 
application specification may define additional aliases.
</>

<para>
For example, the component 
<filename>/com/primix/tapestry/links/Action.jwc</>
has a standard alias of &Action;.
</>


		</section>
		
		<section>
			<title>Binding elements
			
<para>
There are four different types of bindings.  The standard binding is most common, as it binds a parameter
to a property of an object, and may be read, write or read/write.

<figure>
	<title>Component specification: binding elements
<programlisting>
&lt;binding
  name="<replaceable>name</>" <co id="components.spec.binding.name">
  property-path="<replaceable>property-path</>"/&gt; <co id="components.spec.binding.path">
  
&lt;field-binding
  name="<replaceable>name</>"
  field-name="<replaceable>field-name</>"/&gt; <co id="components.spec.binding.field-name">
  
&lt;inherited-binding
  name="<replaceable>name</>"
  parameter-name="<replaceable>parameter-name</>"/&gt; <co id="components.spec.binding.parameter-name">
  
&lt;static-binding
  name="<replaceable>name</>"&gt;
  	... <replaceable>value</> ... <co id="components.spec.binding.static-value">
&lt;/static-binding&gt;
</programlisting>
</figure>

<para>
<calloutlist>
	<callout arearefs="components.spec.binding.name">
		<para>
		A name of the parameter to bind.  This usually matches the name of
		a formal parameter of the component.  For components which
		allow informal parameters, this may be any value.
		</>
	</>
	<callout arearefs="components.spec.binding.path">
		<para>
		The name of a property reachable from the containing component.
		</>
	</>
	<callout arearefs="components.spec.binding.field-name">
		<para>
		The name of a public static field.  This takes the form
		<replaceable>class name</>.<replaceable>field name</>.  The class name is the complete
		class name (including the package names), unless the package is <varname>java.lang</>, in which
		case the package portion can be ommitted.
		</>
		<para>
		Field bindings are often more useful than static bindings, because the value does't have to
		be a convertable from a string.  This means true objects, not just holders of single values,
		can be used, this is quite useful when dealing with the form element components.
		</>
	</>
	<callout arearefs="components.spec.binding.parameter-name">
		<para>
		The name of a formal or informal parameter of the containing component.  The contained component
		will share the same binding.  This is one of the ways in which it is possible to build complex
		components by combining simple ones.
		</>
	</>
	<callout arearefs="components.spec.binding.static-value">
		<para>
		Unlike the other binding types, the <sgmltag class=starttag>static-binding</> element
		wraps around its static value, which allows for maximum flexibility.  It does, however,
		remove all leading and trailing whitespace from the value.
		</>
	</>
</calloutlist>
</para>

<para>
An example of using an
<sgmltag class=starttag>inherited-binding</> is the <classname>Border</> component, 
which has a <varname>title</> parameter that gives the name of the page.  
The <classname>Border</> component embeds an &Insert; component, 
and uses an inherited binding to set the 
&Insert; component's <varname>value</> parameter to the 
containing <classname>Border</> component's <varname>title</> parameter.
</>

			</section>

			<section>
				<title>Asset elements</>

<para>
Assets are a way of identifying resources whose URLs will appear in a web page.  
Most often, the assets are image files used with an &Image; or 
&Rollover; components.
</>


<figure>
	<title>Component specification: Asset elements
	
<programlisting>
&lt;context-asset
	name="<replaceable>name</>"
	path="<replaceable>path</>"/&gt;
	
&lt;external-asset
	name="<replaceable>name</>"
	URL="<replaceable>URL</>"/&gt;
	
&lt;private-asset
	name="<replaceable>name</>"
	resource-path="<replaceable>resource-path</>"/&gt;
</programlisting>
</figure>

<para>
Assets may be stored at some arbitrary URL, may be within the same web application context as the 
Tapestry application, or may be stored as a resource inside Java VM class path.
</>

<para>
In all three cases, the name must be very simple:  
start with a letter and contain only letters, numbers and underscores or dashes.  
Assets names must be unique within the component.
</>

<para>
For external assets, the URL must be complete:  it will be inserted into the HTML unchanged.  In many cases,
the URL can omit the <literal>http://<replaceable>hostname</></> portion of the URL, if the asset is located
on the same host as the web application.
</>

<para>
For context assets
the path must be relative to the servlet context.  
Context assets may be localized; this will be reflected in the 
actual file chosen and in the URL inserted into the HTML.  
The final URL inserted into the HTML will include the servlet context prefix and may reflect 
a localized path.
</>

<para>
For private assets, the resource path must be a resource path within the 
Java VM class path, as with a specification or HTML template resource path.  
This means the asset can be stored in the 
<filename class=directory>WEB-INF/classes</> directory of the application's WAR, 
or inside some JAR in the classpath.  Like context assets, private assets may be localized.
</>
		</section>
	</section>
</chapter>

<?xml version="1.0" encoding="utf-8"?>
<!-- $Id$ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN"
  "http://www.oasis-open.org/docbook/xml/4.1/docbookx.dtd" [
  <!-- Useful snippets -->
  <!ENTITY jwc-tag "<sgmltag class='starttag'>jwc</sgmltag>">
  <!ENTITY % TapestryLinks SYSTEM "../common/TapestryLinks.xml">
  %TapestryLinks;
  <!ENTITY Action '<link linkend="builtin.Action"><classname>Action</classname></link>'>
  <!ENTITY Block '<link linkend="builtin.Block"><classname>Block</classname></link>'>
  <!ENTITY Checkbox '<link linkend="builtin.Checkbox"><classname>Checkbox</classname></link>'>
  <!ENTITY Body '<link linkend="builtin.Body"><classname>Body</classname></link>'>
  <!ENTITY Conditional '<link linkend="builtin.Conditional"><classname>Conditional</classname></link>'>
  <!ENTITY Direct '<link linkend="builtin.Direct"><classname>Direct</classname></link>'>
  <!ENTITY ExceptionDisplay '<link linkend="builtin.ExceptionDisplay"><classname>ExceptionDisplay</classname></link>'>
  <!ENTITY Foreach '<link linkend="builtin.Foreach"><classname>Foreach</classname></link>'>
  <!ENTITY Form '<link linkend="builtin.Form"><classname>Form</classname></link>'>
  <!ENTITY Hidden '<link linkend="builtin.Hidden"><classname>Hidden</classname></link>'>
  <!ENTITY ListEdit '<link linkend="builtin.ListEdit"><classname>ListEdit</classname></link>'>
  <!ENTITY Image '<link linkend="builtin.Image"><classname>Image</classname></link>'>
  <!ENTITY Insert '<link linkend="builtin.Insert"><classname>Insert</classname></link>'>
  <!ENTITY InsertBlock '<link linkend="builtin.InsertBlock"><classname>InsertBlock</classname></link>'>
  <!ENTITY InsertText '<link linkend="builtin.InsertText"><classname>InsertText</classname></link>'>
  <!ENTITY InsertWrapped '<link linkend="builtin.InsertWrapped"><classname>InsertWrapped</classname></link>'>
  <!ENTITY Option '<link linkend="builtin.Option"><classname>Option</classname></link>'>
  <!ENTITY Page '<link linkend="builtin.Page"><classname>Page</classname></link>'>
  <!ENTITY PropertySelection '<link linkend="builtin.PropertySelection"><classname>PropertySelection</classname></link>'>
  <!ENTITY Radio '<link linkend="builtin.Radio"><classname>Radio</classname></link>'>
  <!ENTITY RadioGroup '<link linkend="builtin.RadioGroup"><classname>RadioGroup</classname></link>'>
  <!ENTITY Rollover '<link linkend="builtin.Rollover"><classname>Rollover</classname></link>'>
  <!ENTITY Script '<link linkend="builtin.Script"><classname>Script</classname></link>'>
  <!ENTITY Select '<link linkend="builtin.Select"><classname>Select</classname></link>'>
  <!ENTITY Service '<link linkend="builtin.Service"><classname>Service</classname></link>'>
  <!ENTITY ShowInspector '<link linkend="builtin.ShowInspector"><classname>ShowInspector</classname></link>'>
  <!ENTITY Text '<link linkend="builtin.Text"><classname>Text</classname></link>'>
  <!ENTITY TextField '<link linkend="builtin.TextField"><classname>TextField</classname></link>'>
  <!ENTITY Upload '<link linkend="builtin.Upload"><classname>Upload</classname></link>'>
  <!ENTITY ValidField '<link linkend="builtin.ValidField"><classname>ValidField</classname></link>'>
]>
<!-- Conventions:

	Component ids are <varname>
	Java packages and class names are <classname>
	Tapestry component aliases are <classname>

	In-line code snippets use <function>
	Property paths and JavaBeans property names used <varname>
-->
<book>
  <title>Tapestry Developer's Guide</title>
  <bookinfo>
    <author>
      <firstname>Howard</firstname>
      <surname>Lewis Ship</surname>
    </author>
    <copyright>
      <year>2000</year>
      <year>2001</year>
      <year>2002</year>
      <holder>Howard M. Lewis Ship</holder>
    </copyright>
  </bookinfo>
  <chapter id="intro">
    <title>Introduction</title>
    <para>Tapestry is a comprehensive web application framework, written in Java.</para>
    <para>Tapestry is not an application server.  
Tapestry is a framework designed to be used inside an application server.</para>
    <para>Tapestry is not an application.  Tapestry is a framework for creating web applications.</para>
    <para>Tapestry is not a way of using JavaServer Pages.  
Tapestry is an alternative to using JavaServer Pages.</para>
    <para>Tapestry is not a scripting environment.  Tapestry uses a component object model, 
not simple scripting, to create highly dynamic, interactive web pages.</para>
    <para>Tapestry is based on the Java Servlet API version 2.2  It is compatible with JDK 1.2 and above.   
Tapestry uses a sophisticated component model to divide a web application into a hierarchy of components.  
Each component 
has specific responsibilities for rendering web pages (that is, generating a portion of an HTML page) 
and responding to HTML queries (such as clicking on a link, or submitting a form).</para>
    <para>The Tapestry framework takes on virtually all of the responsibilities 
for managing application flow and server-side client state.  
This allows developers to concentrate on the business and presentation aspects of the application.</para>
    <section id="intro.scripting">
      <title>Scripting vs. Components</title>
      <para>Most leading web application frameworks are based on some form of 
scripting.  These frameworks (often bundled into a web or application server) include:

	<itemizedlist mark="opencircle">
          <listitem>
            <para>
              <ulink url="http://java.sun.com/products/jsp/">Sun JavaServer Pages</ulink>
            </para>
          </listitem>
          <listitem>
            <para>Microsoft Active Server Pages</para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.macromedia.com/software/coldfusion/">Allaire ColdFusion</ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.php.net/">PHP</ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.webmacro.org/">WebMacro</ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://freemarker.sourceforge.net/">FreeMarker</ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://jakarta.apache.org/velocity/index.html">Velocity</ulink>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>All of these systems are based on reading an HTML template file
and performing some kind of processing on it.  The processing is identified by directives ... 
special tags in the HTML template that indicate dynamic behavior.</para>
      <para>Each framework has a scripting language.  For JavaServer Pages it is Java itself.  
For ASP it is Visual Basic.  Most often, the directives are snippets of 
the scripting language inserted into the HTML.</para>
      <para>For example, here's a snippet from a hypothetical 
JavaServer Page that displays part of a shopping cart.
</para>
      <informalexample>
        <programlisting>
<emphasis>&lt;%
	String userName = (String)session.getAttribute("userName");
%&gt;</emphasis>
&lt;h1&gt;Contents of shopping cart for 
<emphasis>&lt;%= userName %&gt;</emphasis>:&lt;/h1&gt;
</programlisting>
      </informalexample>
      <para>Most of the text is static HTML that is sent directly back to the client web browser.  
The <emphasis>emphasised</emphasis> text identifies scripting code.</para>
      <para>The first large block is used to extract the user name from the &HttpSession;, 
a sort of per-client scratch pad (it is part of the Java Servlet API; 
other systems have some similar construct).  
The second block is used to insert the value of an expression into the HTML.  
Here, the expression is simply the value of the userName variable.  
It could be more complex, including the result of invoking a method on a Java object.</para>
      <para>This kind of example is often touted as showing how useful and powerful scripting solutions are.  
In fact, it shows the very weaknesses of scripting.</para>
      <para>First off, we have a good bit of Java code in an HTML file.  
This is a problem ... no HTML editor is going to understand the JavaServer Pages syntax, 
or be able to validate that the Java code in the scripting sections is correct, or that it even compiles.  
Validation will be deferred until the page is viewed within the application.  
Any errors in the page will be shown as runtime errors.  
Having Java code here is unnatural ... Java code should be developed exclusively inside an IDE.</para>
      <para>In a real JavaServer Pages application I've worked on, each JSP file was 30% - 50% Java.  
Very little of the Java was simple presentation logic like 
<sgmltag class="starttag">%= userName %</sgmltag>, 
most of it was larger blocks needed to 'set up' the presentation logic.  
Another good chunk was concerned with looping through lists of results.</para>
      <para>In an environment with separate creative and technical teams, 
nobody is very happy.  The creative team is unlikely to know JSP or Java syntax.  
The technical team will have difficulty "instrumenting" the HTML files provided by creative team.  
Likewise, the two teams don't have a good common language 
to describe their requirements for each page.</para>
      <para>One design goal for Tapestry is minimal impact on the HTML.  
Many template-oriented systems add several different directives 
for inserting values into the HTML, marking blocks as conditional, 
performing repetitions and other operations.  
Tapestry works quite differently; it allows existing tags to be marked
as dynamic in a completely unobtrusive way.</para>
      <para>A Tapestry component is any HTML tag with a <varname>jwcid</varname>
attribute ("jwc" stands for "Java Web Component").
For comparison, an equivalent Tapestry template to the previous JSP example:
</para>
      <informalexample>
        <programlisting><![CDATA[
<h1>Contents of shopping cart for
<span jwcid="insertUserName">John Doe</span>:</h1>
]]></programlisting>
      </informalexample>
      <para>This defines a component named <varname>insertUserName</varname> on the page.
To assist HTML development, a sample value, "<literal>John Doe</literal>" is included, but
this is automatically editted out when the HTML template is used by the framework.
</para>
      <para>
The <sgmltag class="starttag">span</sgmltag> tag simply indicated where the Tapestry component
will go ... it doesn't identify any of its behavior.  That is provided elsewhere, in
a <link linkend="components.specification">component specification</link>.
</para>
      <para>A portion of the page's specification file defines what
the <varname>insertUserName</varname> component is and what it does:
</para>
      <informalexample id="intro.ex">
        <programlisting>
&lt;component id="insertUserName" type="Insert"&gt; <co id="intro.ex.co.id-and-type"/>
  &lt;binding name="value" property-path="visit.userName"/&gt;  <co id="intro.ex.co.value-binding"/>
&lt;/component&gt;
</programlisting>
        <calloutlist>
          <callout arearefs="intro.ex.co.id-and-type">
            <para>
		The <varname>id</varname> attribute gives the component a unique identifier, that matches against the
		HTML template.  The <varname>type</varname> attribute is used to specify which kind of component
		is to be used.
		</para>
          </callout>
          <callout arearefs="intro.ex.co.value-binding">
            <para>
		Bindings identify how the component gets the data it needs.  In this example, 
		the &Insert; component requires a binding for its <varname>value</varname>
		parameter, which is what will be inserted into the response HTML page.  This
		type of binding (there are others), extracts the userName property from the
		visit object (a central, application-defined object used to store most
		server-side state in a Tapestry application).
		</para>
          </callout>
        </calloutlist>
      </informalexample>
      <para>Tapestry really excels when it is doing something 
more complicated than simply producing output.  
For example, let's assume that there's a checkout button that should only 
be enabled when the user has items in their shopping cart.</para>
      <para>In the JSP world, this would look something like:
</para>
      <informalexample>
        <programlisting><emphasis>&lt;%
   boolean showLink;
   String imageURL;
   showLink = applicationObject.getHasCheckoutItems();
   if (showLink)
     imageURL = "/images/Checkout.gif";
   else
     imageURL = "/images/Checkout-disabled.gif";

  if (showLink)
  {
     String linkURL;
     linkURL = response.encodeURL("/servlet/checkout"); %&gt;</emphasis>
&lt;a href="<emphasis>&lt;%= linkURL %&gt;</emphasis>"&gt;
<emphasis>&lt;% } %&gt;</emphasis>
&lt;img border=0 src="<emphasis>&lt;%= imageURL %&gt;</emphasis>" alt="Checkout"&gt;<emphasis>&lt;%
  if (showLink)
    out.println("&lt;/a&gt;");
%&gt;</emphasis>
</programlisting>
      </informalexample>
      <para>This assumes that <varname>applicationObject</varname> exists to 
determine whether the user has entered any checkout items.  
Presumably, this object was provided by a controlling servlet, or placed into the 
&HttpSession;.
</para>
      <para>
The corresponding Tapestry HTML template is much simpler:
</para>
      <informalexample>
        <programlisting><emphasis><![CDATA[
<a jwcid="checkoutLink"><img jwcid="checkoutButton"/></a>]]></emphasis>
        </programlisting>
      </informalexample>
      <para>
A bit more goes into the page's specification :
</para>
      <informalexample id="intro.ex2">
        <programlisting>&lt;component id="checkoutLink" type="Page"&gt; <co id="intro.ex2.co.checkoutLink"/>
  &lt;static-binding name="page"&gt;Checkout&lt;/static-binding&gt;
  &lt;binding name="disabled" property-path="visit.cartEmpty"/&gt; <co id="intro.ex2.co.link-disabled"/>
&lt;/component&gt;

&lt;component id="checkoutButton" type="Rollover"&gt; <co id="intro.ex2.co.Rollover"/>
  &lt;binding name="image" property-path="assets.checkout"/&gt;
  &lt;binding name="disabled" property-path="assets.checkout-disabled"/&gt; 
  &lt;static-binding name="alt"&gt;Checkout&lt;/static-binding&gt;
&lt;/component&gt;

&lt;external-asset name="checkout" URL="/images/Checkout.gif"/&gt; <co id="intro.ex2.co.checkout-asset"/>
&lt;external-asset name="checkout-disabled" URL="/images/Checkout-disabled.gif"/&gt;

</programlisting>
        <calloutlist>
          <callout arearefs="intro.ex2.co.checkoutLink">
            <para>
    Component <varname>checkoutLink</varname> is a &Page;, a component that creates
    a link to another page in the application.  Tapestry takes care of generating the
    appropriate URL.
    </para>
          </callout>
          <callout arearefs="intro.ex2.co.link-disabled">
            <para>
  	The <varname>disabled</varname> parameter allows the link to be "turned off"; here it is turned
  	off when the shopping cart is empty.
  	</para>
          </callout>
          <callout arearefs="intro.ex2.co.Rollover">
            <para>
    A &Rollover; component inserts an image; it must be inside some kind of
    link component (such as the &Page;) and is sensitive to whether the link
    is enabled or disabled; inserting a different image when disabled.  Not shown here
    is the ability of the &Rollover; component to 
    generate dynamic mouse over effects as well.
    </para>
          </callout>
          <callout arearefs="intro.ex2.co.checkout-asset">
            <para>
  	Tapestry uses an abstraction, <link linkend="components.assets">assets</link>,
  	to identify images, stylesheets
  	and other resources.  The &Rollover; component wants a reference to
  	an asset, not a URL.
  	</para>
          </callout>
        </calloutlist>
      </informalexample>
      <para>
The point of this example is that the JSP developer had to worry about character-by-character 
production of HTML.  Further,  the ratio of Java code to HTML is quickly getting out of hand.
</para>
      <para>
By contrast, the Tapestry developer is concerned with the behavior of 
components and has an elegant way of specifying that behavior dynamically.
</para>
    </section>
    <section id="intro.interaction">
      <title>Interaction</title>
      <para>
Let's continue with a portion of the JSP that would allow an 
item to be deleted from the shopping cart.  
For simplicity, we'll assume that there's an object of class <classname>LineItem</classname> 
named <varname>item</varname> and that there's a servlet used for making changes to the shopping cart. 
</para>
      <informalexample>
        <programlisting><![CDATA[
<tr> <td> ]]><emphasis>&lt;%= item.getProductName() %&gt;</emphasis><![CDATA[</td>
	 <td> ]]><emphasis>&lt;%= item.getQuantity() %&gt;</emphasis><![CDATA[</td>
	 <td> 
]]><emphasis>&lt;%  String URL = response.encodeURL("/servlet/update-cart?action=remove" +
 			"&amp;item=" + item.getId());
%&gt;</emphasis><![CDATA[
<a href="]]><emphasis>&lt;%= URL %&gt;</emphasis><![CDATA[">Remove</a> </td> </tr>]]></programlisting>
      </informalexample>
      <para>
This clearly shows that in a JSP application, the designer is responsible for 
"knitting together" the pages, servlets and other elements at a very low level.  
By contrast, Tapestry takes care of nearly all these issues automatically:
</para>
      <informalexample>
        <programlisting><![CDATA[
<tr> <td> ]]><sgmltag class="starttag">span jwcid="insertName"/</sgmltag><![CDATA[ </td>
	 <td> ]]><sgmltag class="starttag">span jwcid="insertQuantity"/</sgmltag>;<![CDATA[ </td>
	 <td> ]]><sgmltag class="starttag">a jwcid="remove"</sgmltag>Remove<sgmltag class="endtag">a</sgmltag><![CDATA[ </td> </tr>]]></programlisting>
      </informalexample>
      <para>
Because of the component object model used by Tapestry, the framework knows exactly 
"where on the page" the <varname>remove</varname> component is.  
It uses this information to build an appropriate URL that references the <varname>remove</varname> component.  
If the user clicks the link, the framework will inform the component to perform the desired action.  
The <varname>remove</varname> component can then remove the item from the shopping cart.
</para>
      <para>
In fact, under Tapestry, no user code ever has to either encode or decode a URL.  
This removes an entire class of errors from a web application 
(those URLs can be harder to assemble and parse than you might think!)
</para>
      <para>
Tapestry isn't merely building the URL to a servlet for you; 
the whole concept of 'servlets' drops out of the web application.  
Tapestry is building a URL that will invoke a method on a component.
</para>
      <para>
Tapestry applications act like a 'super-servlet'.  
There's only one servlet to configure and deploy.  
By contrast, even a simple JavaServer Pages application developed using 
Sun's Model 2 (where servlets provide control logic and JSPs are used for presenting results) 
can easily have dozens of servlets.  
</para>
    </section>
    <section id="intro.security">
      <title>Security</title>
      <para>
Developing applications using Tapestry provides some modest security benefits.
</para>
      <para>
Tapestry applications are built on top of the Java Servlet API, 
and so inherits all the sercurity benefits of servlets.  
Most security intrusions against CGI programs 
(such as those written in Perl or other scripting languages) 
rely on sloppy code that evaluates portions of the URL in a system shell; 
this never happens when using the Java Servlet API.
</para>
      <para>
Because the URLs created by Tapestry for processing client interaction 
are more strongly structured than the URLs 
in traditional solutions, there are fewer weaknesses 
to exploit.  Improperly formatted URLs result in an exception response 
being presented to the user.  Tapestry URLs are also harder to spoof, 
since they are very conversational ... the exact form of the 
URL is dependent on any or all of the previous interactions between 
the client and the server in the same session.
</para>
      <para>
Where the Java Servlet API suffers is in client identification, 
since a session identifier is stored on the client either as an 
HTTP Cookie or encoded into each URL.  Malicious software could acquire 
such an identifier and "assume" the identity of a user who has recently logged 
into the application.  Still, because of the conversational nature 
of the Tapestry URLs it would be difficult for an 
automated intruder to progress through the application from that point.
</para>
      <para>
Finally, Tapestry applications have a single flow of control:  
all incoming requests flow through a few specific methods of particular classes.  
This makes it easier to add additional security measures that are specific to the application.
</para>
    </section>
    <section id="intro.features">
      <title>Features</title>
      <para>
The framework, based on the component object model, provides a significant number of other features, 
including:

	<itemizedlist>
          <listitem>
            <para>Easy localization of applications</para>
          </listitem>
          <listitem>
            <para>Extremely robust error handling and reporting</para>
          </listitem>
          <listitem>
            <para>Highly re-usable components</para>
          </listitem>
          <listitem>
            <para>Automatic persistence of server-side client state between request cycles</para>
          </listitem>
          <listitem>
            <para>Powerful processing of HTML forms</para>
          </listitem>
          <listitem>
            <para>Strong support for load balancing and fail over </para>
          </listitem>
          <listitem>
            <para>Zero code generation
				<footnote>
                <para>That is, Tapestry templates and specifications are interpreted as is.
					Unlike JSPs, they are not translated into Java source code
					and compiled into Java classes.
					</para>
              </footnote>
            </para>
          </listitem>
          <listitem>
            <para>Easy deployment</para>
          </listitem>
          <listitem>
            <para>The Inspector, which allows developers to debug a running Tapestry application</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
The point of Tapestry is to free the web application developer from the most tedious tasks.  
In many cases, the "raw plumbing" of a web application can be completely mechanized by 
the framework, leaving the developer to deal with more interesting challenges, such 
as business and presentation logic.
</para>
      <para>
As Tapestry continues to develop, new features will be added.  On the drawing board are:

	<itemizedlist>
          <listitem>
            <para>Support for easy cross-browser DHTML</para>
          </listitem>
          <listitem>
            <para>XML / XHTML support</para>
          </listitem>
          <listitem>
            <para>Improved WAP / WML support</para>
          </listitem>
          <listitem>
            <para>A real-time performance "Dashboard"</para>
          </listitem>
          <listitem>
            <para>Journaling / Playback</para>
          </listitem>
        </itemizedlist>
      </para>
    </section>
  </chapter>
  <chapter id="webapp">
    <title>Web Applications</title>
    <para>
Tapestry has a very strong sense of what an application is, derived from an 
XML specification file.  This file identifies and gives names to 
all the pages in the application, and identifies certain other key classes as well.  
It also gives a human-readable name to the entire application.
</para>
    <para>
In other systems, there is no application per-se.  There is some kind of  
'home page' (or servlet), which is the first page seen when a client 
connects to the web application.  There are many pages, servlets (or equivalent, 
in other frameworks) and interrelations between them.  There is also some amount 
of state stored on the server, such as the user name and a shopping 
cart (in a typical e-commerce application).  The sum total of these 
elements is the web application.
</para>
    <para>
Tapestry imposes a small set of constraints on the developer, chiefly, that the application 
be organized in terms of pages and components.  These constraints are 
intended to be of minimal impact to the developer, imposing an acceptible amount of 
structure.  They create a common language that can be used between members 
of a team, and even between the technical and creative groups within a team.
</para>
    <para>
Under Tapestry, a page is also very well defined:  It consists of a component 
specification, a corresponding Java class, an HTML template, and a 
set of contained components.
</para>
    <para>
By contrast, when using JavaServer Pages there are one or more servlets, embedded JavaBeans, 
a JSP file and the Java class created from the JSP file.  There isn't 
a standard naming scheme or other way of cleanly identifying the 
various elements.
</para>
    <para>
Interactivity in Tapestry is component based.  If a component is interactive, such as 
an image button with a hyperlink (<sgmltag class="starttag">a</sgmltag>), clicking on the link 
invokes a method on the component.  All interactivity on a 
page is implemented by components on the page.
</para>
    <para>
JavaServer Pages bases its interactivity on servlets.  Interactive portions of a page must 
build URLs that reference these servlets.  The servlets use a variety of ad-hoc 
methods to identify what operation is to take place when a link is clicked.  Since there 
is no standard for any of this, different developers, even on the same project, 
may take widely varying approaches to implementing similar constructs.
</para>
    <para>
Because pages are components, they have a well-defined interface, which describes to 
both the framework and the developer how the page fits into the overall application.
</para>
    <para>
At the core of any Tapestry application are two objects:  the engine and the visit.  
The engine is created when the first request from a client arrives at the server.  
The engine is responsible for all the mundane tasks in Tapestry, such as managing the request cycle.  
It is sort of a dispatcher, that handles the incoming request and runs the 
process of responding to the request with a new HTML page.
</para>
    <para>
The visit is a second object that contains application-specific data and logic.  
Its type is completely defined by the application.  
In an e-commerce application, the visit might store a shopping cart 
and information about the user (once logged in).
</para>
    <para>
Both the engine and the visit are stored persistently between request cycles, inside the 
&HttpSession; object.
</para>
    <para>
The engine also provides services.  Services are the bridge between URLs and components.  
Services are used to generate the URLs used by hyperlinks and form submissions.  
They are also responsible for interpreting the same URLs when they are later 
triggered from the client web browser.
</para>
  </chapter>
  <chapter id="beans">
    <title>JavaBeans and Properties</title>
    <para>
The Tapestry framework is based upon the use of 
<ulink url="http://java.sun.com/j2se/1.3/docs/api/java/beans/package-summary.html">JavaBeans</ulink>
and JavaBeans properties.  This chapter is a short review
of these concepts.  A more 
involved discussion is available as part of the
<ulink url="http://java.sun.com/docs/books/tutorial/javabeans/index.html">Java Tutorial</ulink>.
</para>
    <section id="beans.beans">
      <title>JavaBeans</title>
      <para>
The JavaBeans framework is a way of manipulating Java objects when their exact type is not known.  The
ability to make objects work together, when their exact type is not known, is very powerful.  It's an example
of the kind of flexibility availble in a highly dynamic language like Java that is not possible in
lower-level languages such as C++.
</para>
      <para>
The JavaBeans framework is the basis for a number of component-based frameworks, including Java's AWT and Swing GUI
libraries, as well as Tapestry.  The idea is that, by following a few naming rules and coding
conventions, it is possible to "plug into" a framework with new classes, classes not even written yet
when the framework is created.  In Tapestry terms, this is used to allow the creation of new Tapestry components.
</para>
      <para>
Any Java object can act as a JavaBean; it just has to follow certain naming conventions (discussed in
<link linkend="beans.properties">the next section</link>).  In cases where a framework needs to create new
instances of a class, such as when Tapestry creates a new instance of a component,
the Java class must implement a public, no arguments constructor (it may implement additional constructors as
well).
</para>
      <para>
The <ulink url="http://java.sun.com/j2se/1.3/docs/api/java/lang/reflect/package-summary.html">Java Reflection API</ulink> allows Tapestry to access the methods, attributes and constructors of a class.
</para>
    </section>
    <section id="beans.properties">
      <title>JavaBeans Properties</title>
      <para>
For Tapestry, the central concept for JavaBeans are properties.  The JavaBeans framework allows Tapestry to
treat any object as a collection of named properties.  Tapestry frequently reads, and occasionally writes, values
from or to these named properties.
</para>
      <para>
A property is <emphasis>not</emphasis> the same as an <emphasis>attribute</emphasis> ... though, most often, each property is backed up by an attribute.  To Tapestry, and the Reflection API, a property is a set public methods on the object.  Accessing a property involves invoking one of these methods.
</para>
      <example>
        <title>JavaBeans getter method</title>
        <programlisting>
public <replaceable>type</replaceable> get<replaceable>Name</replaceable>()
{
  ...
}
</programlisting>
      </example>
      <example>
        <title>JavaBeans setter method</title>
        <programlisting>
public void set<replaceable>Name</replaceable>(<replaceable>type</replaceable> value)
{
  ...
}
</programlisting>
      </example>
      <para>
A property may be read-only or write-only (that is, it may implement just one of the
two methods).  The <replaceable>type</replaceable> may be a scalar type (boolean, int, etc.)
or any Java class.
</para>
      <para>
Note the naming; the first letter of the property name is capitalized after <literal>get</literal>
or <literal>set</literal>.  JavaBeans properties are case sensitive with respect to the method names
and the property names.  A special case exists when the name is an acronyn; this is recognized
by two or more upper-case letters in a row (after get or set); in this case, the property name
does <emphasis>not</emphasis> have the first letter convert to lower-case.
</para>
      <para>
As a special case, a boolean property may use an alternate name for the getter method:
</para>
      <example>
        <title>JavaBeans getter method (boolean)</title>
        <programlisting>
public boolean is<replaceable>Name</replaceable>()
{
  ...
}
</programlisting>
      </example>
      <para>
Although the normal implementation is to get or set an instance variable, more complicated options are
possible.  One pattern is <emphasis>lazy evaluation</emphasis>, where an expensive calculation is
put off until the actual value is needed, for example:
</para>
      <example>
        <title>Lazy evaulation of JavaBeans property</title>
        <programlisting>

public List userNames = null;

/**
 *  Returns a List of user names obtained from the database.
 *
 */

public List getUserNames()
{
  if (userNames == null)
    userNames = fetchUserNamesFromDatabase();

  return userNames;
}
</programlisting>
      </example>
      <para>
Here, the first time the method is invoked, the expensive database fetch occurs.  The value
returned from the database is then cached for later invocations.
</para>
      <para id="beans.properties.synthesized">
Another common pattern is a <emphasis>synthesized property</emphasis>.  Here, there is no
real attribute at all, the value is always computed on the fly.  A frequent use of this is to
avoid tripping over null pointers.
</para>
      <example>
        <title>Synthesized JavaBeans Property</title>
        <programlisting>
/**
 *  Returns the name of the company's account representative, if
 *  if the company has one, or null otherwise.
 *
 */

public String getAccountRepName()
{
  AccountRep rep = company.getAccountRep();

  if (rep == null)
    return null;
  
  return rep.getName();
}
</programlisting>
      </example>
      <para>
This example creates a synthetic property, <varname>accountRepName</varname>.
</para>
    </section>
    <section id="beans.property-path">
      <title>Property Paths</title>
      <para>
The JavaBeans framework provides basic named properties for JavaBean objects.  Tapestry
extends this from simple properties to <emphasis>property paths</emphasis>.
</para>
      <para>
A property path is a series of property names, separated by periods.  When reading a property path, each
property is read in series.
</para>
      <para>
In the <link linkend="intro.ex">example from the introduction</link>, the property path <varname>visit.userName</varname>
was referenced.  This path means that the <varname>visit</varname> property of the start object (a Tapestry page) should be accessed, then the <varname>userName</varname> property of the visit object should
be accessed.  This is approximately the same as Java code
<literal>getVisit().getUserName()</literal> (except that property access is not typesafe).
</para>
      <para>
In some cases, property paths are used to change a value, instead of reading it.  When this occurs, all properties
but the last a read; only the last property is written.  In other words, updating <varname>visit.userName</varname>
would be similar to the JavaCode <literal>getVisit().setUserName(<replaceable>value</replaceable>)</literal>.
</para>
      <para>
Property paths can be of any length; however, they are just as suseptible to <classname>NullPointerException</classname>s
as any other JavaCode.  Care must be taken that none of the properties in a property path, except the final one, return null.  This can often be accomplished using <link linkend="beans.properties.synthesized">synthesized properties</link>
      </para>
      <para>
The Tapestry class &PropertyHelper; is used to streamline property path access to objects.  It also provides hooks that
allow for non-conforming access ... allowing non-JavaBeans to behave like JavaBeans.  For example, a built-in hook allows
the keys stored in a &Map; to appear as named properties.
</para>
    </section>
  </chapter>
  <chapter id="components">
    <title>Tapestry Components</title>
    <para>
Tapestry components are "black boxes" that are involved with both rendering 
HTML responses and responding to HTTP requests.
</para>
    <para>
A Tapestry component is defined by its specification.  
The specification is an XML file that defines the type of the component, it parameters, 
the template used by the component, any components embedded within it and 
how they are 'wired up', and (less often) any assets used by the component.
</para>
    <para>
At runtime, the specification is used to identify and instantiate a class 
for the component.  When the page containing the component is rendered, the 
component will access its HTML template to find the static HTML and embedded 
components it will render.
</para>
    <section id="components.params">
      <title>Parameters and Bindings</title>
      <para>
Tapestry components are designed to work with each other, 
within the context of a page and application.  The process of rendering a page 
is largely about pulling information from a source into a component  
and doing something with it.
</para>
      <para>
For example, on a welcome page, a component might get the <varname>userName</varname> property from 
the <varname>visit</varname> object and insert it into the HTML response.
</para>
      <para>
Each component has a specific set of parameters.  
Parameters have a name, a type and may be required or optional.
</para>
      <para>
To developers experienced with Java GUIs, it may appear that Tapestry 
component parameters are the same as JavaBeans properties.  This is not completes true.  
JavaBeans properties are set-and-forget; the designer sets a value 
for the property using a visual editor and the value 
is saved with the bean until it is used at runtime.
</para>
      <para>
Parameters define the type of value needed, but not the actual value.  
This value is provided by a special object called a binding.  
The binding is a bridge between the component and the parameter value,
exposing that value to the component as it is needed.
</para>
      <para>
A binding is a source and sink of data.  A component 
uses a binding to import or export a data value.
</para>
      <para>
There are two types of bindings:  static and dynamic.  
Static bindings are read-only; the value for the binding is 
specified in the component specification. 
</para>
      <para>
Dynamic bindings are more prevalent and useful.  A dynamic 
binding uses a JavaBeans property name to retrieve the value when needed 
by the component.  The source of this data is a property of some component.
</para>
      <para>
In fact, dynamic bindings use
<link linkend="beans.property-path">property paths</link>, allowing
a  binding to 
'crawl' deeply through an object graph to access the value it needs.  
This frees the components from relying totally on the properties of their container, 
instead they are free to access properties of more distant objects.
</para>
    </section>
    <section id="components.informal-parameters">
      <title>Formal vs. Informal Parameters</title>
      <para>
Tapestry components have two types of parameters: formal and informal.
</para>
      <para>
Formal parameters are parameters defined in the 
<link linkend="components.spec.parameter">component specification</link>.  
Each formal parameter has a specific
(case sensitive) name and may be required or optional.
</para>
      <para>
In many cases, there is a one-to-one mapping between a Tapestry component and a specific
HTML tag.  For example, &Body; and <sgmltag class="starttag">body</sgmltag>,
&Form; and <sgmltag class="starttag">form</sgmltag>, etc.  In other cases, a Tapestry component
produces a known single HTML tag.  For example, &Action;, &Direct;, &Page; and &Service;
all produce an <sgmltag class="starttag">a</sgmltag> tag.
</para>
      <para>
To support truly rich interfaces, it is often necessary to specify additional attributes
of the HTML tags; usually this means setting the <varname>class</varname> of a tag so as to
get visual properties from a stylesheet.  In other cases, display attributes may be specified inline
(this is often the case with attributes related to display width and height, since
CSS support for these properties are inconsistent between the major HTML 4.0 browsers).
</para>
      <para>
In theory, these components <emphasis>could</emphasis> define additional formal parameters for
each possible HTML attribute ... but there are a huge number of possible attributes, many of
which are specific to a particular browser.
</para>
      <para>
Instead, Tapestry has the concept of an <emphasis>informal parameter</emphasis>.  
This is an "additional" parameter, not specified
in the component's specification.  In most cases, where informal parameters are allowed, they
are added as additional HTML attributes (there are a few special exceptions, such as the &Script; component).
</para>
      <para>
Informal parameters do have some limitations.  Informal parameters that conflict with the names of
any formal parameters, or with any the HTML attributes generated directly by the component, are silently
ommitted.  The comparison is case-insensitve.  Thus, for a &Direct; component, you can not change
the <varname>href</varname> attribute, even if you supply a <varname>Href</varname> (or other variation) informal parameter.
</para>
      <para>
Not all Tapestry components even allow informal parameters; this is explicitly 
stated in the <link linkend="components.specification">component specification</link>.
</para>
      <note>
        <title>Informal Parameters that are Assets</title>
        <para>
Tapestry includes a special case when an informal parameter is actually an 
<link linkend="components.assets">asset</link>.  The URL for the asset is determined and that is the value
supplied for the attribute.
</para>
      </note>
    </section>
    <section id="components.embedded">
      <title>Embedded Components</title>
      <para>
Under Tapestry, it is common to define new components 
by combining existing components.  The existing components are 
embedded in the containing component.  This is always true at the top level; Pages, 
which are still Tapestry components, always embed other Tapestry components.
</para>
      <para>
Each embedded component has an <varname>id</varname> (an identifying string) 
that must be unique within the containing component.  
Every non-page component is embedded inside some other 
component forming a hierarchy that can get quite deep 
(in real Tapestry applications, some pages have components nested three to five levels deep).
</para>
      <para>
In some cases, a component will be referenced by its id path.  
This is a series of component ids separated by periods, representing a path from 
the page to a specific component.  The same notation as a property path 
is used, but the information being represented is quite different.
</para>
      <para>
For example, the id path <literal>border.navbar.homeLink</literal>
represents the component named <varname>homeLink</varname>, 
embedded inside a component named <varname>navbar</varname>, 
embedded inside a component named <varname>border</varname>, embedded inside some page.
</para>
      <para>
Tapestry components are "black boxes".  They have a set of parameters that may 
be bound, but their internals, how they are implemented, are not revealed.
</para>
      <para>
Primitive components may not embed other components, or even 
have a template.  Nearly all the built-in components are primitive; they are 
building blocks for constructing more complex components.
</para>
      <para>
Alternately, a component may be implemented using a template and embedded components.  
In either case, the names, types or very existence of embedded components is private, 
hidden inside the containing component's "black box".
</para>
    </section>
    <section id="components.html-template">
      <title>HTML Templates</title>
      <para>Nearly all Tapestry components combine static HTML
	<footnote>
          <para>
			The initial relase of Tapestry is specifically oriented around HTML.  Some support for
			non-HTML languages, such as XML, XHTML or WML is already present
			and will be expanded in the future.
		</para>
        </footnote>
from a template with additional dynamic content 
(some few components are just dynamic content).  
Often, a Tapestry component embeds other Tapestry components.  
These inner components are referenced in the containing component's template.
</para>
      <para>
Templates look like standard HTML files, though they are rarely complete 
HTML documents; usually they are snippets.  
</para>
      <para>
Identifying a Tapestry component is accomplished by adding a <varname>jwcid</varname> attribute to a tag.
</para>
      <informalexample>
        <programlisting>
&lt;<replaceable>any</replaceable> jwcid="<replaceable>component id</replaceable>" ... &gt;  <replaceable>body</replaceable>  &lt;/<replaceable>any</replaceable>&gt;
</programlisting>
      </informalexample>
      <para>or
</para>
      <informalexample>
        <programlisting>
&lt;<replaceable>any</replaceable> jwcid="<replaceable>component id</replaceable>" ... /&gt;
</programlisting>
      </informalexample>
      <para>
Most often, the HTML element chosen is <sgmltag class="starttag">span</sgmltag>, though (in fact) Tapestry
completely ignores the element, except to make sure the open and close tags balance.
</para>
      <para>
The parser used by Tapestry is relatively forgiving about case 
and white space.  Also, the component id (and any other attributes) can be enclosed in 
double quotes (as above), single quotes, or be left unquoted.
</para>
      <para>
When using the <varname>jwcid</varname> attribute, you are free to specify additional
attributes.  These attributes will become
<link linkend="components.informal-parameters">informal parameters</link> for the Tapestry component.
</para>
      <para>
An alternative to using the <varname>jwcid</varname> attribute is to use
the &jwc-tag; element.  The &jwc-tag; element has two forms:
</para>
      <informalexample>
        <programlisting>
&lt;jwc id="<replaceable>component id</replaceable>"&gt;  <replaceable>body</replaceable>  &lt;/jwc&gt;
</programlisting>
      </informalexample>
      <para>or
</para>
      <informalexample>
        <programlisting>
&lt;jwc id="<replaceable>component id</replaceable>"/&gt;
</programlisting>
      </informalexample>
      <note>
        <para>
	Through Tapestry release 1.0.1, only the &jwc-tag; tag was supported 
	in HTML templates.  Support for the <varname>jwcid</varname> attribute
	in arbitrary elements was
	added in release 1.0.2.
	</para>
      </note>
      <para>
When using the &jwc-tag; tag, you may only specify the <varname>id</varname> attribute.  You may
not specify any additional informal parameters, as you can when using the standard
notation.
</para>
      <para>
The ability to convert static HTML tags into dynamic tags is really to streamline the 
<link linkend="components.html-production">integration process</link>,
the process whereby the efforts of HTML designers are 
converted into Tapestry components and templates.
</para>
      <para>
The start and end tags for Tapestry components must balance properly. This includes cases where the
end tag is normally ommitted, such as <sgmltag class="starttag">input</sgmltag> elements.  Either a closing
tag must be supplied, or the XML-style syntax for an empty element must be used (that is, 
a slash just before the end of the tag).
</para>
      <para>
Tapestry divides the contents of the HTML template into two categories:
<itemizedlist mark="bullet">
          <listitem>
            <para>
		Static HTML and HTML comments, which pass through unchanged.
		</para>
          </listitem>
          <listitem>
            <para>
		Tapestry components (tags with the <varname>jwcid</varname> attribute, as well as the &jwc-tag; element).
		The related tags are removed, and the HTML is supplied by the actual
		components.
		</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
The body listed above can be either static HTML or other Tapestry 
components or both.  Elements in the body of a component are 
wrapped by the containing component.  The containing component controls the 
rendering of the elements it wraps in its body.  For example, 
the &Conditional; component may decide not to 
render its body and the &Foreach; component may render 
its body multiple times.
</para>
      <para>
Not all Tapestry components should have a body.  
For example, the &TextField; component creates an
<sgmltag class="starttag">input type=text</sgmltag>
form element and it makes no sense for it to contain anything else.  
Whether a component can have a body (and wrap other elements) is defined in the 
component's specification.
</para>
      <para>
Tapestry includes a special component, &InsertWrapped;, 
which is used to render the body of a component.  
It makes it easy to create components that wrap other components.
</para>
      <para>
In many scripting systems, scripting constructs are one-dimensional.... 
they appear at a certain point on the page and dynamically 
insert some content into a stream of HTML that eventually 
ends up on the client web browser.
</para>
      <para>
Tapestry components are more powerful ... they have open and 
close tags and thus can contain a body.  This body is made up 
of static HTML from the template and other Tapestry components.  The outer component 
wraps the inner elements.
</para>
      <para>
An example of this is the <classname>Border</classname> component in the Tapestry Tutorial
	<footnote>
          <para>
			The Border tutorial has changed slightly since this
			was initially written, but the basic ideas still hold.
		</para>
        </footnote>.  
It shows how a component can wrap the entire content of a page.
</para>
      <figure>
        <title>Border Component</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Border-Screenshot.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
Here, the <varname>border</varname> component provides the application title ("Reusable Component Tutorial",
in the title bar of the window), the page title (upper left corner) and navigation 
controls (left side).  The page provides the content in the light gray box in the center. 
In this example, the page content is simply static HTML but in a real application the 
content would include other components.
</para>
      <para>
The Home page component has the following HTML template:
</para>
      <figure>
        <title>Home Page HTML Template</title>
        <programlisting>
<sgmltag class="starttag">jwc id="border"</sgmltag><![CDATA[

Nothing much doing here on the <b>home</b> page.  Visit one of our other fine 
pages.

]]><sgmltag class="endtag">jwc</sgmltag>
        </programlisting>
      </figure>
      <para>
In other words, the <varname>border</varname>
component gets to produce HTML first.  At some point, the page's content 
(wrapped inside the <varname>border</varname> component) will be produced.  
Afterwards, the <varname>border</varname> component will have an opportunity to produce more HTML.
The <classname>Border</classname> component has a much larger HTML template:
</para>
      <figure>
        <title>Border component HTML template</title>
        <programlisting><![CDATA[
<HTML>
<head>
<title>Reusable Component Tutorial</title>
</head>
<body>
<table border=0 bgcolor=gray cellspacing=0>
  <tr valign=top>
    <td colspan=3 align=left>
      <font size=5 color="White">]]><sgmltag class="starttag">jwc id="insertPageTitle"/</sgmltag>;<![CDATA[</font>
    </td>
  </tr>
  <tr valign=top>
    <td align=right>
      <font color=white>
]]><sgmltag class="starttag">jwc id="e"</sgmltag>;<![CDATA[
        <br>]]><emphasis><![CDATA[<jwc id="link"><jwc id="insertName"></jwc>
</jwc>]]></emphasis><![CDATA[
      </font>
    </td>
    <td valign=top bgcolor=silver>
      ]]><sgmltag class="starttag">jwc id="wrapped"/</sgmltag>;<![CDATA[
    </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td colspan=3>&nbsp;</td>
  </tr>
</table>
</body>
</HTML>
]]></programlisting>
      </figure>
      <para>
The <classname>Border</classname> component contains five components:

	<itemizedlist>
          <listitem>
            <para>
              <varname>insertPageTitle</varname>
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>e</varname>
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>link</varname>
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>insertName</varname>
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>wrapped</varname>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
The <varname>e</varname> component wraps some static HTML and the 
<varname>link</varname> component.  The 
<varname>link</varname> component wraps the <varname>insertName</varname> component.
</para>
      <para>
When it comes time to render, Tapestry parses the HTML template and breaks 
them into blocks of static HTML, component starts 
(the &jwc-tag; tag) and component ends (the <sgmltag class="endtag">jwc</sgmltag> tag).
</para>
      <para>
The framework determines what each component wraps.  
For components with their own templates, such as <classname>Home</classname> and 
<classname>Border</classname>, it figures out what the outer elements are, 
the outermost static HTML and components that aren't wrapped by other components.
</para>
      <para>
This information turns into a data structure:
</para>
      <figure>
        <title>Border Component Construction</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Border-Construction.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The left side shows how the components are embedded.  
The <classname>Home</classname> page contains the <varname>border</varname> component.  
The <varname>border</varname> component contains the other components.
</para>
      <para>
The outermost elements for the <classname>Home</classname> page is 
a list of one item: the  <varname>border</varname> component.  
There's no text before or after the <varname>border</varname> component's &jwc-tag; tag, 
and the remaining text in the template is wrapped by the <varname>border</varname> component.
</para>
      <para>
The <varname>border</varname> component is 
more complicated; it has several outer elements, 
representing static HTML text and components.  
The other components don't have templates, 
so they don't have outer elements, but some do wrap other components.
</para>
      <para>
When it's time to render, the process starts in the <classname>Home</classname> page, since a page
is always the outermost component. 
It iterates through its outer list, which contains a single element: the
<varname>border</varname> component.  The process then recursively renders the 
<varname>border</varname> component.  Its outer list is rendered in order.  
Each component decides where it will render its wrapped elements (if it has any).  
The <varname>e</varname> component is a &Foreach;; 
it will render its wrapped elements any number of times.
</para>
      <para>
Eventually, the process reaches the <varname>wrapped</varname> component, 
which is of type &InsertWrapped;.  
This is a special component; it jumps up one level to its container (the <varname>border</varname> component)
and renders the <varname>border</varname>'s wrapped elements ... the text from the <classname>Home</classname>
page template.
</para>
      <para>
It may seem complicated, but ultimately its very natural from a markup language point of view; 
the &jwc-tag; tags continue to act like HTML elements, wrapping around and 
controlling their contents, just exactly like a 
<sgmltag class="starttag">table</sgmltag>
wraps its <sgmltag class="starttag">tr</sgmltag>'s or a <sgmltag class="starttag">form</sgmltag> wraps its 
<sgmltag class="starttag">input</sgmltag>'s.
</para>
    </section>
    <section id="components.html-production">
      <title>Tapestry and HTML Production</title>
      <para>
Tapestry is design to work in a large-scale environment, that typically features
two seperate teams: a "creative" team that produces HTML and a 
"technical" team that produces Tapestry pages, components and Java code.
</para>
      <para>
The division of skills is such that the creative team has virtually no knowledge of Java and
a minimal understanding of Tapestry, and the technical team has a limited understanding of HTML 
(and tend to be color blind).
</para>
      <para>
The typical workflow is that the technical team implements the application, using very minimal HTML 
... that is, minimal attention to layout, font size, colors, etc.  Just enough to be sure that
the functionality of the application is there.
</para>
      <para>
Meanwhile, the creative team is producing HTML pages of what the finished application will look like.  
These pages are like snapshots of the HTML produced by the running application.
</para>
      <para>
        <emphasis>Integration</emphasis> is the process of merging these two views of the application together.
Primarily, this involves marking up the HTML page with <varname>jwcid</varname> attributes, to indicate
to Tapestry which portions of the page are dynamic.  In this way, the 
page can be used as a Tapestry HTML template.
</para>
      <para>
Tapestry includes a number of features to ease this whole process.
</para>
      <section>
        <title>Implicitly removed bodies</title>
        <para>
In many cases, a component doesn't allow a body, but one may be present in the HTML template.
Tapestry considers that body to be a sample value, that exists to allow the HTML producer
to verify the layout of the page.  Tapestry edits out the body.
</para>
        <para>For example, an HTML producer may create an HTML template that includes a table
cell to display the user's name.  The producer includes a sample value so that the
cell isn't empty (when previewing the HTML layout).
</para>
        <informalexample>
          <programlisting>
&lt;td&gt;&lt;span jwcid="insertName"&gt;John Doe&lt;/span&gt;&lt;/td&gt;
</programlisting>
        </informalexample>
        <para>
The &Insert; component doesn't allow a body, so Tapestry edits out the 
content of the <sgmltag class="starttag">span</sgmltag> tag from the HTML template.  The fact that
a <sgmltag class="starttag">span</sgmltag> was used to represent the &Insert; component in the
HTML template is irrelevant to Tapestry; any tag could have been used, Tapestry just
cares that the start and end tags balance.
</para>
        <para>
At runtime, Tapestry will combine the HTML template and the &Insert; component to produce the
final HTML:
</para>
        <informalexample>
          <programlisting>
&lt;td&gt;Frank N. Furter&lt;/td&gt;
</programlisting>
        </informalexample>
        <para>
This editting out isn't limited to simple text; any HTML inside the body is removed.  However,
none of that content may be dynamic ... the presence of a &jwc-tag; tag or a
<varname>jwcid</varname> attribute will cause a parsing exception.
</para>
      </section>
      <section>
        <title>Explicitly removed bodies</title>
        <para>
Another feature related to production and integration is the ability to remove sections of the HTML template.
Producers often include some optional portions on the page.  The canonical example of this is a page that 
shows a table of results; the HTML producer will usually include extra rows to demonstrate the look and layout of
a fully populated page.
</para>
        <para>
The first row will be wrapped by a &Foreach; and otherwise changed to include dynamic links and output, but what about
the other rows?
</para>
        <para>
To handle this case,
Tapestry recognizes a special <varname>jwcid</varname> attribute value: <literal>$remove$</literal>.  
Using this special id causes
Tapestry to edit out the tag and all of its contents.  Thus, each additional <sgmltag class="starttag">tr</sgmltag> in the
table should specify the value <literal>$remove$</literal> for attribute <varname>jwcid</varname>.
</para>
        <informalexample>
          <programlisting><![CDATA[
<table>
  <span jwcid="foreach">
  <tr>
    <td><span jwcid="insertUserName">John Doe</span></td>
    <td><span jwcid="insertAge">42</span></td>
  </tr>
  </span>
  <tr jwcid="$remove$">
  	<td>Frank N. Furter</td>
  	<td>47</td>
  </tr>
  <tr jwcid="$remove$">
    <td>Bob Doyle</td>
    <td>24</td>
  </tr>
</table>]]></programlisting>
        </informalexample>
      </section>
      <section>
        <title>Limiting template content
	</title>
        <para>
In a typical Tapestry application, some form of Border component provides a significant portion of every page.
This typically includes the outermost <sgmltag class="starttag">html</sgmltag>, <sgmltag class="starttag">head</sgmltag> and <sgmltag class="starttag">body</sgmltag>
tags, as well as <sgmltag class="starttag">table</sgmltag>s used to control layout.
</para>
        <para>
In the static HTML pages from the creative team, this is not directly visible ... they <emphasis>must</emphasis>
include all the content
normally generated by the Border component in order to see what the HTML page actually looks like.
</para>
        <para>
By default, the <emphasis>entire</emphasis> HTML template is the content for the page.  
This causes a problem, even after a <sgmltag class="starttag">span</sgmltag>
is added, to represent the Border component ... much of the HTML is duplicated, 
once from the static HTML, then dynamically from the Border component.
</para>
        <para>
To eliminate this problem, Tapestry has a second special <varname>jwcid</varname> attribute: <literal>$content$</literal>.
Using this special id causes Tapestry to limit its view of the HTML template to just the content inside the tag.  Anything outside
the defined content is completely ignored.
</para>
      </section>
      <section>
        <title>Limits</title>
        <para>
Ideally, the HTML pages created by the HTML producers would be used as is
as the HTML templates.  Changes made for integration, the adding of <varname>jwcid</varname> attributes and such,
would be copied back into the HTML pages.
</para>
        <para>
Given the use of the <literal>$remove$</literal> and <literal>$content$</literal>
          <varname>jwcid</varname>'s, 
this is practical
to a point.  Once the application starts using a number of re-usable components, there
isn't a good way to perform the integration short of cutting and replacing
some of the HTML page content to form the HTML template.
</para>
      </section>
    </section>
    <section id="components.localization">
      <title>Localization</title>
      <para>
Tapestry has built in support for localization, designed to be easy to use.  
Tapestry allows multiple versions of HTML templates and assets (described in a later section) 
to be deployed with the application.
</para>
      <para>Each client connecting to the application will select a particular <classname>Locale</classname>. 
When a page for the application is created, the locale is used to select the correct template.  
Locales are defined by the ISO (International Standards Organization).  
A locale consists of a language code (such as 'en' for English, 'de' for German or 'fr' for French) 
and a country code (such as 'AU' for Australia, 'BE' for Belguim, or  'GB' for United Kingdom).
</para>
      <para>
The base template name is derived from the specification name, 
by changing the '.jwc' extension to '.html.  
For example, component <filename>/com/skunkworx/skunkapp/Banner.jwc</filename>
will have a base template name of  <filename>/com/skunkworx/skunkapp/Banner.html</filename>.
This resource name is used as the basis of a search that includes the locale.  
Various suffixes are inserted just before the '.html' extension.
</para>
      <para>
A French speaking Belgian visitor would provoke the following search:
</para>
      <itemizedlist>
        <listitem>
          <para>
            <filename>/com/skunkworx/skunkapp/Banner_fr_BE.html</filename>
          </para>
        </listitem>
        <listitem>
          <para>
            <filename>/com/skunkworx/skunkapp/Banner_fr.html</filename>
          </para>
        </listitem>
        <listitem>
          <para>
            <filename>/com/skunkworx/skunkapp/Banner.html</filename>
          </para>
        </listitem>
      </itemizedlist>
      <para>
The Tapestry framework automatically provides this basic level of support.  
To this, an application could add custom logic to allow the locale to be selected at 
runtime, and to store a user's locale preference (in a cookie, or in some form of profile)
for later visits.
</para>
    </section>
    <section id="components.assets">
      <title>Assets</title>
      <para>
Assets are images (GIF, JPEG, etc.), movies, sounds or other collateral associated 
with a web application.  Assets come in three flavors:  external, internal and private.
</para>
      <para>
External assets live at an arbitrary URL.  Internal assets use a URL within the 
servlet context hosting the Tapestry application; 
these assets are deployed on the same web server as the application, 
or within the same Web Application Archive (WAR).
</para>
      <para>
Private assets come from the Java class path and are 
resources not normally visible to the web server.
</para>
      <para>
Tapestry uses the assets concept to address two areas:  localization and deployment.
</para>
      <para>
For localization:  internal and private assets are localized, 
just like HTML templates.  That is, the path name provided is 
used as the basis for a search that takes into account the desired locale.  
External assets can't be localized in this way.
</para>
      <para>
Private assets allow for easy deployment because the assets are 
packaged with the HTML templates and Java code of the application, 
inside a Java Archive (JAR) file, or within the <filename class="directory">WEB-INF/classes</filename>
directory of a Web Application Archive (WAR) file.
</para>
      <para>
Private assets support re-usability; a re-usable component may be 
packaged with supporting assets (typically, image files) and used in any 
Tapestry application without change, and without having to locate, extract or 
otherwise fiddle with those assets.
</para>
      <para>
The Tapestry framework provides two ways of exposing the assets to the client web browser.
</para>
      <para>
First, it provides a service that will access the asset dynamically.  
The URL encodes the application servlet and the resource to download, 
and Tapestry framework code will pump the bytes down to the client web browser.  
This is the default behavior (and is most useful during development).
</para>
      <para>
The second method involves copying the asset out to a directory visible 
to the web server, and creating a URL for it in its final location.  
This requires some extra configuration of the application.  
This method also has some implications when deploying new versions of the web application.  
These are addressed later in this document.
</para>
    </section>
    <section id="components.helper-beans">
      <title>Helper Beans</title>
      <para>
There is a second form of aggregation allowed with Tapestry components.  The first way, covered previously, is to use embedded
components to extend the functionality of the outer component.  In some cases, useful behavior can be isolated, 
not into an additional component, but into a simple JavaBean.
</para>
      <para>
These additional beans, called helper beans, are defined in the component specification, in the
<link linkend="components.spec.bean">
          <sgmltag class="starttag">bean</sgmltag> element</link>.
Each bean has a unique name, a class to instantiate,
and a lifecycle (which controls how long the component keeps a reference to the bean).  The specification 
allows properties of the bean to be set as well, using
the <link linkend="components.spec.set-property">
          <sgmltag class="starttag">set-property</sgmltag> element</link>.  
Helper beans are accessed through the <varname>beans</varname> property of the component.
</para>
      <para>
Beans are created as needed, they may then be cached for future use according to their declared lifecycle.
The default lifecycle is <varname>request</varname>, meaning that the same bean will be returned until the end of the current request cycle.
</para>
      <para>
An alternate lifecycle, <varname>page</varname>, means that once the bean is instantiated, it will continue to be available
for the lifetime of the page containing it.  Remember that helper beans should never contain any client-specific
state, since a page will be used by multiple sessions and clients.
</para>
      <para>
The last available lifecycle, <varname>none</varname>, indicates that the bean is not cached at all, and will be created fresh on
each property access.
</para>
      <para>
In all things, Tapestry attempts to pool and cache objects, to minimize the number of objects created or garbage collected
during a request.  Helper beans are no exception.  There exists a general helper bean pool.  Helper beans with the
<varname>request</varname> lifecycle may be placed into the pool for subsequent reuse (in the same or different page).  This
only occurs with helper beans that implement the &IPoolable; interface.
</para>
      <para>
Tapestry includes a handful of useful helper beans.  &Default; is used to provide default values for optional parameters.
&ValidationDelegate; 
and several implementions of &IValidator;
used with &ValidField;, it allows simple handling of validation and presentating validation errors.
&EvenOdd; is used by the <link linkend="inspector">Tapestry Inspector</link>; it generates a stream of values alternating between "even" and "odd"; this is combined with cascading stylesheets to make the rows alternate between white and grey backgrounds.
</para>
    </section>
    <section id="components.specification">
      <title>Component Specification</title>
      <para>
The component specification is an XML document.  
This discussion assumes a passing familiarity with XML documents.   
The specification is located inside the running Java VMs class path; 
in a deployed application, it will be a package resource, 
located (along with the Java class files) in the 
<filename class="directory">WEB-INF/classes</filename> 
directory of the WAR (Web Application Archive).
</para>
      <para>
These specifications can be somewhat verbose, 
it is strongly advised that a DTD-aware XML editor be used, 
rather than hand editting the files.
</para>
      <section>
        <title>
          <sgmltag class="starttag">specification</sgmltag> element</title>
        <para>
Component specification files, which use the filename extension <literal>.jwc</literal>, consist of a
<sgmltag class="starttag">specification</sgmltag> element.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">specification</sgmltag> element</title>
          <programlisting><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE specification PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN"
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">
]]>

&lt;specification 
  allow-body="<replaceable>yes</replaceable>|<replaceable>no</replaceable>" <co id="components.spec.co.allow-body"/>
  allow-informal-parameters="<replaceable>yes</replaceable>|<replaceable>no</replaceable>" <co id="components.spec.co.informal"/>
  class="<replaceable>java-class</replaceable>"&gt; <co id="components.spec.co.java-class"/>
  
  [ &lt;<link linkend="components.spec.description">description</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.parameter">parameter</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.reserved-parameter">reserved-parameter</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.property">property</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.bean">bean</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.component">component</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.assets"><replaceable>asset</replaceable></link> ...&gt; ...]
&lt;/specification&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="components.spec.co.allow-body">
              <para>
  	Whether the component is allowed to have a body, that is, wrap around other components
  	and static HTML.  The default is 'yes', so this attribute is usually ommitted.
  	</para>
            </callout>
            <callout arearefs="components.spec.co.informal">
              <para>
  	Whether informal parameters are allowed.  Informal parameters are additional parameters
  	beyond the ones formally defined.  These are typically used with components that map
  	directly to an HTML element, to allow additional HTML attributes to be specified.
  	The default is 'yes', so this attribute is usually ommitted.
  	</para>
            </callout>
            <callout arearefs="components.spec.co.java-class">
              <para>
	The complete class name of the component class, 
	for example, <classname>com.skunkworx.skunkapp.Border</classname>.
	</para>
            </callout>
          </calloutlist>
        </para>
        <note>
          <title>Versions of the DTD</title>
          <para>
	There was an earlier version of the DTD, version 1.0, which is the version
	used with Tapestry Release 1.0.0.  Version 1.1 is more succinct and readable
	than version 1.0 and has a few extra features.  Both versions are supported by
	Tapestry until at least release 1.1.0.
	</para>
        </note>
        <para>
As previously described, the specification name is used to find the base 
HTML template name (by replacing the '.jwc' extension with '.html').  
</para>
        <para>
During development, such resources may be in the developer's work areas, 
but when the application is deployed, they will almost always be distributed inside a 
Java Archive (JAR) file or Web Application Archive (WAR) file.  
This is one of the ways that Tapestry eases deployment.
</para>
        <para>
The <sgmltag class="starttag">specification</sgmltag> element wraps around all other elements in
the specification (which are used to define parameters, embedded components and assets).  The following
sections describe these additional elements.
</para>
      </section>
      <section id="components.spec.description">
        <title>
          <sgmltag class="starttag">description</sgmltag> element</title>
        <para>
One or more <sgmltag class="starttag">description</sgmltag> 
elements may be included in the specification.  These are descriptions of 
the component's features and behavior, suitable for inclusion in some form of IDE
<footnote>
            <para>If someone writes such an IDE, please let me know!</para>
          </footnote>.  Multiple descriptions are used to support
multiple languages.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">description</sgmltag> element</title>
          <programlisting>
&lt;description 
  xml:lang="<replaceable>language code</replaceable>"&gt; <co id="component.specification.description.lang"/>
  ... <replaceable>text</replaceable> ... 
&lt;/description&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="component.specification.description.lang">
              <para>
	The language in which the descriptive text is written. This takes the form
	of a two letter code, defined by the ISO-639 standard.
	</para>
            </callout>
          </calloutlist>
        </para>
        <note>
          <title>
            <sgmltag class="starttag">description</sgmltag> usage</title>
          <para>
	The <sgmltag class="starttag">description</sgmltag> element is really used for future expansion, towards
	a time when an  integrated HTML / Tapestry Specification editor does exist.  
	Also, a Javadoc doclet may be created that can read
	Tapestry specifications and include them with Javadoc.  In the meantime, descriptions can be used
	like XML comments.
	</para>
        </note>
      </section>
      <section id="components.spec.parameter">
        <title>
          <sgmltag class="starttag">parameter</sgmltag> element</title>
        <para>
This element is used to describe formal parameters used by a component.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">parameter</sgmltag> element</title>
          <programlisting>
&lt;parameter
  name="<replaceable>name</replaceable>" <co id="components.spec.parameter.name"/>
  java-class="<replaceable>text</replaceable>" <co id="components.spec.parameter.java-class"/>
  required="<replaceable>yes</replaceable>|<replaceable>no</replaceable>"&gt; <co id="components.spec.parameter.required"/>
  [ &lt;<link linkend="components.spec.description">description</link> ... &gt; ...] <co id="components.spec.parameter.description"/>
&lt;/parameter&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="components.spec.parameter.name">
              <para>
		Each parameter must have a unique name.  
		Parameter names must start with a letter and may contain letters, numbers 
		and the underscore.
		</para>
            </callout>
            <callout arearefs="components.spec.parameter.java-class">
              <para>
		Identifies the Java class or type that must be provided for the parameter.
		This is for descriptive purposes only, there is no validation by the framework.
		Additionally, most components will do their best to cooerce whatever value
		is given them into a useful type, such as parsing a String into an int.
		</para>
              <para>
		The <varname>java-type</varname> attribute is optional.
		</para>
            </callout>
            <callout arearefs="components.spec.parameter.required">
              <para>
		If 'yes', then the parameter must be bound when the page is loaded.  The default, 'no',
		allows a parameter to not be bound.
		</para>
              <para>
		Individual components may do a second check, that the bound parameter provides a non-null value.
		</para>
            </callout>
            <callout arearefs="components.spec.parameter.description">
              <para>
		Each parameter is allowed to have its own set of localized descriptions.
		</para>
            </callout>
          </calloutlist>
        </para>
      </section>
      <section id="components.spec.reserved-parameter">
        <title>
          <sgmltag class="starttag">reserved-parameter</sgmltag> element</title>
        <para>
			The <sgmltag class="starttag">reserved-parameter</sgmltag> element is used
			to identify parameter names that may not be
			used as <link linkend="components.informal-parameters">informal parameters</link>.  Informal parameters
			may not match the name of any formal parameter, or any reserved parameter names
			(comparisons ignore case).
			</para>
        <para>
			The point of this is to allow components to declare HTML attributes generated by the
			component to be "off limits" to informal parameters.  For example, the &TextField; component
			declares that the <varname>input</varname> and <varname>name</varname> parameters
			are reserved, since those are generated by the component and should not be overriden
			in any way.
			</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">reserved-parameter</sgmltag> element</title>
          <programlisting>
&lt;reserved-parameter name="<replaceable>name</replaceable>"/&gt;
			</programlisting>
        </figure>
      </section>
      <section id="components.spec.property">
        <title>
          <sgmltag class="starttag">property</sgmltag> element</title>
        <para>
Allows arbitrary name / value pairs to be associated with the container
(a component or application).
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">property</sgmltag> element</title>
          <programlisting>
&lt;property name="<replaceable>name</replaceable>"&gt;
  [ <replaceable>value</replaceable> ]
&lt;/property&gt;
</programlisting>
        </figure>
      </section>
      <section id="components.spec.bean">
        <title>
          <sgmltag class="starttag">bean</sgmltag> element</title>
        <para>
The <sgmltag class="starttag">bean</sgmltag> element
is used to identify <link linkend="components.helper-beans">helper beans</link>
for the component.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">bean</sgmltag> element</title>
          <programlisting>
&lt;bean name="<replaceable>name</replaceable>"
  class="<replaceable>class</replaceable>"
  lifecycle="<replaceable>none</replaceable>|<replaceable>request</replaceable>|<replaceable>page</replaceable>"&gt;

  [ &lt;<link linkend="components.spec.description">description</link> ... &gt; ... ]
  [ &lt;<link linkend="components.spec.set-property">set-property</link> ... &gt; ... ]

&lt;/bean&gt;
</programlisting>
        </figure>
        <para>
The name is the name of the bean, which must be unique for beans within the component.  The bean will be accessible
using the property path <varname>beans.<replaceable>name</replaceable>
          </varname>.  Beans are instantiated
as needed, the may be cached for later use.  The <replaceable>class</replaceable> is the complete Java class name
to instanatiate.
</para>
        <para>
The default lifecycle is <varname>request</varname>, if not specified.
</para>
        <para>
Any number of
<link linkend="components.spec.set-property">
            <sgmltag class="starttag">set-property</sgmltag>
          </link>
elements may be specified, to intialize the properties of the bean.
</para>
      </section>
      <section id="components.spec.set-property">
        <title>
          <sgmltag class="starttag">set-property</sgmltag> element</title>
        <para>
This element is used to set a property of a helper bean, and
appears only inside the <link linkend="components.spec.bean">
            <sgmltag class="starttag">bean</sgmltag> element</link>.  Properties are
set just after the bean is instantiated.  For poolable beans, properties
are set just after the bean is retrieved from the pool.
</para>
        <para>
Values for properties are specified using the <sgmltag class="starttag">static-value</sgmltag>
and <sgmltag class="starttag">property-value</sgmltag> element.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">set-property</sgmltag> element</title>
          <programlisting>
&lt;set-property name="<replaceable>name</replaceable>"&gt;
  [ &lt;<link linkend="components.spec.field-value">field-value</link> ... &gt; | &lt;<link linkend="components.spec.static-value">static-value</link> ... &gt; | &lt;<link linkend="components.spec.property-value">property-value</link> ... &gt; ]
&lt;/set-property&gt;
</programlisting>
        </figure>
        <para>
The name attribute identifies the property to be changed.  The value is provided
by a
<link linkend="components.spec.static-value">
            <sgmltag class="starttag">static-value</sgmltag>
          </link>
or
<link linkend="components.spec.property-value">
            <sgmltag class="starttag">property-value</sgmltag>
          </link>
element.
</para>
      </section>
      <section id="components.spec.field-value">
        <title>
          <sgmltag class="starttag">field-value</sgmltag> element</title>
        <para>
 This element, which appears only within a
<link linkend="components.spec.set-property">
            <sgmltag class="starttag">set-property</sgmltag> element</link>
provides a static value with which to set the property obtained from a public static
variable of some class.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">field-value</sgmltag> element</title>
          <programlisting>
&lt;field-value field-name="<replaceable>field-name</replaceable>"/&gt;
</programlisting>
        </figure>
        <para>
The field name specifies the complete class name (including package name) and the name of a field within the class.  
As a convienience, the package name may be ommitted if the class is in the
<property>java.lang</property>
package.

       </para>
      </section>
      <section id="components.spec.static-value">
        <title>
          <sgmltag class="starttag">static-value</sgmltag> element</title>
        <para>
This element, which appears only within a
<link linkend="components.spec.set-property">
            <sgmltag class="starttag">set-property</sgmltag> element</link>
provides a static value with which to set the property.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">static-value</sgmltag> element</title>
          <programlisting>
&lt;static-value type="<replaceable>boolean</replaceable>|<replaceable>int</replaceable>|<replaceable>double</replaceable>|<replaceable>String</replaceable>"&gt;
  [ <replaceable>value</replaceable> ]
&lt;/static-value&gt;
</programlisting>
        </figure>
        <para>
The value is the simple text content inside the element.  It is converted from a string representation
to one of the available types (more types will be added in the future).  The default
is <varname>String</varname>, in which case the value is used as is, after leading and trailing
whitespace is removed.
</para>
      </section>
      <section id="components.spec.property-value">
        <title>
          <sgmltag class="starttag">property-value</sgmltag> element</title>
        <para>
This element appears inside a
<link linkend="components.spec.set-property">
            <sgmltag class="starttag">set-property</sgmltag>
          </link> element
to set a property of the bean from a dynamic property of the containing 
component.  The component property, which may be a property path, is evaulated
when the bean is instantiated.
</para>
        <figure>
          <title>Component specifciation: <sgmltag class="starttag">property-value</sgmltag> element</title>
          <programlisting>
&lt;property-value property-path="<replaceable>property path</replaceable>"/&gt;
</programlisting>
        </figure>
      </section>
      <section id="components.spec.component">
        <title>
          <sgmltag class="starttag">component</sgmltag> element</title>
        <para>
The <sgmltag class="starttag">component</sgmltag> element is used to describe an embedded component, a
component identified in the containing component's HTML template.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">component</sgmltag> element</title>
          <programlisting>
&lt;component
  id="<replaceable>id</replaceable>" <co id="component.spec.component.id"/>
  type="<replaceable>type</replaceable>" <co id="component.spec.component.type"/>
  copy-of="<replaceable>id</replaceable>"&gt; <co id="component.spec.component.copy-of"/>
  [ &lt;binding|field-binding|inherited-binding|static-binding ...&gt; ... ]
&lt;/component&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="component.spec.component.id">
              <para>
  	Each component must have a unique identifier within its container.  The <varname>id</varname>
  	attribute must conform to an XML id:  start with a letter, and contain only letters, numbers
  	and underscores.
  	</para>
            </callout>
            <callout arearefs="component.spec.component.type">
              <para>
  	The component type is either the the complete path to a component specification, or a well known alias.
  	All the components provided with the framework have well known aliases, at it is possible
  	to create additional aliases in the Tapestry application specification.
  	</para>
            </callout>
            <callout arearefs="component.spec.component.copy-of">
              <para>
	Instead of specifying a type, a component may be a copy of one of its siblings.  In this case,
	the new component is created by copying the type and bindings of the existing component.  It is possible
	to specify additional bindings as well.
	</para>
              <para>
	The component being copied from must be declared first.
	</para>
            </callout>
          </calloutlist>
        </para>
        <para>
  	You must specify either the <varname>type</varname> or <varname>copy-of</varname> attributes, but not both.
  	</para>
        <para>
Each component must also have a type.  Types are resource paths for a component 
specification.  Specifications end with '.jwc'.  An example would be 
<filename>/com/skunkworx/skunkapp/Banner.jwc</filename>.
</para>
        <para>
Unlike HTML templates, specifications are never localized.
</para>
        <para>
As a convenience, aliases may be defined for components.  
An alias is a short name that takes the place of the specification resource path.  
All built-in components for Tapestry have aliases, and an 
application specification may define additional aliases.
</para>
        <para>
For example, the component 
<filename>/com/primix/tapestry/links/Action.jwc</filename>
has a standard alias of &Action;.
</para>
      </section>
      <section id="components.spec.bindings">
        <title>Binding elements</title>
        <para>
There are four different types of bindings.  The standard binding is most common, as it binds a parameter
to a property of an object, and may be read, write or read/write.
</para>
        <figure>
          <title>Component specification: binding elements</title>
          <programlisting>
&lt;binding
  name="<replaceable>name</replaceable>" <co id="components.spec.binding.name"/>
  property-path="<replaceable>property-path</replaceable>"/&gt; <co id="components.spec.binding.path"/>
  
&lt;field-binding
  name="<replaceable>name</replaceable>"
  field-name="<replaceable>field-name</replaceable>"/&gt; <co id="components.spec.binding.field-name"/>
  
&lt;inherited-binding
  name="<replaceable>name</replaceable>"
  parameter-name="<replaceable>parameter-name</replaceable>"/&gt; <co id="components.spec.binding.parameter-name"/>
  
&lt;static-binding
  name="<replaceable>name</replaceable>"&gt;
  	... <replaceable>value</replaceable> ... <co id="components.spec.binding.static-value"/>
&lt;/static-binding&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="components.spec.binding.name">
              <para>
		A name of the parameter to bind.  This usually matches the name of
		a formal parameter of the component.  For components which
		allow informal parameters, this may be any value.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.path">
              <para>
		The name of a property reachable from the containing component.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.field-name">
              <para>
		The name of a public static field.  This takes the form
		<replaceable>class name</replaceable>.<replaceable>field name</replaceable>.  The class name is the complete
		class name (including the package names), unless the package is <varname>java.lang</varname>, in which
		case the package portion can be ommitted.
		</para>
              <para>
		Field bindings are often more useful than static bindings, because the value does't have to
		be a convertable from a string.  This means true objects, not just holders of single values,
		can be used, this is quite useful when dealing with the form element components.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.parameter-name">
              <para>
		The name of a formal or informal parameter of the containing component.  The contained component
		will share the same binding.  This is one of the ways in which it is possible to build complex
		components by combining simple ones.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.static-value">
              <para>
		Unlike the other binding types, the <sgmltag class="starttag">static-binding</sgmltag> element
		wraps around its static value, which allows for maximum flexibility.  It does, however,
		remove all leading and trailing whitespace from the value.
		</para>
            </callout>
          </calloutlist>
        </para>
        <para>
An example of using an
<sgmltag class="starttag">inherited-binding</sgmltag> is the <classname>Border</classname> component, 
which has a <varname>title</varname> parameter that gives the name of the page.  
The <classname>Border</classname> component embeds an &Insert; component, 
and uses an inherited binding to set the 
&Insert; component's <varname>value</varname> parameter to the 
containing <classname>Border</classname> component's <varname>title</varname> parameter.
</para>
      </section>
      <section id="components.spec.assets">
        <title>Asset elements</title>
        <para>
Assets are a way of identifying resources whose URLs will appear in a web page.  
Most often, the assets are image files used with an &Image; or 
&Rollover; components.
</para>
        <figure>
          <title>Component specification: Asset elements</title>
          <programlisting>
&lt;context-asset
	name="<replaceable>name</replaceable>"
	path="<replaceable>path</replaceable>"/&gt;
	
&lt;external-asset
	name="<replaceable>name</replaceable>"
	URL="<replaceable>URL</replaceable>"/&gt;
	
&lt;private-asset
	name="<replaceable>name</replaceable>"
	resource-path="<replaceable>resource-path</replaceable>"/&gt;
</programlisting>
        </figure>
        <para>
Assets may be stored at some arbitrary URL, may be within the same web application context as the 
Tapestry application, or may be stored as a resource inside Java VM class path.
</para>
        <para>
In all three cases, the name must be very simple:  
start with a letter and contain only letters, numbers and underscores or dashes.  
Assets names must be unique within the component.
</para>
        <para>
For external assets, the URL must be complete:  it will be inserted into the HTML unchanged.  In many cases,
the URL can omit the <literal>http://<replaceable>hostname</replaceable>
          </literal> portion of the URL, if the asset is located
on the same host as the web application.
</para>
        <para>
For context assets
the path must be relative to the servlet context.  
Context assets may be localized; this will be reflected in the 
actual file chosen and in the URL inserted into the HTML.  
The final URL inserted into the HTML will include the servlet context prefix and may reflect 
a localized path.
</para>
        <para>
For private assets, the resource path must be a resource path within the 
Java VM class path, as with a specification or HTML template resource path.  
This means the asset can be stored in the 
<filename class="directory">WEB-INF/classes</filename> directory of the application's WAR, 
or inside some JAR in the classpath.  Like context assets, private assets may be localized.
</para>
      </section>
    </section>
  </chapter>
  <chapter id="pages">
    <title>Tapestry Pages</title>
    <para>
Pages are specialized versions of components.  As components, they have a specification, 
embedded components, assets and an HTML template.
</para>
    <para>
Pages do not have parameters, because they are the outermost component in the component 
hierarchy.
</para>
    <para>
All components, however deep their nesting, have a page property that points back to the page 
they are ultimately embedded within.   Pages have an engine property that points to the engine 
they are currently attached to.
</para>
    <para>
Pages participate in a pooling mechanism, so that a single instance of a page component can be 
used by multiple sessions of the same web application.  Even when a large number of client 
sessions are active, it is rare for more than a handful to be actively processing requests in the 
application server.  This pooling mechanism minimizes the number of instances of a page that 
must exist concurrently on the server.  There are some implications to this design that are 
discussed in the following sections.
</para>
    <para>
Pages may have persistent state, properties specific to a particular user
that persist between request cycles.  These properties live only as long as the
&HttpSession;.  There is some complexity here, because the page state is
entirely <emphasis>seperate</emphasis> from any instance of the page.  Remember that
on subsequent requests, a different page from the page pool may be used
to service the request ... in fact, in a clustering environment, the request
may be serviced by an entirely different server.  Tapestry
efficiently and transparently hides these details; when any portion of an application
requests a page, it receives an instance of the page with all persistent page properties
set the the values previously stored for the user.
</para>
    <para>
In fact, any 
component may have persistent state, and use the page as means for recording that state.
</para>
    <para>
The engine is a session persistent object.  The implementation of this varies from application 
server to application server, but the basic idea is that the
&HttpSession; is serialized after each 
request and stored in a file or database.  It may then be removed from memory.  When a 
subsequent request for the same session arrives, it is restored from the persistent storage.
</para>
    <para>
In a clustering server application, consequtive requests for the same session may be serviced by 
different servers within the cluster.  Serializing and deserializing the
&HttpSession; is the mechanism 
by which the servers are kept synchronized.  Persistent page properties are stored as part
of the engine, and so they continue to be available, even after the engine has moved
from one server to another.
</para>
    <para>
The visit object is a property of the engine object, so it is serialized and de-serialized with the 
engine.
</para>
    <para>
Pages are <emphasis>not</emphasis> session persistent.  They exist only within the memory of the Java VM in which they 
are first created.  Pages and components don't need to implement the 
<classname>java.io.Serializable</classname>
interface; they will never be serialized.
</para>
    <para>
The application engine can always instantiate a new page instance and restore its previously 
recorded state (the recorded state information is serialized with the engine).
</para>
    <section id="pages.state">
      <title>Page State</title>
      <para>
Pages, and the components on them, have state.  State is considered the set of values for the 
properties of the page.
</para>
      <para>
In Tapestry, the lifespan of each property is very important.  There are three lifespans:
</para>
      <itemizedlist>
        <listitem>
          <para>
			Persistent.  Changes the property are recorded and persist between request cycles.  
			Persistent properties are restored when the page is next loaded.  Persistent
			properties are specific to an individual user.
		</para>
        </listitem>
        <listitem>
          <para>
			Transient.  The property is set before the page is rendered and will be reset 
			(to its default value) at the end of the current request cycle.
		</para>
        </listitem>
        <listitem>
          <para>
			Dynamic.  The property changes even while the page is rendered, but 
			(like transient) the property is 
			reset at the end of the current request cycle.
		</para>
        </listitem>
      </itemizedlist>
      <para>
Persistent properties are things like the user's name, the product being displayed in an 
e-commerce application, etc.  Transient properties are more commonly things needed just once, 
such as an error message.  Dynamic properties are intimately tied to the rendering process ... for 
example, to display a list of items in an order, it may be necessary to have a dynamic property take 
the value of each line item in sequence, as part of a loop.
</para>
    </section>
    <section id="pages.persistent-state">
      <title>Persistent Page State</title>
      <para>
The Tapestry framework is responsible for tracking changes to page state during the request cycle, 
and storing that state between request cycles.   Ultimately, this is the responsiblility of the 
application engine.  This is accomplished through page recorder objects.  As a page's persistent 
state changes, it notifies its page recorder, providing the name of the property and the new value.  
</para>
      <para>
This information is stored persistently between request cycles.  In a later request cycle, the page 
recorder combines this information with a page instance to rollback the state of the page.
</para>
      <para>
Pages are blind as to how their state is stored.  The basic implementation of Tapestry simply 
stores the page state information in memory (and serializes it with the engine, in the 
&HttpSession;), 
but future options may include storing the data in flat files, relational databases or even as cookies 
in the client browser.
</para>
      <para>
Some minor burden is placed on the developer to support persistent state.
The mutator method of every persistent property must include a line of code that notifies the 
observer of the change.
</para>
      <para>
For example, consider a page that has a persistent property for storing an email address.  It would 
implement the normal accessor and mutator methods:
</para>
      <informalexample>
        <programlisting>
private String emailAddress;

public String getEmailAddress()
{
  return emailAddress;
}

public void setEmailAddress(String value)
{
  emailAddress = value;

  <emphasis>fireObservedChange("emailAddress", value);</emphasis>
}</programlisting>
      </informalexample>
      <para>
The mutator method does slightly more than change the private instance variable; it must also 
notify the observer of the change, by   invoking the method 
<function>fireObservedChange()</function>, 
which is 
implemented by the class 
<classname>com.primix.tapestry.AbstractComponent</classname>.  This method is 
overloaded; implementations are provided for every type of scalar value, and for 
<classname>java.lang.Object</classname>.
</para>
      <para>
The value itself must be serializable (scalar values are converted to wrapper classes, which are 
serializable).
</para>
      <para>
The page designer must provide some additional code to manage the lifecycle of the page and its 
persistent properties.  This is necessary to support the "shell game" that allows a page instance to 
be separate from its persistent state, and is best explained by example.  Let's pretend that the user 
can select a personal preference for the color scheme of a page.  The default color is blue.
</para>
      <para>
The first user, Suzanne, reaches the page first.  Disliking the blue color scheme, she uses a form 
on the page to select a green color scheme.  The instance variable of the page is changed to green, 
and the page recorder inside Suzanne's session records that the persistent value for the color 
property is green.
</para>
      <para>
When Suzanne revisits the page, an arbitrary instance of the page is taken from the pool. The page 
recorder changes the color of the page to green and Suzanne sees a green page.
</para>
      <para>
However, if Nancy visits the same page for the first time, what is the color?  Her page recorder 
will not note any particular selection for the page color property.  She'll get whatever was left in 
the page's instance variable ... green if she gets the instance last used to display the page for 
Suzanne, or some other color if some other user recently hit the same page.
</para>
      <para>
This may seem relatively minor when the persistent page state is just the background color.  
However, in a real application the persistent page state information may include user login 
information, credit card data, the contents of a shopping cart  or whatever.
The way to deal with this properly is for each page with persistent state to override the method 
<function>detach()</function>.  The implementation should reset any instance variables on the page to their initial 
(freshly allocated) values.
</para>
      <para>
In our example, when Suzanne is done with the page, its <function>detach()</function> method will reset the page 
color property back to blue before releasing it into the pool.  When Nancy hits the page for the 
first time, the page retrieved from the pool with have the expected blue property.
</para>
      <para>
In our earlier email address example, the following additional code must be implemented by the 
page:
</para>
      <informalexample>
        <programlisting>
public void detach()
{
  emailAddress = null;

  super.detach();
}</programlisting>
      </informalexample>
      <para> 
All properties, dynamic, transient and persistent, should be reset inside the 
<function>detach()</function> method.
</para>
      <para>
Individual components on a page may also have dynamic, transient or persistent properties.  If so, 
they should implement the &PageDetachListener; interface and implement the 
<function>pageDetached()</function> method and clear 
out such properties, just as a page does in 
<function>detach()</function>.
</para>
    </section>
    <section id="pages.ejb-props">
      <title>EJB Page Properties</title>
      <para>
Tapestry make a single, special case for one particular type of persistent page property:  references 
to Enterprise JavaBeans.
</para>
      <para>
The page recorders check to see if a page property is type 
<classname>javax.ejb.EJBObject</classname>.  If so, they don't 
store the object itself (<classname>EJBObjects</classname> are not directly serializable), 
instead they get the <classname>Handle</classname> for the object 
and store that instead (<classname>Handle</classname>s are serializable).
</para>
      <para>
When the page is next accessed, the <classname>Handle</classname> is converted back into an 
<classname>EJBObject</classname> before assigning 
it to the page property.
</para>
      <para>
A side effect of this is that you may not have a <classname>Handle</classname> as a 
persistant page property; the page 
recorders don't have a way to differentiate a <classname>Handle</classname> from an 
<classname>EJBObject</classname> converted to a <classname>Handle</classname>
and always assume the latter.
</para>
    </section>
    <section id="pages.dynamic-state">
      <title>Dynamic Page State</title>
      <para>
The properties of a page and components on the page can change during the rendering process.   
These are changes to the page's dynamic state.
</para>
      <para>
The majority of components in an application use their bindings to pull data from the page (or 
from business objects reachable from the page).
</para>
      <para>
A small number of components, notably the &Foreach; component, work the other way; pushing 
data back to the page (or some other component).
</para>
      <para>
The &Foreach; component is used to loop over 
a set of items.  It has one parameter from which it 
reads the list of items.  A second parameter is used to write each item back to a property of its 
container.
</para>
      <para>
For example, in our shopping cart example, we may use a &Foreach; to run 
through the list of line 
items in the shopping cart.  Each line item identifies the product, cost and quantity.
</para>
      <example>
        <title>HTML template for Shopping Cart</title>
        <programlisting><![CDATA[
<h1>Context of shopping cart for
<span jwcid="insertUserName">John Doe</span></h1>
<table>
  <tr>
    <th>Product</th> <th>Qty</th> <th>Price</th>
  </tr>
  <span jwcid="eachItem">
  <tr>
    <td><span jwcid="insertProductName">Product Name</span></td>
    <td><span jwcid="insertQuantity">5</span></td>
    <td><span jwcid="insertPrice">$1.50</span></td>
    <td><a jwcid="remove">remove</a></td>
  </tr>
  </span>
</table>]]></programlisting>
      </example>
      <para>
This example shows a reasonable template, including sample static values used
when previewing the HTML layout (they are removed by Tapestry at runtime).  Some
areas have been glossed over, such as allowing quantities to be changed.
</para>
      <para>
Component <varname>eachItem</varname> is our &Foreach;.   
It will render its body (all the text and components it wraps) several times, 
depending on the number of line items in the cart.  On each pass it:
</para>
      <itemizedlist>
        <listitem>
          <para>Gets the next value from the source</para>
        </listitem>
        <listitem>
          <para>Updates the value into some property of its container</para>
        </listitem>
        <listitem>
          <para>Renders its body</para>
        </listitem>
      </itemizedlist>
      <para>
This continues until there are no more values in its source.  Lets say this is a page that has a 
<varname>lineItem</varname> property that is being updated by the 
<varname>eachItem</varname> component.  The <varname>insertProductName</varname>, 
<varname>insertQuantity</varname> and <varname>insertPrice</varname> components use dynamic 
bindings such as <literal>lineItem.productName</literal>, 
<literal>lineItem.quantity</literal> and <literal>lineItem.price</literal>.
</para>
      <para>
Part of the page's specification would configure these embedded components.
</para>
      <example>
        <title>Shopping Cart Specification (excerpt)</title>
        <programlisting>
&lt;component id="eachItem" type="Foreach"&gt;
  &lt;binding name="source" property-path="items"/&gt;
  &lt;binding name="value" property-path="lineItem"/&gt;
&lt;/component&gt;

&lt;component id="insertProductName type="Insert"&gt;
  &lt;binding name="value" property-path="lineItem.productName"/&gt;
&lt;/component&gt;

&lt;component id="insertQuantity" type="Insert"&gt;
  &lt;binding name="value" property-path="lineItem.quantity"/&gt;
&lt;/component&gt;

&lt;component id="insertPrice" type="Insert"&gt;
  &lt;binding name="value" property-path="lineItem.price"/&gt;
&lt;/component&gt;

&lt;component id="remove" type="Action"&gt;
  &lt;binding name="listener" property-path="listeners.removeItem"/&gt;
&lt;/component&gt;
</programlisting>
      </example>
      <para>
This is very important to the <varname>remove</varname> component.  On some future request cycle, it will be 
expected to remove a specific line item from the shopping cart, but how will it know which one?
</para>
      <para>
This is at the heart of the <link linkend="cycle.action">action service</link>.  One aspect of the 
&IRequestCycle;'s functionality is to 
dole out a sequence of action ids that are used for this purpose (they are also involved in forms 
and form elements).  As the &Action; component renders itself, 
it allocates the next action id from 
the request cycle.  Regardless of what path through the page's component hierarchy the rendering 
takes, the numbers are doled out in sequence.  This includes conditional blocks and loops such as 
the &Foreach;.
</para>
      <para>
The steps taken to render an HTML response are very deterministic.  If it were possible to 
'rewind the clock' and restore all the involved objects back to the same state (the same values for 
their instance variables) that they were just before the rendering took place, the end result would 
be the same.  The exact same HTML response would be created.
</para>
      <para>
This is similar to the way in which compiling a program for source code results in the same object 
code.  Because the inputs are the same, the results will be identical.
</para>
      <para>
This fact is exploited by the action service to respond to the URL.  In fact, the state of the page 
and components <emphasis>is</emphasis> rolled back and the rendering processes fired again (with output discarded).  
The &Action; component can compare the action id against the target action id encoded 
within the URL.  When a match is found, the &Action; component can count on the state of the 
page and all components on the page to be in the exact same state they were in when the page 
was previously rendered.
</para>
      <para>
A small effort is required of the developer to always ensure that this rewind operation works.  In 
cases where this can't be guaranteed (for instance, if the source of this dynamic data is a stock 
ticker or unpredictable database query) then other options must be used, including the use of
the &ListEdit; component.
</para>
      <para>
In our example, the <varname>remove</varname> component would trigger some application specific code 
implemented in its containing page that removes the current <varname>lineItem</varname> from the shopping cart.
</para>
      <para>
The application is responsible for providing a
<link linkend="cycle.listeners">listener method</link>, a method which is invoked
when the link is triggered.
</para>
      <example>
        <title>Listener method for remove component</title>
        <programlisting>
public void removeItem(IRequestCycle cycle)
{
  getCart().remove(lineItem);
}
</programlisting>
      </example>
      <para>
This method is only invoked after all the page state is rewound; 
especially relevant is the <varname>lineItem</varname> property.  
The listener gets the shopping cart and removes the current line item from it.
This whole rewinding process has ensured that <varname>lineItem</varname> is the correct value, even though the remove 
component was rendered several times on the page (because it was wrapped by the &Foreach;
component).
</para>
      <note>
        <title>Listener Methods vs. Listener Objects</title>
        <para>
	Listener methods were introduced in Tapestry 1.0.2.  Prior to that, it was necessary
	to create a listener object, typically as an inner class, to be notified when
	the link or form was triggered.  This worked against the basic goal of Tapestry: to 
	eliminate or simplify coding.  In reality, the listener objects are still there,
	they are created automatically and use Java reflection to invoke the
	correct listener method.
	</para>
      </note>
      <para>
An equivalent JavaServer Pages application would have needed to define a servlet for removing 
items from the cart, and would have had to encode in the URL some identifier for the item to be 
removed.  The servlet would have to pick apart the URL to find the cart item identifier, locate the 
shopping cart object (probably stored in the &HttpSession;)
and the particular item and invoke 
the <function>remove()</function> method directly.  Finally, it would forward to the JSP that would produce the 
updated page.
</para>
      <para>
The page containing the shopping cart would need to have special knowledge of the cart 
modifying servlet; its servlet prefix and the structure of the URL (that is, how the item to remove 
is identified).  This creates a tight coupling between any page that wants to display the shopping 
cart and the servlet used to modify the shopping cart.  If the shopping cart servlet is modified 
such that the URL it expects changes structure, all pages referencing the servlet will be broken. 
</para>
      <para>
Tapestry eliminates all of these issues, reducing the issue of manipulating the shopping cart down 
to the single, small listener method.  
</para>
    </section>
    <section id="pages.stale-links">
      <title>Stale Links and the Browser Back Button</title>
      <para>
The fact that web browsers have a "back" button is infuriating to application developers.  What 
right does the user have to dictate the order of navigation through the application?  Whose 
application is this anyway?
</para>
      <para>
In a truly stateless application, the browser back button is not a great hardship, because each page 
carrys within itself (as cookies, hidden form fields and encoded URLs) all the state necessary to 
process the page.
</para>
      <para>
Tapestry applications can be more stateful, which is a blessing and a curse.  The blessing is that 
the Tapestry application, running on the server, can maintain state in terms of business objects, 
data from databases, Enterprise JavaBeans and more.  The curse is that a user hitting the back 
button on the browser loses synchronization with that state.
</para>
      <para>
Let's use an e-commerce example.  A user is browsing a list of available cameras from a product 
catalog.  The user clicks on a Minolta camera and is presented with pictures, prices and details 
about the Minolta camera.</para>
      <para>
Part of the page lists similar or related items.  The user clicks on the name of a similar Nikon 
camera and is shown the pictures, prices and details of the Nikon camera.
The user then hits the 
browser back button, returning to the page showing the Minolta camera, and clicks 
the "add to shopping cart" button.  Web browsers have no way of informing the server that the user
has employed the back button.
</para>
      <para>
Once the user clicks the link, the server replies with a response showing
the contents of the shopping cart ... but what has been added to the cart, the Minolta or the 
Nikon?  It depends on how the Tapestry application has been structured.
</para>
      <para>
Presumably, the application has a single page, named <classname>ProductDetails</classname>, that shows the pictures, 
prices and details of any product.  The <classname>ProductDetails</classname> page will 
have a persistent property named 
product, of type <classname>Product</classname>.  <classname>Product</classname> is a business 
class that contains all that pricing and detail 
information.
</para>
      <para>
The question is, how is the add to shopping cart link implemented?  If its logic is to add whatever the 
current value of the product property is (i.e., by using an &Action;
component or part of a form) then it will 
add the Nikon camera, since that's the current product (the most recent one displayed 
to the user, as far as the server is concerned &horbar; it has no way to know the user hit
the back button and was staring at the Minolta when the link was clicked).  This is the natural approach, since it 
doesn't take into account the possiblility that the user worked backwards to a prior page.
</para>
      <para>
On the other hand, if a &Direct; component is used, it can encode into the 
URL the primary key of 
the Minolta product, and that will be the product added to the shopping cart, regardless of the 
current value of the product property.
</para>
      <para>
HTML Forms, controlled by the &Form; component, are also
susceptible to these issues related to the browser back button.  Still, there are techniques to make 
even forms safe.  Borrowing an idea from more traditional JavaServer Pages development, a 
hidden field can be included in the form to sychronize the form and the application ... for 
example, including the primary key of the Minolta or Nikon product.  Tapestry includes a 
&Hidden; component used for just this purpose.
</para>
      <para>
Finally, the &ListEdit; component exists to help.  It works like a &Foreach;, but encodes the
number and value of the items it iterates as hidden form fields.
</para>
    </section>
    <section id="pages.pooling">
      <title>Page Loading and Pooling</title>
      <para>
The process of loading a page (instantiating the page and its components) can be somewhat 
expensive.  It involves reading the page's specification as well as the specification of all embedded 
components within the page.  It also involves locating, reading and parsing the HTML templates 
of all components.  Component bindings must be created and assigned.
</para>
      <para>
All of this takes time ... not much time on an unloaded server but potentially longer than is 
acceptable on a busy site.</para>
      <para>
It would certainly be wasteful to create these pages just to discard them at the end of the request 
cycle.
</para>
      <para>
Instead, pages are used during a request cycle, and then stored in a pool for later re-use.  In 
practice, this means that a relatively small number of page objects can be shared, even when there 
are a large number of clients (a single pool is shared by all clients).  The maximum number of 
instances of any one page is determined by the maximum number of clients that simultaneously 
process a request that involves that page.
</para>
      <figure>
        <title>Page Lifecycle</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Page-Lifecycle.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
As the page is retrieved from the pool, all of its persistent page properties are set.  Thus
the page is <emphasis>equivalent</emphasis> to the page last used by the application, even
if it is not the same instance.  This includes any state (that is, the settings of any instance variables)
that are particular to the client.
</para>
      <para>
This process is managed by the &IRequestCycle;.  When asked for a page, it checks whether the page has
been accessed yet for this request.  If not, the page must be obtained from the page loader and properly
attached and configured.
</para>
      <figure>
        <title>Page Loading Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Page-Load-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The page loader maintains a pool of pages, or can construct a new page instance as needed.  The
&IPageRecorder; for the page tracks the persistant page properties and can reset the properties
of the page instance to values appropriate to the current session.
</para>
      <para>
A page is taken out of the pool only long enough to process a request for a client that involves it.  
A page is involved in a request if it contains the component identified in the service URL, or if 
application code involves the page explicitly (for instance, uses the page to render the HTML 
response).  In either case, as soon as the response HTML stream is sent back to the client, any 
pages used during the request cycle are released back to the pool.
</para>
      <para>
This means that pages are out of the pool only for short periods of time.  The duration of any 
single request should be very short, a matter of a second or two.  If, during that window, a second 
request arrives (from a different client) that involves the same page, a new instance will be created.  
Unless and until that happens, a single instance will be used and re-used by all clients, regardless of 
the number of clients.
</para>
      <para>Pages stay in the pool until culled, at which point the garbage collector will release the memory used by the page (and all the components embedded in it).  The default behavior is to cull unused pages after approximately ten minutes.</para>
    </section>
    <section id="pages.localization">
      <title>Page Localization</title>
      <para>
When a page is first instantiated, its locale is set to match the locale of the 
engine it is loaded into.
</para>
      <para>
This page locale is read-only; it is set when the page is first created and never changes.
</para>
      <para>
Any component or asset on the page that needs to be locale-specific (for instance, to load the 
correct HTML template) will reference the page's locale.
</para>
      <para>
As noted previously, pages are not discarded; they are pooled for later reuse.  When an engine
gets an existing page from the pool, it always matches its locale against the pooled page's locale.  
Thus a page and its engine will always agree on locale, with one exception:  if the engine 
locale is changed during the request cycle.
</para>
      <para>
When the engine locale changes, any pages loaded in the current request cycle will reflect the 
prior locale.  On subsequent request cycles, new pages will be loaded (or retrieved from the pool) 
with locales matching the engine's new locale.
</para>
      <para>
Tapestry does not currently have a mechanism for unloading a page in the same request cycle it 
was loaded (except at the end of the request cycle, when all pages are returned to the pool).  If an 
application includes the ability to change locale, it should change to a new page after the locale 
change occurs.
</para>
      <para>
Changing locale may have other, odd effects.  If part of a page's persistent state is localized and 
the application locale is changed, then on a subsequent request cycle, the old localized state will be 
loaded into the new page (with the new locale).  This may also affect any components on the page 
that have persistent state (though components with persistent state are quite rare).
</para>
      <para>
In general, however, page localization is as easy as component localization and is usually not much 
of a consideration when designing web applications with Tapestry.
</para>
    </section>
    <section id="pages.buffering">
      <title>Page Buffering</title>
      <para>
The HTML response generated by a page during rendering is buffered.  Eight kilobytes of 8-bit 
ASCII HTML is allowed to accumulate before any HTML output is actually sent back to the 
client web browser.
</para>
      <para>
If a Java exception is thrown during the page rendering process, any buffered output is discarded, 
and the application-defined exception page is used to report the exception to the user.
</para>
      <para>
If a page generates a large amount of HTML (larger than the 8KB buffer)
and then throws an exception, the exception page is 
still used to report the exception, however the page finally viewed in the client browser will be 
"ugly", because part of the failed page's HTML will appear, then the complete HTML of the 
exception page.
</para>
      <para>
In practice, virtually all Tapestry pages will use a 
&Body; component wrapping the majority of the page (it takes
the place of the normal <sgmltag class="starttag">body</sgmltag> element), and a &Body; component 
buffers the output of all components it wraps.  This buffering is necessary so that the 
&Body; component can write out various JavaScript handlers before the main body of HTML is written 
(this is often related to the use of the &Rollover; component).
</para>
      <para>
In any case, whenever a &Body;
component is used, an exception thrown during the rendering of the page will cause all the 
HTML buffered by the &Body; component to be cleanly discarded, allowing for a clean 
presentation of the exception page.
</para>
    </section>
    <section id="pages.events">
      <title>Page Events</title>
      <para>
Each page has a lifecycle; it is created and attached to an engine.  It will render itself.  It is placed in a pool for later reuse.  Later, it comes out of the pool and is attached to a new engine to
start the process again.
There are cases where objects, especially the components embedded somewhere within the page,
need to know about this lifecycle.
</para>
      <para>
&IPage; can produce a number of events related to its lifecycle.  &PageRenderListener; is a listener interface for determining when the page starts and finishes rendering (this includes rewind renders related to the
&Action; component).
</para>
      <figure>
        <title>Page Render Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Page-Render-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The call to <function>commitPageChanges()</function> is very important.  It is not possible to make any
changes to persistant page properties after this method is invoked; doing so will throw an exception.
</para>
      <figure>
        <title>Page Rewind Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Page-Rewind-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
Page rewinds, which are related to the &Form; and &Action; components, also perform a render operation
in order to restore dynamic state on the page.  The &PageRenderListener; events are still fired.  The
event listeners can invoke <function>isRewinding()</function> on &IRequestCycle; to determine
whether this is a normal render, or for rewind purposes.
</para>
      <para>
The &PageDetachListener; interface is used by objects that wish to know when the page is detached from the
application, prior to be stored into the page pool (for later reuse).  This is used by any components
that maintain any independent state.
</para>
      <figure>
        <title>Page Detach Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Page-Detach-Sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
This cleanup occurs at the end of the request, after a response has been sent to the client web browser.
</para>
      <para>
Finally,  the &PageCleanupListener; is implemented by objects that need to know when the
&HttpSession; is invalidated.
</para>
      <figure>
        <title>Page Cleanup Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Page-Cleanup-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The engine knows when the &HttpSession; has been invalidated because the container will
invoke <function>valueUnbound()</function>.  It loads and rolls back each page, then invokes
<function>cleanupPage()</function> to allow the page to gracefully cleanup any held resources.
</para>
      <para>
Components that implement one of these interfaces usually override the method
<function>finishLoad()</function> (from &AbstractComponent;) to register themselves with the page.
</para>
    </section>
  </chapter>
  <chapter id="engine">
    <title>Application Engines and Services</title>
    <para>
The application engine is a central object whose responsibility is to run the request cycle for each 
request.  To do this, it manages resources such as page loaders and page recorders and provides 
services to the pages and components utilized during the request cycle.
</para>
    <para>
Application engines are instantiated by the application's servlet (described in the next section).   
They are stored into the &HttpSession; and are persistent between request cycles.
</para>
    <para>
An important behavior of the engine is to provide named engine services, which are used to create and 
respond to URLs.  The application engine creates and manages the request cycle and provides 
robust default behavior for catching and reporting exceptions.
</para>
    <para>
The application engine provides the page recorder objects used by the request cycle.  By doing so, 
it sets the persistence strategy for the application as a whole.  For example, applications which use 
or subclass &SimpleEngine; will use the simple method of 
storing persistent state:  in memory.  Such applications may still be distributed, since the page 
recorders will be serialized with the application engine (which is stored within the 
&HttpSession;).
</para>
    <section id="engine.servlet">
      <title>Application Servlet</title>
      <para>
Every Tapestry application has a single servlet, which acts 
as a bridge between the servlet container and the 
application engine.  The application servlet is a subclass of 
&ApplicationServlet;.
</para>
      <para>
The subclass provides the framework with the path to the application specification by 
implementing the method <function>getApplicationSpecificationPath()</function>.
</para>
      <para>
The servlet's main job is to find or create the &IEngine; instance.  It then delegates all the behavior
for processing the request to the application engine.  Encoded in the URL will be a particular
application service; the engine delegates to the service to perform the real work of handling
the request.
</para>
      <figure>
        <title>ApplicationServlet Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/ApplicationServlet-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <note id="engine.servlet.subclass-note">
        <title>Is a subclass really necessary?</title>
        <para>
	You would think that the resource path of the
	application specification could simply be
	a servlet initialization parameter, in which case
	no subclass of ApplicationServlet would be necessary.
	</para>
        <para>
	This doesn't work for two reasons.  First and foremost is how
	class loaders work inside an application server.  Generally, the Tapestry
	framework will be loaded by the system class loader, and each
	web application will be loaded by a child class loader.  The child class loader
	has visibility to all the classes in the WAR file, as well as all the classes
	on the class path, whereas the system class loader will only have visibility
	to the Tapestry framework classes.
	</para>
        <para>
	The servlet instance acts as a "hook" exposing the child class loader; the framework
	gets the class loader from the servlet instance and uses that
	to instantiate Java classes for the Tapestry components.
	</para>
        <para>
	A second, and less important reason, is that the subclass is responsible
	for overriding the <function>setupLogging()</function> method, which will be necessary
	for any production Tapestry application.
	</para>
      </note>
      <para>
The servlet may also perform some static initialization for the application in its 
<function>init()</function> method.  
This includes tasks such as loading JDBC drivers.
</para>
    </section>
    <section id="engine.req-pages">
      <title>Required Pages</title>
      <para>
Each application is required to have a minimum of five pages with specific names.  Tapestry 
provides default implementations for four of the five, but a full-featured Tapestry application may 
override any of the others to provide a consistent look-and-feel.
</para>
      <table>
        <title>Tapestry Pages</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Page Name</entry>
              <entry>Required</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Exception</entry>
              <entry>Default provided, may be changed.</entry>
              <entry>
				Page used to present uncaught 
			 	exceptions to the user.</entry>
            </row>
            <row>
              <entry>Home</entry>
              <entry>Must be provided by developer.</entry>
              <entry>The initial page displayed when the 
			 application is started.</entry>
            </row>
            <row>
              <entry>Inspector</entry>
              <entry>Provided, never overriden.</entry>
              <entry>Inspector that allows the Tapestry 
			 application to be interrogated on its 
			 structure.</entry>
            </row>
            <row>
              <entry>StaleLink</entry>
              <entry>Provided</entry>
              <entry>Page displayed when a StaleLinkException is thrown during
			the processing of a request.</entry>
            </row>
            <row>
              <entry>StaleSession</entry>
              <entry>Provided</entry>
              <entry>Page displayed when a StaleSessionException is thrown
			during the processing of a request.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
Tapestry only mandates the logical name of these four pages; the actual page component used is 
defined in the application specification.
</para>
      <para>
The <classname>Home</classname> page is the first page viewed by a client connecting to the application.  
Other than that, 
there is nothing special about the page.
</para>
      <para>
The initial connection to the application, where nothing is specified in the URL but the path to 
the servlet, causes the home service to be invoked, which makes use of the home page.
The restart service will also redirect the user to the home page.
</para>
      <para>
No default is provided for the <classname>Home</classname> page; every Tapestry application must define its
own <classname>Home</classname> page.
</para>
      <para>
The Exception page is invoked whenever an uncaught exception is thrown when processing a service.
</para>
      <para>
The Tapestry framework catches the exception and discards any HTML output (this is why 
output is buffered in memory).
</para>
      <para>
The <classname>Exception</classname> page must implement a writable JavaBeans property of type 
<classname>java.lang.Throwable</classname> named <varname>exception</varname>. 
The framework will invoke the accessor method 
before the page is rendered.
</para>
      <para>
The class &ExceptionAnalyzer; and the 
&ExceptionDisplay; component are typically used to present this information.
</para>
      <para>
The <classname>StaleLink</classname> page is displayed when a &StaleLinkException;
is  thrown, which may occur during the processing of the request.  The exception is thrown when 
Tapestry determines that the state of the page (on the server) is out of synch with the client's view 
of the page ... this most often happens when the user makes use of the browser's back button.
<footnote>
          <para>
If desired, the application engine can override the method
<function>handleStaleLinkException()</function>.  The default implementation of
this method redirects to the <classname>StaleLink</classname> page, but a custom implementation
could set up an error message on the application's <classname>Home</classname> page and
redirect there instead.
</para>
        </footnote>
      </para>
      <para>
The default implementation informs the user of the problem ("you really shouldn't use the back 
button on your browser") and uses the home service to create a link back to the 
<classname>Home</classname> page.
</para>
      <para>
The <classname>StaleSession</classname> page is displayed when a
<classname>com.primix.tapestry.StaleSessionException</classname>
is thrown.  This exception is thrown when the component
is configured to be stateful (which is the default)
and the <classname>HttpSession</classname> doesn't exist, or is 
newly created - this indicates a fresh connection to the servlet container after the old session 
timed out and was discarded.
<footnote>
          <para>
Likewise, the default behavior can be changed by overriding the method
<function>handleStaleSessionException()</function>.
</para>
        </footnote>
      </para>
      <para>
The <classname>Inspector</classname> page is provided by the framework; 
it allows a developer to interrogate a running 
Tapestry application to determine its structure.
</para>
    </section>
    <section id="engine.state">
      <title>Server-Side State</title>
      <para>
There are two types of server side state that are supported by Tapestry: persistent page properties 
and the visit object.  The first (page properties) have already been discussed.
</para>
      <para>
The visit object is a central repository for application state and presentation logic.  The visit object 
is accessible through the application engine (the engine implements a <varname>visit</varname> property).
The application engine doesn't care about the class of the visit object, or what properties it 
implements.
</para>
      <para>
The visit object holds central information that is needed by many pages.  For example, an e-
commerce application may store the shopping cart as a property of the visit object.
</para>
      <para>
When using Enterprise JavaBeans, the visit object is a good place to store remote object 
references (centralizing the logic to look up home interfaces, instantiate references, etc.).
</para>
      <para>
Every page implements a <varname>visit</varname> property that allows access to the visit object.
</para>
      <para>
When using the &SimpleEngine; engine, 
the visit object is 
created the first time it is referenced.  The class of the visit object is stored in the application 
specification.
</para>
    </section>
    <section id="engine.stateless">
      <title>Stateful vs. Stateless</title>
      <para>
Through Tapestry release 1.0.0, an &HttpSession; 
was created on the very first request cycle, and an engine was created and 
stored into it.
</para>
      <para>
This comes at some cost, however.  Creating the session is somewhat expensive if it is
not truly needed, and causes some overhead in a clustering or failover scenario.
In fact, until some real server-side state is created; that is, until a 
persistent page property is recorded or the visit object created, it isn't really
necessary to store any server-side state for a particular client.
</para>
      <para>
Starting with Tapestry release 1.0.1, the framework will operate statelessly 
as long as possible.  When triggered (by the creation of a visit, or by a
persistent page property) an &HttpSession; will be created and the engine
stored within it and the application will continue to operate pretty much
as it does in Tapestry release 1.0.0.
</para>
      <para>
While the application continues statelessly, the framework makes use of a 
pool of engine instances.  This is more efficient, as it reduces the number of objects
that must be created during the request cycle.   However, the major reason
for running statelessly is to bypass the overhead statefulness imposes
on the application server.
</para>
      <para>
Of course, if rendering the <classname>Home</classname> page of your application triggers
the creation of the &HttpSession;
<footnote>
          <para>
That is, changes a persistent page property, or forces the creation
of the visit object.
</para>
        </footnote>, then nothing is gained.  A well
designed application will attempt to defer creation of the session so that, at least,
the <classname>Home</classname> page can be displayed without creating a session.
</para>
    </section>
    <section id="engine.services">
      <title>Engine Services</title>
      <para>
Engine services provide the structure for building a web application from individual pages and 
components.
</para>
      <para>
Each engine service has a unique name.  Well known names exist for the basic services (page, 
action, direct, etc., described in a later section).
</para>
      <para>
Engine services are responsible for creating URLs (which are inserted into the response HTML) 
and for later responding to those same URLs.  This keeps the meaning of URLs localized.  In a 
typical servlet or JSP application, code in one place creates the URL for some servlet to interpret.  
The servlet is in a completely different section of code.   In situations where the servlet's behavior 
is extended, it may be necessary to change the structure of the URL the servlet processes ... and 
this requires finding every location such a URL is constructed and fixing it.  This is the kind of 
inflexible, ad-hoc, buggy solution Tapestry is designed to eliminate.
</para>
      <para>
Most services have a relationship to a particular component.  The basic services (action, direct, 
page) each have a corresponding component (&Action;, &Direct;, &Page;).
The following example 
shows how the &Page; component is used to create a link between application pages.
</para>
      <para>
First, an extract from the page's HTML template:
</para>
      <informalexample>
        <programlisting>
Click &lt;a jwcid="login"&gt;here&lt;/a&gt; to login.
</programlisting>
      </informalexample>
      <para>
This is combined with the a <sgmltag class="starttag">component</sgmltag> declaration in the the page's specification:
</para>
      <informalexample>
        <programlisting>
&lt;component id="<emphasis>login</emphasis>" type="Page"&gt;
  &lt;static-binding name="page"&gt;Login&lt;/static-binding&gt;
&lt;/component&gt;
</programlisting>
      </informalexample>
      <para>
The <varname>login</varname> component will locate the page service, and provide 'Login'
(the name of the target 
page) as a parameter.  The page service will build and return an appropriate URL, 
which the <varname>login</varname> component will incorporate into the <sgmltag class="starttag">a</sgmltag> hyperlink it 
generates.
</para>
      <para>
The resulting HTML:
</para>
      <informalexample>
        <programlisting>
Click &lt;a href="/<replaceable>servlet-path</replaceable>?service=page&amp;context=Login"&gt;here&lt;/a&gt; to login.</programlisting>
      </informalexample>
      <para>
If the user later clicks that link, the application will invoke the page service to handle the URL; 
it 
will extract the page name (<literal>Login</literal>) and render that page.
</para>
      <para>
The other services are more or less complicated, but share the same basic trait:  the service 
provides the URL and later responds if the URL is triggered.
</para>
      <para>
Links (&Action;, &Direct;, etc.) and &Form;s use services in slightly different ways.  Links encode
all the information directly into the URL whereas &Form;s encode most of the information as
hidden form fields.
</para>
      <figure>
        <title>Services and Gestures
</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Gestures.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
In the first part, a service generates a &Gesture; and then extracts the full URL from it, for use
as the <varname>href</varname> attribute of the <sgmltag class="starttag">a</sgmltag> tag.
</para>
      <para>
In the second part, a service is used to access the servlet path (which becomes the
<varname>action</varname> attribute of the <sgmltag class="starttag">form</sgmltag> element).
The query parameters are individually extracted and encoded as hidden fields in the form.
</para>
    </section>
    <section id="engine.logging">
      <title>Logging</title>
      <para>
Tapestry makes use of the Apache group's 
&Log4J; package to perform logging.  This is an easy, fast, 
powerful framework for adding logging to any Java application.  Using &Log4J;, any number of 
<emphasis>categories</emphasis> can be created, and a logging priority for each category assigned.  
Tapestry uses the complete class name as the category for each class.
</para>
      <para>
The <classname>ApplicationServlet</classname> class includes a method, <function>setupLogging()</function>, 
to initialize &Log4J;.  The provided 
implementation is sufficient for testing (see the Javadoc for more information) but serious 
applications may want to create a more involved logging configuration.
</para>
      <para>
The Tapestry Inspector includes a Logging tab that allows the logging configuration to be 
dynamically changed.  The logging priority for any category can be assigned, and new categories 
can be created.
</para>
      <para>
What this means is that, using the Inspector, it is possible to control exactly what logging output is 
produced, dynamically, while the application is still running.  The Tapestry Inspector is easily 
added to any Tapestry application.  More information on the Inspector is provided in a later 
section.
</para>
    </section>
    <section id="engine.private-assets">
      <title>Private Assets</title>
      <para>
The application engine is responsible for making private assets, assets that are stored 
on the Java classpath,
visible when necessary to client web browser.
</para>
      <para>
This takes two forms:
</para>
      <itemizedlist>
        <listitem>
          <para>Dynamic download of asset data via the application servlet.</para>
        </listitem>
        <listitem>
          <para>Dynamic copying of asset data into the web server's virtual file system.
		</para>
        </listitem>
      </itemizedlist>
      <para>
The first form is the default behavior; each private asset requires an additional round trip through the
application server and application engine to retrieve the stream of bytes which make up the asset.  This is
fine during development, but less than ideal at deployment, since it places an extra burden on the
servlet container, stealing valuable cycles away from the main aspects of servicing end users.
</para>
      <para>
The second form is better during deployment.  The bytestreams are copied out of the classpath to a specific directory,
one that is mapped into the web server's virtual file system.  Once it is so copied, the
access to the asset is completely static, as with any other image file or HTML page.
</para>
      <para>
To enable dynamic copying, it is necessary to inform the framework about what file system directory
to copy the assets to, and what virtual file system directory that maps to.  This is accomplished
using a pair of JVM system properties:
</para>
      <variablelist>
        <title>JVM System Properties</title>
        <varlistentry>
          <term>
            <varname>com.primix.tapestry.asset.dir</varname>
          </term>
          <listitem>
            <para>
				The complete pathname of a directory to which private 
				assets may be copied by the asset externalizer.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <varname>com.primix.tapestry.asset.URL</varname>
          </term>
          <listitem>
            <para>
				The URL corresponding to the external asset directory.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="engine.spec">
      <title>Application Specification</title>
      <para>
The application specification is used to identify the name of the application, the engine class for 
the application, the details of each page in the application, and to set up aliases for commonly 
used components within the application.
</para>
      <para>
The application specification is loaded when the application servlet is initialized.  It defines all
pages within the application (except for the four pages automatically provided by the framework: 
Exception, Inspector, StaleSession and StaleLink).  It allows component aliases to be defined for
commonly used components.
</para>
      <note>
        <para>
	Both the application and component specifications use the same DTD.  As with component 
	specifications, there is an older, more verbose version of the DTD which is not described
	here.
	</para>
      </note>
      <section>
        <title>
          <sgmltag class="starttag">application</sgmltag> element</title>
        <para>
The application specification begins with an XML header:
</para>
        <figure>
          <title>Application specification: <sgmltag class="starttag">application</sgmltag> element</title>
          <programlisting><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE application PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN"
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">
]]>

&lt;application
  name="<replaceable>name</replaceable>" <co id="engine.appspec.name"/>
  engine-class="<replaceable>engine-class</replaceable>"&gt; <co id="engine.appspec.engine-class"/>
  [ &lt;<link linkend="components.spec.description">description</link> ...&gt; ...] <co id="engine.appspec.description"/>
  [ &lt;<link linkend="components.spec.property">property</link> ...&gt; ...] <co id="engine.appspec.property"/>
  [ &lt;<link linkend="engine.spec.service">service</link> ... &gt; ...] 
  [ &lt;<link linkend="engine.spec.page">page</link> ...&gt; ...] 
  [ &lt;<link linkend="engine.spec.component-alias">component-alias</link> ...&gt; ...]
&lt;/application&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="engine.appspec.name">
              <para>
  	Each Tapestry application should have a unique, descriptive name.  This name is used, in a few places,
  	to store information in the &HttpSession; and <classname>ServletContext</classname>; 
  	if a single web application (WAR file) contains multiple
  	Tapestry applications, it is imperative that each has a unique name.
  	</para>
            </callout>
            <callout arearefs="engine.appspec.engine-class">
              <para>
  	Specifies the Java class to instantiate as the application engine. 
  	</para>
            </callout>
            <callout arearefs="engine.appspec.description">
              <para>
  	Applications, like components and parameters, may have a (localized) description.
  	</para>
            </callout>
            <callout arearefs="engine.appspec.property">
              <para>
 	Applications may have additional properties.  This is most commonly used to
 	specify the class to instantiate as the visit object (<literal>com.primix.tapestry.visit-class</literal>).
 	</para>
            </callout>
          </calloutlist>
        </para>
      </section>
      
      <section id="engine.spec.service">
      <title>
      	<sgmltag class="starttag">service</sgmltag> element</title>
      	
<para>
Included in some applications that wish to declare new engine services, or override the default services
provided by the framework.
</para>

<figure>
<title>Application Specification: <sgmltag class="starttag">service</sgmltag> element</title>
<programlisting>
&lt;service 
  name="<replaceable>name</replaceable>"
  class="<replaceable>java-class</replaceable>"/&gt;
</programlisting>
</figure>

<para>
Each <sgmltag class="starttag">service</sgmltag> element allows a service name to be associated
with a Java class, which must implement the &IEngineService; interface.
</para>

      </section>
      
      <section id="engine.spec.page">
        <title>
          <sgmltag class="starttag">page</sgmltag> element</title>
        <para>
The application specification will include one 
<sgmltag class="starttag">page</sgmltag> element for each page in the application.
</para>
        <figure>
          <title>Application Specification: <sgmltag class="starttag">page</sgmltag> element</title>
          <programlisting>
&lt;page
  name="<replaceable>name</replaceable>"
  specification-path="<replaceable>specification-path</replaceable>"/&gt;
</programlisting>
        </figure>
        <para>
Each page in the application must have a unique name.  Names may contain
letters, numbers, underscores, dashes and periods.
</para>
        <para>
For each page, the complete path to the page's component specification
is specified. For example 
<filename class="directory">/com/skunkworx/skunkapp/Home.jwc</filename>.
</para>
        <para>
Typically, the name of the page will match the name of the component; the logical name 
<classname>Home</classname> 
will map to 
<filename class="directory">/com/skunkworx/skunkapp/Home.jwc</filename> and be implemented by class 
<classname>com.skunkworx.skunkapp.Home</classname>.  This is not a hard and fast rule, it may make sense to use 
different names; for example, a multi-page wizard may show the relationship between the pages 
using a name like <replaceable>WizardName.PageName</replaceable>.  In other cases, naming conflicts can be eliminated by 
varying the name of the page's logical name or component.
</para>
      </section>
      <section id="engine.spec.component-alias">
        <title>
          <sgmltag class="starttag">component-alias</sgmltag> element</title>
        <para>
Component aliases are used to provide short names for commonly used components within an application.  All the components
provided with Tapestry have predefined component aliases, which may not be overriden.
</para>
        <figure>
          <title>Application Specification: <sgmltag class="starttag">component-alias</sgmltag> element</title>
          <programlisting>
&lt;component-alias
  type="<replaceable>type</replaceable>"
  specification-path="<replaceable>specification-path</replaceable>"/&gt;
</programlisting>
        </figure>
        <para>
Component aliases are mostly freeform (letters, numbers and some punctuation are acceptable).  
A good guideline is to name the alias, the specification and the Java class the same, that is, the
same as the page naming guidelines.
</para>
      </section>
    </section>
  </chapter>
  <chapter id="cycle">
    <title>Understanding the Request Cycle</title>
    <para>
Web applications are significantly different in structure from other types of interactive applications.  
Because of the stateless nature of HTTP (the underlying communication protocol between web browsers 
and web servers), the server is constantly "picking up the pieces" of a conversation with the client.
</para>
    <para>
This is complicated further in a high-volumes systems that utilizes load balancing and fail over.  
In these cases, the server is expected to pick up a conversation started by some other server.
</para>
    <para>
The Java Servlet API provides a base for managing the client - server interactions, 
by providing the &HttpSession; object, which is used to store 
server-side state information for a particular client.
</para>
    <para>
Tapestry picks up from there, allowing the application engine, pages and components 
to believe (with just a little bit of work) that they are in continuous contact 
with the client web browser.
</para>
    <para>
At the center of this is the request cycle.  This request cycle is so fundamental under Tapestry 
that a particular object represents it, and it is used throughout 
the process of responding to a client request and creating an HTML response.
</para>
    <para>
Each application service makes use of the request cycle in its own way.  
We'll describe the three common application services (page, action and direct), 
in detail.
</para>
    <para>
In most cases, it is necessary to think in terms of two consecutive request cycles.  
In the first request cycle, a particular page is rendered and, along the way, any number 
of URLs are generated and included in the HTML.  The second request cycle 
is triggered by one of those service URLs.
</para>
    <section id="cycle.URLs">
      <title>Service URLs and query parameters</title>
      <para>
All URLs generated by the framework consist of the the path to the servlet, and up to three
query parameters.

<itemizedlist>
          <listitem>
            <para>
              <varname>service</varname>: the name of the service that will be used
to processes the request.
</para>
          </listitem>
          <listitem>
            <para>
              <varname>context</varname>: contextual information needed by the service; typically
the name of the page or component involved.  Often there are several pieces of
information, separated by slashes.
</para>
          </listitem>
          <listitem>
            <para>
              <varname>parameters</varname>: additional parameters that can be made available to
the component.  This is used by a &Direct; component.  As with the context, multiple
values are seperated with slashes.</para>
          </listitem>
        </itemizedlist>
      </para>
    </section>
    <section id="cycle.page">
      <title>Page service</title>
      <para>
The page service is used for basic navigation between pages in the application.  
The page service is tightly tied to the &Page; component.
</para>
      <para>
A page service stores the name of the page as the single value in the service context.
</para>
      <para>
The request cycle for the page service is relatively simple.
</para>
      <figure>
        <title>Page Service Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Page-Service-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The URL contains the name of the page, and the corresponding page is aquired from
the request cycle.  The page is given a chance to validate that the user can
access it, it can throw &PageRedirectException; to force a render of a different page.
Otherwise, <function>setPage()</function> tells the request cycle which page will
be used to render a response, and <function>renderPage()</function> peforms
the actual render.
</para>
    </section>
    <section id="cycle.listeners">
      <title>Action and Direct listeners</title>
      <para>
The &Action;, &Direct; and &Form; components (which make use of
the <link linkend="cycle.action">action</link> and <link linkend="cycle.direct">direct</link>
services) inform the application when they have been triggered using listeners.
</para>
      <para>
A listener is an object that implements one of two listener interfaces.
</para>
      <para>
For &Direct;, the listener is specified by the &IDirectListener; interface:
<informalexample>
          <programlisting>
public void directTriggered(IDirect component, String[] context,
  IRequestCycle cycle)
  throws RequestCycleException;
</programlisting>
        </informalexample>
      </para>
      <para>For &Action; and &Form;, the listener is specified by the
&IActionListener; interface.

<informalexample>
          <programlisting>
public void actionTriggered(IComponent component, IRequestCycle cycle)
  throws RequestCycleException;
</programlisting>
        </informalexample>
      </para>
      <para>
Prior to release 1.0.2, it was necessary to create an object to be notified
by the component; this was almost always an annonymous inner class:

<informalexample>
          <programlisting>
public IActionListener getFormListener()
{
  return new IActionListener()
  {
    public void actionTriggered(IComponent component, IRequestCycle cycle)
      throws RequestCycleException
    {
      // perform some operation ...
    }
  };
}
</programlisting>
        </informalexample>
      </para>
      <para>
Although elegant in theory, that's simply too much Java code for too little effect.
Starting with Tapestry 1.0.2, it is possible to create a
<emphasis>listener method</emphasis> instead.
</para>
      <para>
A listener method takes one of two forms:

<informalexample>
          <programlisting>
public void <replaceable>method-name</replaceable>(IRequestCycle cycle)
throws RequestCycleException;
</programlisting>
        </informalexample>
      </para>
      <para>
Or:
<informalexample>
          <programlisting>
public void <replaceable>method-name</replaceable>(String[] context, IRequestCycle cycle)
throws RequestCycleException;
</programlisting>
        </informalexample>
      </para>
      <para>
The first option can act as either kind of listener.  The second option is always
a &IDirectListener;.  In both cases, the method may omit the throws clause.
</para>
      <para>
In reality, listener <emphasis>objects</emphasis> have not gone away.  Instead, there's a mechanism
whereby the appropriate listener object is created automatically when needed.
Each component includes a property, <varname>listeners</varname>, that is a collection of
listener objects for the component, synthesized from the available public methods.  The
listeners objects are properties, with the names corresponding to the method names.
</para>
      <note>
        <para>
The class <classname>AbstractEngine</classname> (the baseclass for &SimpleEngine;)
also implements a listeners property.  This allows you to easily add listener methods
to your application engine.
</para>
      </note>
      <para>
The earlier example is much simpler:
</para>
      <informalexample>
        <programlisting>
public void formSubmit(IRequestCycle cycle)
{
  // perform some operation ...
}
</programlisting>
      </informalexample>
      <para>
However, the property path for the listener binding must be changed, from <varname>formListener</varname> to
<varname>listeners.formSubmit</varname>.
</para>
    </section>
    <section id="cycle.direct">
      <title>Direct service</title>
      <para>
The direct service is used to trigger a particular action.  This service is tied to the 
&Direct; component.  The service context identifies the page and component within the page.  Any parameters
specified by the &Direct; component's <varname>context</varname> parameter are encoded as well.
</para>
      <para>
The request cycle for the direct service is more complicated that the page service.
</para>
      <figure>
        <title>Direct Service Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Direct-Service-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
As with the page service, the page involved has a chance validate the request.
The component is located within the page, and the page is set as the default
response page.  The listener is free to override this, and can load other pages,
change thier properties, or otherwise affect the state of the application.
</para>
      <para>
After the listener has its chance to respond to the request, a response page
is renderred.
</para>
      <note>
        <title>&IDirect; vs. &Direct;</title>
        <para>
The sequence shown above is for the &Direct; component, which implements the &IDirect;
interface.  In some rare cases, it is desirable to have a different component
implement the &IDirect; interface instead.  It will still implement
<function>directTriggered()</function> but will respond in its own way, likely without
a listener.
</para>
      </note>
      <para>
This is the primary way (besides forms) in which applications respond to the user.  
What's key is the component's listener, of type 
&IDirectListener;.  This is the hook that allows 
pre-defined components from the Tapestry framework to access application specific behavior.   
The page or container of the 
&Direct; component provides the necessary listener objects using dynamic bindings.
</para>
      <para>
The direct service is useful in many cases, but does have its limitations.  
The state of the page when the listener is invoked is its state just prior to rendering 
(in the previous request cycle).  This can cause a problem when the action to be performed is reliant 
on state that changes during the rendering of the page.  In those cases, the 
<link linkend="cycle.action">action service</link>
(and &Action; or &Form; components) should be used.
</para>
      <para>
The &Direct; component has an optional parameter named <varname>context</varname>. 
The value for this may be a single &String;, an array of &String;s,
or a &List; of &String;s.  
These strings are added to the URL after the id path.  
When the action is triggered, the array is reconstructed (from the URL) and provided to 
the &Direct; component and its listener.  
This is primarily used to encode dynamic page state directly 
into the URL when doing so is not compatible with the action service (described in the next section).
</para>
      <para>
The most common use for this context is to record 
an identifier for some object that is affected by the link.  For 
example, if the link is designed to remove an item from 
the shopping cart (in an e-commerce example), the context could identify which item 
to remove in terms of a primary key, or line number within the order.
</para>
    </section>
    <section id="cycle.action">
      <title>Action service</title>
      <para>
The action service is also used to trigger a particular application-specific 
action using an &Action; component, and its listener.  
The action service may also be used by the &Form; component to process HTML form submissions.
</para>
      <para>
An action service encodes the page name and component for the request.  It also includes
an action id.
</para>
      <para>
The request cycle for the action service is more complicated that the direct service.  
This sequence assumes that the component is an 
&Action;, the details of handling form submissions are described in a later section.
</para>
      <figure>
        <title>Action Service Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Action-Service-Sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The point of the action service is to restore the <emphasis>dynamic state</emphasis>
of the page to how it was when the &Action; component rendered the link.  Only then is
the listener notified.</para>
      <para>
The process of restoring the page's dynamic state is called rewinding.  Rewinding is used to 
go beyond restoring a page's persistent state and actually restore the page's dynamic state.  
Whatever state the page was in when the action URL was rendered in the previous request cycle 
is restored before the &Action; component's listener is invoked.
</para>
      <para>
Use of the action service is convenient, but not always appropriate.   
Deeply nested &Foreach; components will result in a geometric increase in 
processing time to respond to actions (as well as render the HTML).
</para>
      <para>
If the data on the page is not easily accessible then the action service should be avoided.  
For example, if the page is generated from a long running database query.  
Alternate measures, such as storing the results of the query as persistent page state should be used. 
Another alternative is to use the direct service (and &Direct; component) instead, as 
it allows the necessary context to be encoded into the URL.  This can be very useful when the dynamic state of the page is dependant on 
expensive or unpredictably changing data (such as a database query).  
</para>
      <para>
For example, a product catalog could encode the primary key of the products listed as the context
to create links to a product details page.
</para>
    </section>
    <section id="cycle.forms">
      <title>Services and forms</title>
      <para>
Processing of requests for &Form; components is a little more complicated than 
for ordinary &Action; components.  
This is because a &Form; will wrap a number of form-related components, such as 
&TextField;, &Checkbox;, &PropertySelection; and others.
</para>
      <para>
In order to accept the results posted in the HTML form, each of 
these components must be given a chance to respond to the request.  A component responds to the 
request by extracting a request parameter from the &HttpServletRequest;, 
interpreting it, and assigning a value through a parameter.  
</para>
      <para>
As with an &Action; component, a full rewind must be done, 
to account for conditional portions of the page and any &Foreach; components.
</para>
      <note>
        <para>
Starting with Tapestry release 1.0.2, &Form;s may now use the 
<link linkend="cycle.direct">direct service</link> instead
of the 
<link linkend="cycle.action">action service</link>; this is configurable.  Using the direct service is the
default behavior unless specified.  A rewind still occurs, it simply starts directly
with the &Form; component, rather than having to "work down" to it.  This can be
a big gain if a page contains many forms.
</para>
      </note>
      <para>
The &Form; component doesn't terminate the rewind cycle until <emphasis>after</emphasis> all of 
its wrapped components have had a chance to render.  It then notifies its own listener.
</para>
      <para>
The basic components, &Text;  and &TextField;, 
are quite simple.  They simply move text between the 
application, the HTML and the submitted request. 
</para>
      <para>
Individual &Checkbox; components are also simple: they 
set a boolean property.  
A &RadioGroup; and some &Radio; components 
allow a property to be set to a value 
(dependent on which radio button is selected by the user).

The &PropertySelection; component is designed to more 
efficiently handle this and can produce HTML for either 
a popup list or a collection of radio buttons.
</para>
      <para>
Tapestry also includes the more involved component, 
 &ValidField;,
 which is similar to the simple &TextField; component, 
but provide greater validation and checking of input, and 
provides the ability to visually mark fields that are required or in error.
</para>
      <para>
Regardless of which service the &Form; uses, it encodes the query parameters
(which identify the service and context)
as hidden field elements, rather than encoding them into the URL.  This is necessary because some
servlet containers ignore URL query parameters when using the HTTP POST request; therefore, it is necessary that all query parameters (including the ones related to the engine service), be part of the form posting ... and that means the use of hidden fields in the form.
</para>
    </section>
  </chapter>
  <chapter id="builtin">
    <title>Builtin Components</title>
    <para>
The Tapestry framework provides a large set of pre-written components to use 
as a starting point for building applications, or more complicated components.
</para>
    <para>
This section will provide a brief overview of the available components and 
their most commonly used parameters.  The Javadoc is the final reference for this information.
</para>
    <para>
Each of these components is automatically added as an alias in 
an application specification.
</para>
    <section id="builtin.Action">
      <title>Action</title>
      <para>
Creates an <sgmltag class="starttag">a</sgmltag> hyperlink in the HTML response.  
If the link is triggered, then the <classname>Action</classname>
 retrieves its listener, and invokes 
<function>actionTriggered()</function> on it.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>listener</term>
          <listitem>
            <para>The object notified if and when the link is triggered.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the link is produced.  If true, the link is not
			created (but wrapped elements are still rendered).
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Any">
      <title>Any</title>
      <para>
Used to make an existing HTML element dynamic.  Informal 
parameters are used to fill in the attributes of the element.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>element</term>
          <listitem>
            <para>The element to be produced.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Block">
      <title>Block</title>
      <para>
A block is used to prevent a section of an HTML template from being renderred.  That is,
a <classname>Block</classname> is allowed a body, but never renders it.  Intead, an
&InsertBlock; component is used to insert
the body of the block.
</para>
      <para>
        <classname>Block</classname>s are used to pass arbitrary blocks of HTML and components as parameters
to a component.
</para>
    </section>
    <section id="builtin.Body">
      <title>Body</title>
      <para>
Replaces the <sgmltag class="starttag">body</sgmltag> tag.  
The <classname>Body</classname> component provides support dynamic scripting and image
preloaded, used by other 
components, such as the &Rollover; component.
</para>
    </section>
    <section id="builtin.Checkbox">
      <title>Checkbox</title>
      <para>
Used to implement a checkbox form element (<sgmltag class="starttag">input type=checkbox</sgmltag>). 
Must be wrapped by a &Form;  component.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>selected</term>
          <listitem>
            <para>Indicates whether the checkbox is selected or not.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the text field is active or not.  This attibute is
			ignored by Netscape Navigator 4.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Conditional">
      <title>Conditional</title>
      <para>
Makes part of an HTML template conditional.  
The body of the <classname>Conditional</classname> component is only rendered if a 
specified condition is met.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>condition</term>
          <listitem>
            <para>The condition to be met.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>invert</term>
          <listitem>
            <para>If true, then the condition is inverted. 
			This is useful for simulating an else clause.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Delegator">
      <title>Delegator</title>
      <para>
A component which delegates its behavior (that is, the HTML rendered) 
to some other object.  This is occasionally useful when the HTML 
to render is best generated from pure Java code (or has been provided 
from some source outside of Tapestry).
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>delegate</term>
          <listitem>
            <para>The object which will provide the rendering for the component.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Direct">
      <title>Direct</title>
      <para>
Creates a <sgmltag class="starttag">a</sgmltag> hyperlink that notifies 
the component when the link is triggered.  
The link includes some context-specific data that 
is passed on to the component's listener.  This  
is used in cases where the &Action; component can't be used 
(or is too inefficient).
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>listener</term>
          <listitem>
            <para>Specifies an object that is notified when the link is clicked.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>context</term>
          <listitem>
            <para>An array of Strings to be encoded into the URL. 
			These parameters will be decoded when the link is triggered.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the link is produced. If true, the 
			portion of the template the link surrounds is still rendered, but 
			not the link itself.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.ExceptionDisplay">
      <title>ExceptionDisplay</title>
      <para>
A component, used on the standard exception page, which renders a detailed list of the exceptions.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>exceptions</term>
          <listitem>
            <para>An array of &ExceptionDescription; objects.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.FieldLabel">
      <title>FieldLabel</title>
      <para>
A component, used with a &ValidField;
that provides the label for the field.  A delegate object may be 
specified that will change the visual formatting of the label to reflect the 
state of the field, for instance, to make the label red when the field itself is in error.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>field</term>
          <listitem>
            <para>The validating text field (type &IField;)
			associated with the label.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>delegate</term>
          <listitem>
            <para>An optional &IValidationDelegate;, responsible for the visual look 
			of the label.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Foreach">
      <title>Foreach</title>
      <para>
A component that loops through a set of values, setting a property 
for each value before rendering its wrapped elements.  The &ListEdit;
component is often more useful if the items are inside a &Form;.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>source</term>
          <listitem>
            <para>The source of objects to be iterated, and array or &List; of objects.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>Used to update the current value on each iteration.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Form">
      <title>Form</title>
      <para>
A component that manages an HTML <sgmltag class="starttag">form</sgmltag>.
The other form-related components must be wrapped inside the <classname>Form</classname>.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>method</term>
          <listitem>
            <para>The value to use for the method attribute of the <sgmltag class="starttag">form</sgmltag>
		 	tag.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>listener</term>
          <listitem>
            <para>The &IActionListener;, informed after the wrapped components of the form 
			have had a chance to respond to the request.</para>
          </listitem>
        </varlistentry>
       
        <varlistentry>
          <term>delegate</term>
          <listitem>
            <para>An &IValidationDelegate; used to handle validation exceptions.  Forms
            that wrap &ValidField;s must bind a delegate.
			</para>
          </listitem>
        </varlistentry>
        
      </variablelist>
    </section>
    <section id="builtin.Hidden">
      <title>Hidden</title>
      <para>
Adds a hidden (<sgmltag class="starttag">input type=hidden</sgmltag>) field to a 
&Form;.  This is often used to synchronize 
data when the form is submitted with values
known when the page was rendered .
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>Property to store when the form is renderred and to 
			restore when the form is submitted.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Image">
      <title>Image</title>
      <para>
Used to insert a static image.  &Rollover; is a similar component that can create
dynamic mouse-over effects as well.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>image</term>
          <listitem>
            <para>The image to show, specified as an asset.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.ImageSubmit">
      <title>ImageSubmit</title>
      <para>
An image button inside a &Form;.  Clicking the button submits the form.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>If true, the image button will be disabled (not respond to the mouse).</para>
            <para>The disabled attribute is ignored by Netscape Navigator 4.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>image</term>
          <listitem>
            <para>The default image to display.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>selected</term>
          <listitem>
            <para>A property updated if the button is clicked.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>tag</term>
          <listitem>
            <para>The value assigned to the selected property if the button is clicked.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Insert">
      <title>Insert</title>
      <para>
Inserts dynamic text into the HTML response.   Invalid characters (such as &lt; and &gt;) 
are converted into HTML entities ('&amp;lt;' and '&amp;gt;').  Use an &InsertText; component
to handle multi-line text.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>The value to be inserted, which may be a &String; or an 
			arbitrary object (that is converted to a String;).
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>format</term>
          <listitem>
            <para>A format (<classname>java.text.Format</classname>) object used to format 
			the &String; or object.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.InsertBlock">
      <title>InsertBlock</title>
      <para>
Inserts the body of a &Block;.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>block</term>
          <listitem>
            <para>The &Block; to insert.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.InsertText">
      <title>InsertText</title>
      <para>
Inserts multiline text, adding <sgmltag class="starttag">p</sgmltag> tags around each line,
or inserting <sgmltag class="starttag">br</sgmltag> tags between each line.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>text</term>
          <listitem>
            <para>The text to insert.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>mode</term>
          <listitem>
            <para>Identifies how to break apart lines for display.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.InsertWrapped">
      <title>InsertWrapped</title>
      <para>
Renders the static HTML and components wrapped by the container of the 
<classname>InsertWrapped</classname> component.  Components 
which have HTML templates and can wrap other elements should 
include exactly one <classname>InsertWrapped</classname> component in their template.
</para>
    </section>
    <section id="builtin.ListEdit">
      <title>ListEdit</title>
      <para>
Similar to a &Foreach;, this component must be wrapped by
a &Form;.  It provides the iteration of the &Foreach; but helps to avoid stale link
exceptions by recording the number of items in its source, as well as an encoding of
each value, as hidden fields in the form.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>source</term>
          <listitem>
            <para>The source of objects to be iterated, and array or &List; of objects.
			This is only accessed when the containing page is renderred, not when the
			containing form is rewound.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>Used to update the current value on each iteration.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Option">
      <title>Option</title>
      <para>
Implements a component that manages an HTML
<sgmltag class="starttag">option</sgmltag> form element, and must 
be wrapped by a &Select; component.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>selected</term>
          <listitem>
            <para>Used to indicate whether the given option is selected.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Page">
      <title>Page</title>
      <para>
Creates a hyperlink to another page within the application.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>page</term>
          <listitem>
            <para>The name of a page to link to.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the link is produced. If true, the portion of 
			the template the link surrounds is still rendered, but not the link itself.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.PropertySelection">
      <title>PropertySelection</title>
      <para>
Creates form elements that allow a property of an object to be selected.  This may take the form
of a <sgmltag class="starttag">select</sgmltag> or a sequence 
of <sgmltag class="starttag">input type=radio</sgmltag> elements.
</para>
      <para>
Uses a model to map between Java values that will be assigned, and 
textual labels that will appear in the HTML response.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>The property value to edit.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>model</term>
          <listitem>
            <para>The model used to enumerate the potential values, and 
			to produce text labels for each value.
		</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>renderer</term>
          <listitem>
            <para>
An object used to render the property selection; two default implementations are 
provided (one creates a pop up list, the other a table of radio buttons).
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Radio">
      <title>Radio</title>
      <para>
A component used to manage an HTML radio form element.
Such a component must be wrapped (possibly indirectly) inside a 
&RadioGroup; component.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>
				The value to be assigned through the 
				&RadioGroup;'s selected parameter, if the 
				<classname>Radio</classname> is selected by the user.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>
				If true, then the <classname>Radio</classname> is disabled. It will write a 
				disabled attribute into its tag when rendering, and will 
				not update its selected binding.
			</para>
            <para>
				The disabled attribute is ignored by Netscape Navigator 4.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.RadioGroup">
      <title>RadioGroup</title>
      <para>
A container of &Radio; components, which itself must be 
within a &Form; component.  
The <classname>RadioGroup</classname> and &Radio; components 
combined provide similar functionality to the 
&PropertySelection; component (though with some greater flexibility).
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>selected</term>
          <listitem>
            <para>The property to be updated by the 
			&Radio; button is selected by the user.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Rollover">
      <title>Rollover</title>
      <para>
Works with any kind of link component, which must wrap it, 
to provide a rollover image button ... a button where the 
image changes when the mouse move over it or off of it.  
A <classname>Rollover</classname> is disabled if the link that wraps it is disabled
(in which case it doesn't respond to the mouse).  Use the simpler
&Image; component is dynamic behavior isn't required.
</para>
      <para>
The component provides all the necessary JavaScript to swap the image when the mouse
enters and exits the button.  However, the <classname>Rollover</classname> must be wrapped
(ultimately) by a &Body; component.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>image</term>
          <listitem>
            <para>The (initial) image to show (if not disabled).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>focus</term>
          <listitem>
            <para>The image displayed when the mouse moves over the 
			button (unless disabled).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>blur</term>
          <listitem>
            <para>The image displayed when the mouse moves off of 
			the button (unless disabled).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>The image displayed if the link is itself disabled.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Script">
      <title>Script</title>
      <para>
A component that accesses a script file and adds JavaScript functions and statements 
to the response page.  The specified script file is read and parsed and 
substitutions are made before the final scripting code is inserted into the page.  This
allows the JavaScript to be tailored to the ids and names that are generated by Tapestry.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>script</term>
          <listitem>
            <para>The resource path of the script file.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Select">
      <title>Select</title>
      <para>
A component which creates a <sgmltag class="starttag">select</sgmltag> form element (it is
also a wrapper around &Option;  components), within a &Form;.
</para>
      <para>
It is generally easier to use a &PropertySelection; unless multiple selections
are desired.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>multiple</term>
          <listitem>
            <para>If true, the component allows multiple selection.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Service">
      <title>Service</title>
      <para>
A component for creating a link for an arbitrary engine service 
that uses no parameters, such as the reset or home service.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>service</term>
          <listitem>
            <para>The name of the service.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the link is produced. If true, 
			the portion of the template the link surrounds is still rendered, 
			but not the link itself.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Shell">
      <title>Shell</title>
      <para>
Provides the outer "shell" of a page, including the 
<sgmltag class="starttag">html></sgmltag>, 
<sgmltag class="starttag">head</sgmltag> and <sgmltag class="starttag">title</sgmltag> tags 
(but not the <sgmltag class="starttag">body</sgmltag> tag) (which is typically provided by a &Body;
component).
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>title</term>
          <listitem>
            <para>Title for the page, placed within a <sgmltag class="starttag">title</sgmltag> element.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>stylesheet</term>
          <listitem>
            <para>Stylesheet to be used for the page.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Submit">
      <title>Submit</title>
      <para>
Provides a form submit button (&lt;input type=submit&gt;).  
This is most useful when the form contains multiple submit buttons and the 
application needs to know which was actually pressed.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>If true, the submit button will be 
			disabled.</para>
            <para>The disabled attribute is ignored by Netscape Navigator 4).
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>label</term>
          <listitem>
            <para>The label to put on the button.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>selected</term>
          <listitem>
            <para>A property updated if the button is the one clicked 
			to submit the form.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>tag</term>
          <listitem>
            <para>The value applied to the selected property if the button 
			is the one clicked to submit the form.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.ShowInspector">
      <title>ShowInspector</title>
      <para>
Adds a link to a page that is used to raise the Tapestry Inspector in a new window.  
This is generally added to the navigational border of an application, and is only enabled
when developing the application (disabled in deployment).
</para>
    </section>
    <section id="builtin.Text">
      <title>Text</title>
      <para>
Implements a component that manages an HTML <sgmltag class="starttag">textarea</sgmltag> form element, 
within a &Form; component.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>The text inside the text area.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>
				Controls whether the <classname>Text</classname> is active or not.
			</para>
            <para>The disabled attribute is ignored by 
				Netscape Navigator 4.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>columns</term>
          <listitem>
            <para>The width of the <sgmltag class="starttag">textarea</sgmltag>, in characters.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>rows</term>
          <listitem>
            <para>The number of rows in the <sgmltag class="starttag">textarea</sgmltag>.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.TextField">
      <title>TextField</title>
      <para>
Implements a component that manages an HTML 
<sgmltag class="starttag">input type=text</sgmltag> or 
<sgmltag class="starttag">input type=password</sgmltag> form element, within a 
&Form; component.
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>The text inside the text field.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>hidden</term>
          <listitem>
            <para>If true, then the text field is written as a 
			<sgmltag class="starttag">input type=password</sgmltag> form element.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the text field is active or not.  Netscape Navigator 4
			ignores the disabled attribute.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>displayWidth</term>
          <listitem>
            <para>Controls the display width of the text control in the client browser.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>maximumLength</term>
          <listitem>
            <para>Controls the maximum number of characters that the 
			text control will accept.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.Upload">
      <title>Upload</title>
      <para>
    A form element used to handle file uploads.  The uploaded file is represented
    by an instance of &IUploadFile;.
    </para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>file</term>
          <listitem>
            <para>The &IUploadFile; (representing the content of the file provided
            by the client).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the text field is active or not.  Netscape Navigator 4
			ignores the disabled attribute.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="builtin.ValidField">
      <title>ValidField</title>
      <para>
An improved &TextField; that can perform simple validations and translations
between a string representation (used in the client web browser) and
an object representation.  
</para>
      <variablelist>
        <title>Parameters</title>
        <varlistentry>
          <term>value</term>
          <listitem>
            <para>The object value editted by field.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>hidden</term>
          <listitem>
            <para>If true, then the text field is written as a 
			<sgmltag class="starttag">input type=password</sgmltag> form element.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>displayName</term>
          <listitem>
            <para>
A name for the the component, used when formulating error messages.
</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>validator</term>
          <listitem>
            <para>An &IValidator; used to convert between string and object
 					representations.  The validator may also enforce rules on the
 					input value, such as minimum and maximums, or to make the
 					value required.
 				</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>Controls whether the text field is active or not.  Netscape Navigator 4
			ignores the disabled attribute.
			</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>displayWidth</term>
          <listitem>
            <para>Controls the display width of the text control in the client browser.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>maximumLength</term>
          <listitem>
            <para>Controls the maximum number of characters that the 
			text control will accept.
			</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </chapter>
  <chapter id="apps">
    <title>Designing Tapestry Applications</title>
    <para>
When first starting to design a Tapestry application, the 
designer consider some basic elements as a guide 
to the overall design of the application.
</para>
    <section id="apps.storage">
      <title>Persistent Storage Strategy</title>
      <para>
Tapestry pages store a certain amount of 
client state between request cycles. Each implemention of the 
&IEngine; interface provides a different strategy.
</para>
      <para>
Currently, only the &SimpleEngine; class is 
provided with the framework; it uses in-memory page recorders.  
When the engine is serialized, the page recorders are serialized along with it.
</para>
      <para>
The <classname>IPageRecorder</classname> interface doesn't specify anything about how 
a page recorder works.  This opens up many possibilities for storage of state, 
including flat files, databases, stateful EJB session beans, or HTTP Cookies.
</para>
      <para>
In fact, a very sophisticated application engine could mix and match, 
using cookies for some pages, in-memory for others.
</para>
      <para>
By default, page recorders stay active for the duration of the user session.  
If a page will not be referenced again, or its persistent 
state is no longer relevant or needed, the application may explicitly "forget" its state.
</para>
      <para>
Remember that for load balancing and fail over reasons, 
the engine will be serialized and de-serialized.  Ideally, its serialized state should 
be less than two kilobytes; because Java serialization is inefficient, 
this does not leave much room.
</para>
      <para>
The Tapestry Inspector can be used to monitor the size of the serialized engine in a running
application.
</para>
    </section>
    <section id="apps.pages">
      <title>Identify Pages and Page Flow</title>
      <para>
Early in the design process, the page flow of the application should 
be identified.  Each page should be identified and 
given a specific name.
</para>
      <para>
Page names are less structured than other identifiers in Tapestry.  
They may contain letters, numbers, underscores, dashes and periods.  Tapestry makes 
absolutely no interpretation on the page names.
</para>
      <para>
In many applications, certain parts of the functionality are 
implemented as "wizards", several related pages that are used in 
sequence as part of a business process.  A common example of this is 
initial user registration, or when submitting an order to an 
e-commerce system.
</para>
      <para>
A good page naming convention for this case is
"<replaceable>wizard name</replaceable>.<replaceable>page name</replaceable>" 
(a period separates the two names).  This visually identifies that several pages are related.  
In addition, a Java package for the wizard 
should be created to contain the Java classes, component specifications, 
HTML templates and other assets related to the wizard.  Having the wizard name match the package name
is also helpful.
</para>
      <para>
The designer must also account for additional entry points to the application 
beyond the standard home page.  These may require 
additional application services (see below).
</para>
    </section>
    <section id="apps.commmon-logic">
      <title>Identify Common Logic</title>
      <para>
Many applications will have common logic that appears on many pages.  
For example, an e-commerce system may have a shopping cart, and have many 
different places where an item can be added to the cart.
</para>
      <para>
In many cases, the logic for this can be centralized in the visit object.  
The visit object may implement methods for adding products to the shopping cart.  
This could take the form of Java methods, component listeners. 
</para>
      <para>
In addition, most web applications have a concept of a 'user'.  
The object representing the user should be a property of the visit object, 
making it accessible to all pages and components.
</para>
      <para>
Most Tapestry applications will involve some interaction with Enterprise JavaBeans.  
The code to lookup home interfaces, or to gain access to ession beans, is typically 
located in the visit object.
</para>
      <para>
Listener code, on various pages, will cast the visit object to the appropriate 
actual class and invoke methods.
</para>
      <para>
The following example demonstrates this idea.  Visit is a 
hypothetical visit object that uses EJBs.
</para>
      <informalexample>
        <programlisting>
public IActionListener getListener()
{
  return new IActionListener()
  {
    public void actionTriggered(IComponent component,
                                IRequestCycle cycle)
    {
      Visit visit; <co id="apps.common-logic.ex.visit"/><![CDATA[
      ]]><replaceable>ISomeHomeInterface</replaceable> home;
	
      visit = (Visit)getVisit();
	
      home = visit.<replaceable>getSomeHomeInterface</replaceable>();

      try
      {
      	// etc.
      }
      catch (RemoteException ex)
      {
        throw new ApplicationRuntimeException(ex);
      }
    }
  };
}
</programlisting>
      </informalexample>
      <para>
        <calloutlist>
          <callout arearefs="apps.common-logic.ex.visit">
            <para>
  Each application can freely define the type of the visit object,
  and its is common to call the class "Visit".  Another option is
  to create a subclass for the engine and store home interfaces
  there.
  </para>
          </callout>
        </calloutlist>
      </para>
    </section>
    <section id="apps.services">
      <title>Identify Engine Services</title>
      <para>
Tapestry applications will need to define new engine services when a page 
must be referenced from outside the Tapestry application
</para>
      <para>
This is best explained by example.  It is 
reasonable in an e-commerce system that there is a particular page that shows 
product information for a particular product.  This information includes 
description, price, availability, user 
reviews, etc.  A user may want to bookmark that 
page and return to it on a later session.
</para>
      <para>
Tapestry doesn't normally allow this; the page may be bookmarked, but 
when the bookmark is triggered, the page may not render correctly, because it 
will not know which product to display.  The URLs normally generated in a 
Tapestry application are very context sensitive; they are only meaningful in 
terms of the user's navigation throughout the application, starting with the Home page.  
When bookmarked, that context is lost.
</para>
      <para>
By defining a new engine service, the necessary context can be encoded directly 
into the URL, in a way similar to how the direct action works.  This is
partially a step backwards towards typical servlet or JSP development, but 
even here Tapestry offers superior services.  In the e-commerce example, 
the service URL could encode some form of product identifier.
</para>
      <para>
An example of this is in the Virtual Library application.  In 
order to make certain pages bookmarkable, a new service named 
"external" was created.  This involved subclassing 
&SimpleEngine; 
to provide the new service.
</para>
      <para>
The external service includes the name of a page and the primary key 
of an object that page displays (this was simplified by the 
design of the Vlib entity beans, which always use  an <classname>Integer</classname> 
as the primary key).
</para>
      <para>
The external service works much the same was as the page service, except 
that it invokes an additional method on the page, <function>setup()</function>, 
which is passed the primary key extracted from the URL.
</para>
      <para>
The end result is that when a user arrives at such a page, 
the URL used identifies the page and the primary key.  Bookmarking the page stores the URL so 
that when the bookmark is later opened, the correct data 
is read and displayed.
</para>
    </section>
    <section id="apps.common-components">
      <title>Identify Common Components</title>
      <para>
Even before detailed design of an application, certain portions of pages will be 
common to most, if not all, pages.  The canonical example is 
a "navigation bar", a collection of links and buttons used to navigate to 
specific pages within the application.  An e-commerce site may 
have a shopping cart related component that can appear in many places.
</para>
      <para>
In many cases, common components may need to be parameterized:  the navigation bar may 
need a parameter to specify what pages are to appear; the shopping cart component 
will require a shopping cart object (the component is the view 
and controller, the shopping cart object is the model).
</para>
      <para>
Other examples of common components are viewers and editors of 
common data types.
</para>
      <para>
In the Virtual Library, components that make use of the external service were 
created.  The components, <classname>BookLink</classname> and <classname>PersonLink</classname>, took as 
parameters the corresponding objects (<classname>Book</classname>  or <classname>Person</classname>) 
and created links to the pages 
that displayed the details of that <classname>Book</classname>  or <classname>Person</classname>.
</para>
    </section>
  </chapter>
  <chapter id="coding">
    <title>Coding Tapestry Applications</title>
    <para>
After performing the design steps from the previous chapter, it 
is time to start coding.  The designs will imply 
certain requirements for the implementations.
</para>
    <section id="coding.engine">
      <title>Application Engine</title>
      <para>
Application engines will be serialized and de-serialized as part of 
load balancing and fail over.  As much as possible, attributes of the application 
object should be transient.  For example, the instance variable that 
holds the <classname>ApplicationSpecification</classname> is transient; if 
needed (after de-serialization), the engine can locate the specification from 
its servlet (the servlet reads the application specification once, when it is first initialized).
</para>
      <para>
This is largely not an issue, since most applications use a provided class, 
such as &SimpleEngine;.  Subclassing 
is only necessary when the application requires new engine services, 
or needs a different method of instantiating the visit object, or
needs to store additional data (see <link linkend="coding.stateless" endterm="coding.stateless.title"/>).
</para>
    </section>
    <section id="coding.visit">
      <title>Visit Object</title>
      <para>
The visit object will contain all the data about a client's 
visit to the web application.  If possible, it should have a no-arguments 
constructor (this allows &SimpleEngine; to instantiate it as needed).
</para>
      <para>
Keeping the size of the serialized engine small is a 
good goal for overall performance and scalability, and the visit object is serialized 
with the engine.  During initial development, the visit 
object should implement the <classname>java.io.Serializable</classname> interface.
</para>
      <para>
Once the application, and the structure of the visit object, is 
stable, the more efficient <classname>java.io.Externalizable</classname> interface should be implemented instead. 
</para>
      <para>
In addition, deferring the creation of the visit object as late as 
possible is also of benefit, since this is the best way to keep the serialized engine small.
</para>
    </section>
    <section id="coding.stateless">
      <title id="coding.stateless.title">Operating Stateless</title>
      <para>
Tapestry applications can operate in a stateless mode, that is, without a &HttpSession;.  The
framework automatically creates a session when needed; when the Visit object is first created,
or when any persistent page properties are changed.
</para>
      <para>
Ideally, the <classname>Home</classname> page of the application should not trigger the creation of a session: 
it should be careful not to create the Visit object.  Remember that hits on your application will form
a curve:  The <classname>Home</classname> page is at the top of the curve, and it drops of rapidly as
users penetrate deeper into the application ... how many times have you visited the front page of a web site
and gone no further?
</para>
      <para>
Stateless operations will affect &Action;, &Direct; and &Form; components on your pages.  By default, they
will reject requests while the application is running stateless; the user will be redirected
to the <classname>StaleSession</classname> page.  This is appropriate, since normally, the lack of a session
means that the previous session timed out and was discarded.
</para>
      <para>
Each of these components has a <varname>stateful</varname> parameter which may be bound to 
<classname>Boolean.FALSE</classname>.  When <varname>stateful</varname> is false, the components will accept stateless
requests.
</para>
      <para>
As the developer, you must keep a careful eye on what's stateful vs. stateless, and look to move
stateless data into the engine, so as to avoid creating a visit object as long as possible.  For example,
the engine can resolve and store 
EJB home interfaces and references to <emphasis>stateless</emphasis> session EJBs.  
Even read-only database data can be stored in the engine.  However, anything that is related to a particular 
user must be stored in the visit object (or a persistent page property).
</para>
      <para>
It is also important to not accidentally create the visit object.  Every page includes
a <varname>visit</varname> property which will create the visit if it doesn't already exist.  This will,
in turn, force the creation of an &HttpSession;.  On the other hand, the property path
<varname>engine.visit</varname> will <emphasis>not</emphasis> create the visit object.
To avoid creating the visit, you may need to wrap some of your HTML template inside
a &Conditional; component whose condition parameter is bound to the property <varname>engine.visit</varname>.
</para>
    </section>
    <section id="coding.ejb">
      <title>Enterprise JavaBeans Support</title>
      <para>
The visit object should provide access to the most commonly 
used Enterprise JavaBeans used in the application.  It can provide a central location 
for the common code (related to JNDI and to narrowing EJB references), rather 
than have that scattered throughout the application.
</para>
      <para>
It is important to remember that EJB references are not serializable.  
However, it is possible to convert between an EJB reference and an EJB handle, 
and handles are serializable.  The visit should make any 
instance variables that store EJB references transient, and should perform 
extra serialization work to serialize and restore the necessary EJB handles.
</para>
      <para>
Also remember that persistent page properties that are EJB references are 
<emphasis>automatically</emphasis>
converted to handles when stored, and back into references when restored.
</para>
    </section>
    <section id="coding.page-classes">
      <title>Page classes</title>
      <para>
It is often useful to create one or two subclasses of 
&BasePage; specific to your application.  
Often your application will have a consistent navigational border on some 
or all pages that can be supported by the base class.
Many applications have one set of pages that are visible 
to unidentified guests, and a second section that is visible once the user logs 
in.  A base class for the second set of pages could override  the 
<function>validate()</function> method to redirect to a login page 
if the user is not already logged in.
</para>
    </section>
  </chapter>
  <chapter id="coding-components">
    <title>Designing new components</title>
    <para>
Creating new components using Tapestry is designed to be quite simple.
</para>
    <para>
Components are typically created through aggregation, that is, by combining existing 
components using an HTML template and specification.
</para>
    <para>
You will almost always want to define a short alias 
for your new component in the application specification.  This insulates developers from minor 
name changes to the component specification, such as moving the component 
to a different Java package.
</para>
    <para>
Like pages, components should reset their state back to 
default values when the page they are contained within is returned to the pool.
</para>
    <para>
Most components do not have any state.  A component which does should 
implement the &PageDetachListener; interface, 
and implement the <function>pageDetached()</function> method.
</para>
    <para>
The <function>pageDetached()</function> method is invoked from the page's 
<function>detatch()</function> method, which is invoked at the very end 
of the request cycle, just before the page is returned to the page pool.
</para>
    <section id="coding-components.base-class">
      <title>Choosing a base class</title>
      <para>
There are two basic types of components:  those that use an HTML template, and those that don't.
</para>
      <para>
Nearly all of the base components provided with the Tapestry framework don't 
use templates.  They inherit from the class 
&AbstractComponent;.  Such 
components must implement the <function>render()</function> method.
</para>
      <para>
Components that use templates inherit from a subclass of 
&AbstractComponent;: 
&BaseComponent;.  They should leave the <function>render()</function>
method alone.
</para>
      <para>
In some cases, a new component can be written just by combining existing components 
(this often involves using inherited bindings).  Such a codeless 
component will consist of just a specification and an HTML 
template and will use the &BaseComponent; class without subclassing.  This
is even more possible when using <link linkend="components.helper-beans">helper beans</link>.
</para>
    </section>
    <section id="coding-components.parameters">
      <title>Parameters and Bindings</title>
      <para>
You may create a component that has parameters.  Under Tapestry, component parameters are a 
kind of "named slot" that can be wired up as 
a source (or sink) of data in a number of ways.  This "wiring up" is 
actually accomplished using binding objects.
</para>
      <para>
The page loader, the object that converts a component specification into an actual 
component, is responsible for creating and assigning the bindings.  It uses the method 
<function>setBinding()</function> to assign a binding with a name.  Your 
component can retrieve the binding by name using <function>getBinding()</function>.
</para>
      <para>
For example, lets create a component that allows the color of 
a span of text to be specified using a <classname>java.awt.Color</classname> object.  The 
component has a required parameter named <varname>color</varname>.  The class's 
<function>render()</function> method is below:
</para>
      <informalexample>
        <programlisting>
public void render(IResponseWriter writer, IRequestCycle cycle)
  throws RequestCycleException
{
  IBinding colorBinding;
  Color color;
  String encodedColor;

  colorBinding = getBinding("color");
  color = (Color)colorBinding.getObject("color", Color.class);
  encodedColor = RequestContext.encodeColor(color);

  writer.begin("font");
  writer.attribute("color", encodedColor);

  renderWrapped(writer, cycle);

  writer.end();
}</programlisting>
      </informalexample>
      <para>
The call to <function>getBinding()</function> is relatively expensive, since 
it involves rummaging around in a &Map; and then 
casting the result from <classname>java.lang.Object</classname> to <classname>com.primix.tapestry.IBinding</classname>.  
</para>
      <para>
Because bindings are typically set once and then read frequently by the component, 
implementing them as private instance variables is much more efficient.  Tapestry 
allows for this as an optimization on frequently used components.
</para>
      <para>
The <function>setBinding()</function> method in 
<classname>AbstractComponent</classname> checks to see if there is a read/write 
JavaBeans property named "<replaceable>name</replaceable>Binding" of
type &IBinding;.  In this example, it 
would look for the methods <function>getColorBinding()</function> and <function>setColorBinding()</function>.
</para>
      <para>
If the methods are found, they are invoked from 
<function>getBinding()</function> and <function>setBinding()</function> instead of updating the 
&Map;.
</para>
      <para> This changes the example to:</para>
      <informalexample>
        <programlisting>
          <emphasis>private IBinding colorBinding;

public void setColorBinding(IBinding value)
{
  colorBinding = value;
}

public IBinding getColorBinding()
{
  return colorBinding;
}
</emphasis>

public void render(IResponseWriter writer, IRequestCycle cycle)
  throws RequestCycleException
{
  Color color;
  String encodedColor;

  color = (Color)<emphasis>colorBinding</emphasis>.getObject("color", Color.class);
  encodedColor = RequestContext.encodeColor(color);

  writer.begin("font");
  writer.attribute("color", encodedColor);

  renderWrapped(writer, cycle);

  writer.end();
}</programlisting>
      </informalexample>
      <para>
This is a trade off; slightly more code for slightly better performance.  
There is also a memory bonus; the 
&Map; used by &AbstractComponent; will never be created.
</para>
    </section>
    <section id="coding-components.persistent-state">
      <title>Persistent Component State</title>
      <para>
As with pages, individual components may have state that persists between request cycles.  
This is rare for non-page components, but still possible and useful in special circumstances.
</para>
      <para>
A client that must persist some client state uses its page's <varname>changeObserver</varname>.  
It simply posts <classname>ObservedChangeEvents</classname> with itself (not its page) as the 
source.  In practice, it still simply invokes the <function>fireObservedChange()</function> method.
</para>
      <para>
In addition, the component should implement the interface 
&PageDetachListener;, and implement 
the method <function>pageDetached()</function>, and, within that method, reset all 
instance variables to default values, just as a page does (in its <function>detach()</function> method).
</para>
    </section>
    <section id="coding-components.assets">
      <title>Component Assets</title>
      <para>
Tapestry components are designed for easy re-use.  Most 
components consist of a specification, a Java class and an HTML template.
</para>
      <para>
Some components may need more; they may have additional image 
files, sounds, Flash animations, QuickTime movies or whatever.  These are 
collectively called "assets".  
</para>
      <para>
Assets come in three flavors:  external, internal and private.
</para>
      <itemizedlist>
        <listitem>
          <para>An external asset is just a fancy way of packaging a URL at an arbitrary web site.
		</para>
        </listitem>
        <listitem>
          <para>An internal asset represents a file with a URL 
		relative to the web server containing the Tapestry application.</para>
        </listitem>
        <listitem>
          <para>A private asset is a file within the class path, 
		that is, packaged with the component in a Java Archive (JAR) file.  
		Obviously, such assets are not normally visible to the web server.
		</para>
        </listitem>
      </itemizedlist>
      <para>
Components which use assets don't care what flavor they are; they 
simply rely on the method <function>buildURL()</function> to provide a 
URL they can incorporate into the HTML they generate.  For example, the 
&Image; component has an image parameter that is used to 
build the <varname>src</varname> attribute of an HTML <sgmltag class="starttag">img</sgmltag> element.
</para>
      <para>
Assets figure prominently into three areas:  reuse, deployment and localization.
</para>
      <para>
Internal and private assets may be localized:  when 
needed, a search occurs for a localized version, relative to a base name 
provided in the component specification.
</para>
      <para>
Private assets simplify both re-use and deployment.  They allow a re-usable Tapestry 
component, even one with associated images, style sheets (or other assets) to be incorporated 
into a Tapestry application without any special consideration.  For example, the standard exception 
page makes use of a private asset to access its stylesheet.
</para>
      <para>
In a traditional web application, private assets would need to be packaged 
separately from the 'component' code and placed into some pre-defined 
directory visible to the web server.
</para>
      <para>
Under Tapestry, the private assets are distributed with the component 
specification, HTML templates and Java code, within a Java Archive (JAR) 
file, or within the <filename class="directory">WEB-INF/classes</filename> directory of a 
Web Application Archive (WAR) file.  The resources are located within the 
running application's class path.
</para>
      <para>
The Tapestry framework takes care of making the private 
assets visible to the client web browser.  This occurs in 
one of two ways:
</para>
      <itemizedlist>
        <listitem>
          <para>The private assets are copied out of the 
				class path and to a directory visible to the web server.  
				This requires some additional configuration of the Tapestry 
				application's web deployment descriptor.
			</para>
        </listitem>
        <listitem>
          <para>
			The assets are dynamically accessed from the class 
			path using the asset service.
		</para>
        </listitem>
      </itemizedlist>
      <para>
Copying assets out of the class path and onto the web 
site is the best solution for final deployment, since it allows the assets 
to be retrieved as static files, an operation 
most web servers are optimized for.
</para>
      <para>
Dynamically accessing assets requires additional operations in Java code.  
These operations are not nearly as efficient as static 
access.  However, dynamic access is much more convenient during development 
since much less configuration (in this case, copying of assets) is 
necessary before testing the application.
</para>
      <para>
As with many things in Tapestry, the components using assets 
are blind as to how the assets are made visible to the client.
</para>
      <para>
Finally, every component has an <varname>assets</varname> property that is an 
unmodifiable &Map;.  The assets in the 
&Map;
are accessible as if they were properties of the &Map;.  In 
other words, the property path <varname>assets.welcome</varname> is valid, if the 
component defines an asset named 'welcome'.
</para>
    </section>
  </chapter>
  <chapter id="script">
    <title>Tapestry and JavaScript</title>
    <para>
Building cutting edge Web applications is not entirely about the server side.
A significant amount of work must be done on the client side to support truly dynamic
user experiences.  Typically, this scripting is done using the JavaScript language embedded
into major web browsers such as Internet Explorer and Netscape Navigator.
</para>
    <para>
These effects range from simple effects such as image rollovers (changing 
the icon used for a link whent he cursor is over it) to more involved
patterns such as client side validation of forms or even complex animations.
</para>
    <para>
In traditional, static web page development, the author is completely responsible
for this aspect of development, usually aided by a web page authoring tool, such as
Dreamweaver.  Ultimately, though, the web page developer assigns unique names or ids to
various elements on the page, and attaches JavaScript event handlers to 
the elements.</para>
    <example>
      <title>Traditional JavaScript usage</title>
      <programlisting><![CDATA[

var preload = new Array();
preload[0] = new Image();
preload[0].src = "/images/button.gif";
preload[1] = new Image();
preload[1].src "/images/button-highlight.gif";

function rollover(image, index)
{
  image.src = preload[index].src;
}

.
.
.
  <a href="..."
    onMouseOver="javascript:rollover(document.button, 1);"
    onMouseOut="javascript:rollover(document.button, 0);">
    <img name="button" src="/images/button.gif">
  </a>

]]></programlisting>
    </example>
    <para>
The preloading business is all about forcing the browser to load the image <emphasis>before</emphasis>
it is needed, so that it is already in memory when the mouseover event handler
needs it.
</para>
    <para>
From here, adding additional rollovers means extending the <varname>preload</varname> array, providing
names for the additional <sgmltag class="starttag">img</sgmltag> elements and writing the additional
event handlers for the <sgmltag class="starttag">a</sgmltag> elements.
</para>
    <para>
Now, envision a running Tapestry application.  With everything so dynamic (especially when you account for things like the
&Foreach; component), it's all but impossible to even know how many links and buttons will be on the page, never 
mind what they'll
all be named.  At first glance, it may appear that Tapestry prevents the use of this kind of scripting.
</para>
    <para>
In fact, Tapestry is structured to enhance this kind of scripting.  This is faciliated by the &Body; component, which replaces
the <sgmltag class="starttag">body</sgmltag> element of the page.  Virtually all of a page's content will be wrapped by the &Body; component,
including everything that has need for dynamic scripting.
</para>
    <section id="script.body">
      <title>The Body component</title>
      <para>
The &Body; component provides a number of services to the components it wraps.  It handles preloading of
images.  It provides the ability to add arbitrary JavaScript to the page, to include an external static
JavaScript document, or to the
<sgmltag class="starttag">body</sgmltag> element's onload event handler.  Finally, it provides an easy way 
to generate unique identifiers needed for things like image names.
</para>
      <para>
When the &Body; component renders, it registers itself as an attribute of the &IRequestCycle;.  This
allows components wrapped by the &Body; component, directly or indirectly, to locate it and invoke methods
on it.  These methods are used to define preloaded images, and add JavaScript code to the response HTML.
</para>
      <figure>
        <title>Body Component Rendering Sequence</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Body-sequence.gif" format="GIF"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
When rendering is complete, the &Body; component will have produced four distinct portions of the
HTML response:
</para>
      <informalexample>
        <programlisting>
&lt;script language="JavaScript" src="..."&gt;&lt;/script&gt; <co id="script.body.include"/>
&lt;script language="JavaScript"&gt;&lt;!-- <co id="script.body.script"/>

...

function tapestry_onLoad()  <co id="script.body.onload"/>
{
}

// --&gt; &lt;/script&gt;
&lt;body onload="javascript:tapestry_onLoad();"&gt; <co id="script.body.tag"/>

... <co id="script.body.wrapped"/>

&lt;/body&gt;

</programlisting>
      </informalexample>
      <para>
        <calloutlist>
          <callout arearefs="script.body.include">
            <para>Any number of included static scripts may be added to the page.</para>
          </callout>
          <callout arearefs="script.body.script">
            <para>
  This script block is only emitted when necessary; that is, because some component
  needed to generate scripting or initialization (or preloaded images).  The block
  is properly "commented" so that older browsers, those that fail to support scripting,
  will not be confused by the JavaScript code.
  </para>
          </callout>
          <callout arearefs="script.body.onload">
            <para>
  The onload event handler function is only generated if some component requests some
  onload initialization.
  </para>
          </callout>
          <callout arearefs="script.body.tag">
            <para>
  The <sgmltag class="starttag">body</sgmltag> tag only specfies a <varname>onload</varname>
  event handler function if one is needed.
  </para>
          </callout>
          <callout arearefs="script.body.wrapped">
            <para>
  The content of the <sgmltag class="starttag">body</sgmltag> element is defined by the
  Tapestry components it wraps.  Importantly, the rollovers, JavaScript, event handlers and
  the content are all generated in parallel (the &Body; component uses buffering so that
  the JavaScript portion is written out first).
  </para>
          </callout>
        </calloutlist>
      </para>
    </section>
    <section id="script.script">
      <title>Script documents</title>
      <para>
Scripting in Tapestry requires some extra thought; in the examples above, the web developer
specifically knew the URLs of the images to preload and the name of the 
<sgmltag class="starttag">img</sgmltag> element to be affected.  For Tapestry, those things are not
known ahead of time; scripting is a matter of plugging in variable content to a template.
</para>
      <para>
Tapestry supports scripting with the Tapestry Script document, another XML document type.  A Tapestry
script takes as input a number of <emphasis>symbols</emphasis> and uses them to construct 
the desired JavaScript event handlers, and to provide initializations for them.
</para>
      <section>
        <title>
          <sgmltag class="starttag">script</sgmltag> element</title>
        <para>
Script documents, which use the filename extension <literal>.script</literal>, consist
of a <sgmltag class="starttag">script</sgmltag> element.
</para>
        <figure>
          <title>Script document: <sgmltag class="starttag">script</sgmltag> element</title>
          <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script PUBLIC 
  "-//Howard Ship//Tapestry Script 1.1//EN"
  "http://tapestry.sf.net/dtd/Script_1_1.dtd">
]]>

&lt;script&gt;
  [ &lt;<link linkend="script.spec.include-script">include-script</link> ... /&gt; ... ] <co id="script.dtd.script.include-script"/>
  [ &lt;<link linkend="script.spec.let">let</link> ...&gt; ...] <co id="script.dtd.script.let"/>
  [ &lt;<link linkend="script.spec.body">body</link>&gt; ] <co id="script.dtd.script.body"/>
  [ &lt;<link linkend="script.spec.initialization">initialization</link>&gt; ] <co id="script.dtd.script.initialization"/>
  
&lt;/script&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="script.dtd.script.include-script">
              <para>
Any number of other scripts may be included.
</para>
            </callout>
            <callout arearefs="script.dtd.script.let">
              <para>
  The <sgmltag class="starttag">script</sgmltag> may contain any number of 
  <sgmltag class="starttag">let</sgmltag> elements, used to define new symbols.
  </para>
            </callout>
            <callout arearefs="script.dtd.script.initialization">
              <para>
  The <sgmltag class="starttag">body</sgmltag> element contains
  JavaScript event handling logic.  This is optional, and may appear
  only once.
  </para>
            </callout>
            <callout arearefs="script.dtd.script.initialization">
              <para>
  The <sgmltag class="starttag">initialization</sgmltag> element
  contains JavaScript statements added to the HTML
  <sgmltag class="starttag">body</sgmltag> element's 
  <function>onLoad</function> event handler.
  </para>
            </callout>
          </calloutlist>
        </para>
      </section>
      <section id="script.spec.include-script">
        <title>
          <sgmltag class="starttag">include-script</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">include-script</sgmltag> element</title>
          <programlisting>
&lt;include-script resource-path="<replaceable>path</replaceable>" /&gt;
</programlisting>
        </figure>
        <para>
This element is used to include external, static, JavaScript scripts on the rendered page.
This is useful to in cases where large parts of the JavaScript do not depend on any dynamic symbols.
The path is to a resource on the class path, much like
a <link linkend="components.spec.assets">private asset</link>.
</para>
      </section>
      <section id="script.spec.let">
        <title>
          <sgmltag class="starttag">let</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">let</sgmltag> element</title>
          <programlisting>
&lt;let key="<replaceable>symbol-name</replaceable>"&gt; <co id="script.dtd.let.key"/>
  [
     [ <replaceable>text</replaceable> ] <co id="script.dtd.let.text"/>
     [ &lt;<link linkend="script.spec.insert">insert</link> ...&gt; ] 
     [ &lt;<link linkend="script.spec.if">if</link> ...&gt; ] 
     [ &lt;<link linkend="script.spec.if-not">if-not</link> ...&gt; ] 
     [ &lt;<link linkend="script.spec.foreach">foreach</link>...&gt; ] 
  ... ] <co id="script.dtd.let.full-content"/>
&lt;/let&gt;

</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="script.dtd.let.key">
              <para>
 The new symbol to define.  This should be a new name, though no check is made.  The
 symbol gets the result of evaluating the body of the
 <sgmltag class="starttag">let</sgmltag> element, though leading and trailing whitespace
 is removed.
 </para>
            </callout>
            <callout arearefs="script.dtd.let.text">
              <para>
 The <sgmltag class="starttag">let</sgmltag> element
 consists of static text intermixed with the other elements (which produce
 dynamic text).
 </para>
            </callout>
            <callout arearefs="script.dtd.let.full-content">
              <para>
 The allowed content of the <sgmltag class="starttag">let</sgmltag> element is called
 <emphasis>full content</emphasis>.  Most of the other elements defined by the document type
 also use full content.  <sgmltag class="starttag">let</sgmltag> elements generally don't have
 a need for other than text and the <sgmltag class="starttag">insert</sgmltag> element.
 </para>
            </callout>
          </calloutlist>
        </para>
        <para>
This element is used to define new symbols.  The most common use of this is to define the
name of a function, usually by combining some unique name or id with other text.  This new
symbol is then used in the <sgmltag class="starttag">body</sgmltag> element to define the function, and
in the <sgmltag class="starttag">initialization</sgmltag> element to establish the function as the
handler for some HTML element's event.
</para>
        <para>
The <sgmltag class="starttag">let</sgmltag> elements are evaluated in order.  Often, some building
block symbols are established first; other symbols add suffixes and prefixes to form the final
names of functions.
</para>
      </section>
      <section id="script.spec.insert">
        <title>
          <sgmltag class="starttag">insert</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">insert</sgmltag> element</title>
          <programlisting>
&lt;insert property-path="<replaceable>property-path</replaceable>"/&gt;
</programlisting>
        </figure>
        <para>
The <sgmltag class="starttag">insert</sgmltag> element is used to insert the value of a property.
Simple names are just the names of symbols passed to the script, or the names can be
a full property path (operating like a <sgmltag class="starttag">binding</sgmltag> element
in a component specification).
</para>
      </section>
      <section id="script.spec.if">
        <title>
          <sgmltag class="starttag">if</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">if</sgmltag> element</title>
          <programlisting>
&lt;if property-path="<replaceable>property-path</replaceable>"&gt;
  [ <replaceable>full content</replaceable> ]
&lt;/if&gt;
</programlisting>
        </figure>
        <para>
The <sgmltag class="starttag">if</sgmltag> element provides some conditional content.  It evaluates
its property and, if true (generally, non-null, non-empty or non-zero, depending on the type),
it includes its content.  The content is full content, meaning just about anything can be
contained (including <sgmltag class="starttag">if</sgmltag>, <sgmltag class="starttag">foreach</sgmltag>, etc.).
</para>
      </section>
      <section id="script.spec.if-not">
        <title>
          <sgmltag class="starttag">if-not</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">if-not</sgmltag> element</title>
          <programlisting>
&lt;if-not property-path="<replaceable>property-path</replaceable>"&gt;
  [ <replaceable>full content</replaceable> ]
&lt;/if&gt;
</programlisting>
        </figure>
        <para>
The <sgmltag class="starttag">if-not</sgmltag> element is the same as the
<sgmltag class="starttag">if</sgmltag> element, but it inverts the meaning of the
property, including its content if the property is false.
</para>
      </section>
      <section id="script.spec.foreach">
        <title>
          <sgmltag class="starttag">foreach</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">foreach</sgmltag> element</title>
          <programlisting>
&lt;foreach key="<replaceable>key</replaceable>"
  property-path="<replaceable>property-path</replaceable>"&gt;
  [ <replaceable>full content</replaceable> ]
&lt;/foreach&gt;
</programlisting>
        </figure>
        <para>
The <sgmltag class="starttag">foreach</sgmltag> element is an analog of the &Foreach; component;
it iterates through a list of objects.  On each iteration, it sets the named symbol
(via the <varname>key</varname> attribute) and inserts its body.
</para>
      </section>
      <section id="script.spec.body">
        <title>
          <sgmltag class="starttag">body</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">body</sgmltag> element</title>
          <programlisting>
&lt;body&gt;
  [ <replaceable>full content</replaceable> ]
&lt;/body&gt;
</programlisting>
        </figure>
        <para>
The <sgmltag class="starttag">body</sgmltag> element evaluates its content and the result is added to the
script block preceding the HTML <sgmltag class="starttag">body</sgmltag> element in the response HTML.
</para>
      </section>
      <section id="script.spec.initialization">
        <title>
          <sgmltag class="starttag">initialization</sgmltag> element</title>
        <figure>
          <title>Script document: <sgmltag class="starttag">initialization</sgmltag> element</title>
          <programlisting>
&lt;initialization&gt;
  [ <replaceable>full content</replaceable> ]
&lt;/initialization&gt;
</programlisting>
        </figure>
        <para>
The <sgmltag class="starttag">initialization</sgmltag> element evaluates its content and the result is 
added to the 
HTML <sgmltag class="starttag">body</sgmltag> element's 
<varname>onLoad</varname> event handler function.
</para>
      </section>
    </section>
    <section id="script.script-component">
      <title>Script component</title>
      <para>
The &Script; component is one of the more common ways to add scripting to a Tapestry page.
</para>
      <para>
The component has a single required parameter, <varname>script</varname> that is the path to
a Script document within the classpath.  The optional <varname>symbols</varname> parameter
allows a &Map; to be specified as the base set of symbols, to which are added any informal
parameters.
</para>
      <para>
A handful of scripts are included with the framework.  The following script
is used by the Tapestry Inspector to force a &Form; to submit when a &PropertySelection;
changes value.
</para>
      <figure>
        <title>SelectSubmit.script</title>
        <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE script PUBLIC 
  "-//Howard Ship//Tapestry Script 1.1//EN"
  "http://tapestry.sf.net/dtd/Script_1_1.dtd"&gt;
&lt;!--

Adds a handler that forces the form containing a particular select element
to submit when the select changes its value.

Input symbols:
  component: The PropertySelection component the script is to be attached to.
--&gt;
&lt;script&gt;
&lt;let key="formName"&gt; <co id="script.ex.formName"/>
  &lt;insert property-path="component.form.name"/&gt;
&lt;/let&gt;
&lt;let key="selectName"&gt;
  &lt;insert property-path="component.name"/&gt;
&lt;/let&gt;
&lt;let key="formPath"&gt; <co id="script.ex.formPath"/>
  document.&lt;insert property-path="formName"/&gt;
&lt;/let&gt;
&lt;let key="selectPath"&gt;
  &lt;insert property-path="formPath"/&gt;.&lt;insert property-path="selectName"/&gt;
&lt;/let&gt;
&lt;let key="functionName"&gt; <co id="script.ex.functionName"/>
  onChange_&lt;insert property-path="formName"/&gt;_&lt;insert property-path="selectName"/&gt;
&lt;/let&gt;

&lt;body&gt;

function &lt;insert property-path="functionName"/&gt;()
{
  &lt;insert property-path="formPath"/&gt;.submit();
}

&lt;/body&gt;

&lt;initialization&gt;
&lt;insert property-path="selectPath"/&gt;.onchange = &lt;insert property-path="functionName"/&gt;;
&lt;/initialization&gt;
&lt;/script&gt;
</programlisting>
      </figure>
      <calloutlist>
        <callout arearefs="script.ex.formName">
          <para>
	The property path makes it easy to find the &Form; containing the &PropertySelection;
	component.  Part of the necessity for this script is that form and form element names
	are assigned by Tapestry.
	</para>
        </callout>
        <callout arearefs="script.ex.formPath">
          <para>
	Here, the <emphasis>path</emphasis> refers to how to identify the HTML element in the
	browser's DOM.
	</para>
        </callout>
        <callout arearefs="script.ex.functionName">
          <para>
	The function name is used twice; to define the function and to setup the event handler.
	Note how the name incorporates the unique form name and element name, this ensures
	that any number of &PropertySelection; components, inside any number of &Form;s can
	use this script without concern for naming conflicts.
	</para>
        </callout>
      </calloutlist>
      <para>
Using the script simply involves declaring it in the component specification and configuring
its input parameters.  It must also be in the HTML template, before the closing
<sgmltag class="endtag">jwc</sgmltag> tag of the &Form; component.
</para>
      <figure>
        <title>SubmitScript usage</title>
        <programlisting>
&lt;component id="submitScript" type="Script"&gt;
  &lt;static-binding name="script"&gt;/com/primix/tapestry/form/SelectSubmit.script&lt;/static-binding&gt;
  &lt;binding name="component" property-path="components.selectPage"/&gt;
&lt;/component&gt;
</programlisting>
      </figure>
    </section>
  </chapter>
  <chapter id="inspector">
    <title>The Tapestry Inspector</title>
    <para>
Tapestry includes a powerful tool: the Inspector, which reveals the construction 
of a running Tapestry application. 
</para>
    <para>
The &ShowInspector; component is used to include a link that 
launches the Inspector.  This is typically included in the navigational border of an 
application, so that it is available to the developer from any page.  The 
Inspector itself is a page that is provided by the framework and available to 
any Tapestry application.
</para>
    <section id="inspector.spec">
      <title>Specification View</title>
      <figure>
        <title>Inspector - Specification View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Spec.jpg" format="JPG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The Inspector allows the developer to see how the page is constructed.  
It reveals the page's specification, a list of embedded components within the page, 
the page's HTML template and more.
</para>
      <para>
It is possible to dig down and see the same information for 
any component within the page.
</para>
    </section>
    <section id="inspector.template">
      <title>Template View</title>
      <figure>
        <title>Inspector - Template View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Template.jpg" format="JPG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The template view shows the HTML template for the component.  Within the template,
component references are links that "dig down" into their template (if they have one).
</para>
    </section>
    <section id="inspector.properties">
      <title>Properties View</title>
      <figure>
        <title>Inspector - Properties View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Properties.jpg" format="JPG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The properties view shows the persistent properties for the page and any components on the page.
</para>
    </section>
    <section id="inspector.engine">
      <title>Engine View</title>
      <figure>
        <title>Inspector - Engine View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Engine.jpg" format="JPG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The engine view shows information about the running engine instance, including its name and class.
</para>
      <para>
Not shown in the figure is the serialized state of the application engine (in a hex dump format) and a
long display of all the request cycle information (the same information produced when an 
uncaught exception is thrown).
</para>
    </section>
    <section id="inspector.logging">
      <title>Logging View</title>
      <figure>
        <title>Inspector - Logging View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Logging.jpg" format="JPG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The final tab allows control of the logging behavior of the application.  It allows the logging level
for any category to be set, and allows new categories to be created.
</para>
    </section>
  </chapter>
  
<appendix id="jars">
	<title>Tapestry JAR files</title>
	
<para>
The Tapestry distribution includes a number of JAR files, some of which are needed to compile the framework (and
examples), others are used at runtime (and must be added to the servlet container's classpath).
</para>

<variablelist>


	<varlistentry>
		<term><filename>com.primix.tapestry-<replaceable>x.x.x</replaceable>.jar</filename></term>
		<listitem>
			<para>
			The main Tapestry framework.  This is needed at compile time and runtime.  At runtime, it is most
			often added to the servlet container's classpath.  The framework release number is
			integrated into the file name.
			</para>
		</listitem>
	</varlistentry>
	
	<varlistentry>
		<term><filename>ejb.jar</filename></term>
		<listitem>
			<para>
			Contains the EJB 1.1 packages.  These classes are needed by Tapestry at runtime 
			(Tapestry includes some special handling
			of EJB client stubs recorded by a &PageRecorder;.  However, most often, the servlet container or application server
			provides these interfaces and classes.
			</para>
		</listitem>
	</varlistentry>
	
	<varlistentry>
		<term><filename>javax.servlet.jar</filename></term>
		<listitem>
			<para>
			Defines the Java Servlet API.  Again, these classes and interfaces are needed by Tapestry
			at runtime, but are almost always provided by the servlet container.
			</para>
		</listitem>
	</varlistentry>
	
	<varlistentry>
		<term><filename>junit.jar</filename></term>
		<listitem>
			<para>
			The <ulink url="http://www.junit.org/">JUnit</ulink> testing framework, used by the Tapestry unit tests
			(in the <filename>junit</filename> directory).
			</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><filename>javax.xml.jaxp.jar</filename></term>
		<listitem>
		<para>
		The Java API for XML Processing.  Needed at runtime to allow Tapestry to locate an XML
		processor, used to parse application and component specifications.
		</para>
		</listitem>
	</varlistentry>
	
	<varlistentry>
		<term><filename>log4j-core.jar</filename></term>
		<listitem>
		<para>
		The &Log4J; logging framework.  This is used by Tapestry at runtime.
		</para>
		</listitem>
	</varlistentry>
	

	<varlistentry>
		<term><filename>mcoidb.jar</filename></term>
		<listitem>
		<para>
		The <ulink url="http://mckoi.com/database/">McKoi SQL Database</ulink>, a GPL Java database.
		This is used by the Virtual Library demonstration.
		</para>
		</listitem>
	</varlistentry>


	<varlistentry>
		<term><filename>net.sf.tapestry.contrib-<replaceable>x.x.x</replaceable>.jar</filename></term>
		<listitem>
		<para>
		Contains additional components and tools that are not integral to the framework itself, such
		as the Palette.  Needed at runtime if any such components are used in an application.
		The framework release number is integrated into the file name.
		</para>
		</listitem>
	</varlistentry>
	
	<varlistentry>
		<term><filename>org.apache.crimson.jar</filename></term>
		<listitem>
		<para>
		An XML parser that can be used by Tapestry unless a different one is configured.
		</para>
		</listitem>
	</varlistentry>
	
	
	<varlistentry>
		<term><filename>org.mortbay.jetty.jar</filename></term>
		<listitem>
		<para>
		The &Jetty; servlet container, used to execute the Tapestry examples, tutorials and demostrations.
		</para>
		</listitem>
	</varlistentry>
	
	<varlistentry>
		<term><filename>Tutorial.war</filename></term>
		<term><filename>Vlib.ear</filename></term>
		<term><filename>Vlib.war</filename></term>
		<term><filename>Wap.war</filename></term>
		<listitem>
		<para>
		Example Tapestry applications.
		</para>
		</listitem>
	</varlistentry>
	
	
	<varlistentry>
		<term><filename>VlibBeans.jar</filename></term>
		<listitem>
		<para>
		An EJB JAR, containing entity and session EJBs for deployment with &JBoss;.
		</para>
		</listitem>
	</varlistentry>
	
</variablelist>

</appendix>
  
<appendix id="building">
	<title>Building Tapestry</title>
	
<para>
The Tapestry framework and examples can be easily rebuilt using &Ant;.  The Tapestry distribution includes
all necessary source code, build files and most of the 
supporting frameworks.  The distribution has virtually the same structure as the Tapestry
CVS repository (the main difference being that the Tapestry distribution does <emphasis>not</emphasis> include
the source for the Tapestry manuals).
</para>

<para>
The Tapestry distribution can be downloaded from
the <ulink url="http://sourceforge.net/project/showfiles.php?group_id=4754">Tapestry downloads page</ulink>.
Alternately, Tapestry source can be obtained via
<ulink url="http://sourceforge.net/cvs/?group_id=4754">CVS access on SourceForge</ulink>.
</para>

<para>
In either case, the &JBoss; distribution is also required for a complete build (some of the example code, as well as the 
<filename>net.sf.tapestry.contrib.jar</filename> framework has dependencies on &JBoss;).
</para>

<para>
In addition, it is necessary to inform the Tapestry build files where the JBoss distribution exists.
The file <filename>config/build.properties</filename> exists for this purpose.  A sample file is included in the distribution;
this can be renamed or copied, then editted, filling in the entry for <varname>jboss.dir</varname>.
</para>

<para>
Tapestry is currently built and tested againt release 2.3.3 of JBoss.
</para>

<para>
Finally, you must have &Ant; 1.4 or better, as well as a JDK 1.2 or better JDK.
</para>

<para>
Rebuilding the framework is as easy as executing the command <command>ant clean install</command>.  The
<varname>clean</varname> target deletes all derived files, including the precompiled libraries included in
the distribution.  The <varname>install</varname> target recompiles all Java code and builds the library JAR files.
</para>



</appendix>
  
  <appendix id="faq">
    <title>Frequently Asked Questions</title>
    <para>
This section contains a few Q's and A's gleemed from the 
<ulink url="http://sourceforge.net/forum/forum.php?forum_id=14493">Tapestry forums at SourceForge</ulink>.
</para>
    <qandaset defaultlabel="qanda">
      <qandaentry>
        <question>
          <para>
            <classname>java.lang.NoSuchMethodError</classname> gets thrown
		when I attempt to use Tapestry with Tomcat.  How do I fix this?
		</para>
        </question>
        <answer>
          <para>
            <ulink url="http://jakarta.apache.org/tomcat/index.html">Tomcat</ulink> ships with version 1.0 of the 
	<ulink url="http://java.sun.com/xml/xml_jaxp.html">JAXP (Java API for XML Processing)</ulink> 
	framework.  Tapestry is coded against version 1.1.  You must replace the
	<filename>jaxp.jar</filename> in Tomcat with the
	<filename>javax.xml.jaxp.jar</filename> from Tapestry.  Simply delete the old file
	and copy the new one into the Tomcat distribution.
		</para>
          <para>
		In addition you must replace <filename>parser.jar</filename> (which contains
		an XML parser) with
		<filename>org.apache.crimson.jar</filename>, Sun's default XML parser.
		</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>Can Tapestry be used to create a Portal application?</para>
        </question>
        <answer>
          <para>
		Of course it can!
		</para>
          <para>
		This question came up pretty frequently on the SourceForge forum, so
		I put together a mini-portal application as one of the tutorials.  This sounded
		out some limitations in the framework: the <classname>Porlet</classname> component
		dynamically combines components from multiple pages (using the &Block; and
		&InsertBlock; components).
		</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>
		One more time.  What's this business about rewinding things for forms?
		</para>
        </question>
        <answer>
          <para>
		This is one of the big stumbling blocks for some users of Tapestry.
		The way Tapestry deals with forms is very complex, with a reason: it allows
		for incredibly dynamic pages.
		</para>
          <para>
		In tradional web applilcations, the developer is responsible for
		naming each form element, as well as writing a servlet to
		handle the request cycle when the form is submitted.  That turns into
		a lot of code to extract name parameters from the &HttpServletRequest;, 
		convert them from Strings to other datatypes, and push the values
		into appropriate business objects.
		</para>
          <para>
		This works fine as far as it goes ... but the developer has an advantage 
		that the Tapestry framework doesn't have:  the exact name, type and number
		of form elements is known during development.
		</para>
          <para>
		By contrast, Tapestry has to figure this all out on the fly.  In addition,
		Tapestry forms can wrap around &Foreach; components ... that means the same
		&TextField; component may be responsible for updating a property of
		a whole slew of objects.  On top of that, the use
		of &Conditional;, &Block; and &InsertBlock; components
		mean that the exact set of components involved may be determined dynamically.
		</para>
          <note>
            <para>
			An example of this is the 
			<link linkend="inspector.logging">Tapestry Inspector Logging View</link>.  A single
			&PropertySelection; is wrapped by a &ListEdit; which iterates throught
			a list of the possible categories.
			</para>
            <para>
			Categories may be added at any time (in fact, that's another function
			of the page).
			</para>
          </note>
          <para>
		Now, it's natural to envision Tapestry dynamically walking through its components
		and HTML templates to render the form seen in the user's web browser.  The
		mental leap required is that
		the initial renderring process has to be <emphasis>run again</emphasis> in order to figure out
		which components are involved in processing the submission, and how.  That's
		the <emphasis>rewind phase</emphasis>.
		</para>
          <para>
		Just as with the initial render, Tapestry must work through 
		just the right set of components, in just the right order, taking into account
		&Conditional; and &Foreach; components.  You must also factor in that Tapestry is
		assigning the names used for the HTML form elements, which must also be "rediscovered"
		so that the right HTTP parameter can be combined with the correct component and
		assigned to the appropriate business object property.
		</para>
          <para>
		Sure, this is overkill when you have a simple form to enter the user's name.
		But doesn't it give you a warm feeling to know that when you do create
		your killer dynamic form, the <emphasis>very same code</emphasis> you've come to know
		and trust will be waiting to handle it, just as easily?
		</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>
	How do I specify the CSS class used for a Tapestry component?
	</para>
        </question>
        <answer>
          <para>
	Most Tapestry components support
	<link linkend="components.informal-parameters">informal parameters</link>.  
	These are used to specify
	additional HTML attributes for the tag generated by the component.
	</para>
          <para>
	You can set the value for such informal parameters
	in the <link linkend="components.specification">component specification</link>, or
	in the <link linkend="components.html-template">HTML template</link>.
	</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>
	I get the StaleSession page when I submit a form on my home page.  Why?
	</para>
        </question>
        <answer>
          <para>
	Tapestry applications run in a <link linkend="engine.stateless">stateless</link> mode initially.  That is, they
	don't create a &HttpSession;.  This continues until the application has
	some specific server-side state, at which point the &HttpSession; is created.
	</para>
          <para>
	By default, &Form;s (as well as &Action;s) are stateful; they require that
	an active &HttpSession; exists.  If there isn't an active session, they
	throw a <classname>StaleSessionException</classname>.  However, you can bind
	the <varname>stateful</varname> parameter of these components to
	<classname>Boolean.FALSE</classname> to remove this check.
	</para>
          <para>
	This check makes sense once there's server side state; it detects when
	an &HttpSession; has expired from lack of use.  It's better than seeing
	an anomolous <classname>NullPointerException</classname>, which is quite likely
	when all state is lost.
	</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>What happened to the &ILifecycle; interface?</para>
        </question>
        <answer>
          <para>
Prior to release 1.0.5, there was an interface, &ILifecycle;, that could
optionally be implemented by components so that they could be informed about the lifecycle
of the page which contains them, especially knowing when the page was detached from the engine (so that
the components could reset thier state accordingly).  
</para>
          <para>
By release 1.0.5, this has become somewhat awkward.  Firstly, several non-component objects needed
similar notification and there wasn't a way to cleanly accomplish this.  Secondly, a finer grained
approach was desired, as different objects had different notification requirements.
</para>
          <para>
For release 1.0.5, the interface was replaced by a more standard approach; well defined JavaBeans events.
These are described in the <link linkend="pages.events">Page Events</link> section of this document.
</para>
          <para>
The &ILifecycle; interface will be completely removed in release 1.1.0.  In the meantime, its deprecated, which
will generate some warnings in your code if you create classes which implement the interface.
</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>Why do I need to subclass &ApplicationServlet;?
		</para>
        </question>
        <answer>
          <para>
Several folks have suggested that subclassing &ApplicationServlet; is unneccessary,
and it's primary job, identifying the application specification path, could be accomplished 
using servlet initial parameters.
There are several reasons why a subclass is necessary, outlined in this
<link linkend="engine.servlet.subclass-note">note</link>.  Primarily, it's
a class loader issue.
</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>What happened to <classname>ValidatingTextField</classname>,
		<classname>NumericField</classname>,
		<classname>DateField</classname>
		and <classname>IntegerField</classname>?
		</para>
        </question>
        <answer>
          <para>
		In release 1.0.8, the entire suite of components related to validating
		form input was rewritten.  A single component, &ValidField;, now does the work
		of all the others.  In the earlier version, component subclasses were needed
		to change the behavior:  converting objects to strings, strings to objects and
		validating.  This is now encapsulated in the &IValidator; interface.  In short, it is now
		much easier to create new kinds of validations and just plug them into the
		&ValidField;.
		</para>
        
          <para>This was, regrettably, a completely non-backwards compatible change.  However,
          compatible versions of three of the 1.0.7 components
          (<classname>ValidatingTextField</classname>,
		<classname>NumericField</classname> and
		<classname>DateField</classname>) are now part of the 
		<filename>net.sf.tapestry.contrib.jar</filename> library.
		</para>
		
          <para>
		In addition, the old components had big disclaimers:  "Don't use these inside
		any kind of loop (such as a &Foreach;)".  By expanding the role of the
		&IValidationDelegate;, this is no longer so, the delegate now does much more,
		including the ability to track errors for fields even inside loops.
		</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question>
          <para>Why don't my &Upload; components work?  I keep getting NullPointerExceptions.
		</para>
        </question>
        <answer>
          <para>
		The &Upload; component creates an <sgmltag class="starttag">input type="file"</sgmltag>
		HTML element.  This requires that the containing <sgmltag class="starttag">form</sgmltag> element
		use the encoding MIME type <literal>multipart/form-data</literal>.  This is accomplished by
		setting the informal parameter <property>enctype</property> of the containing &Form; component to
		 <literal>multipart/form-data</literal>.
		</para>
        </answer>
      </qandaentry>
      
      
      <qandaentry>
      	<question>
      		<para>Why isn't Tapestry a JSP taglib?</para>
      	</question>
      	<answer>
      		<para>
      		Simply put, Tapestry needs to run the whole show, from the point the request is receieved by
      		the servlet all the way through to the end of sending a response page back to the client. 
      		All the benefits of Tapestry come from
      		features that JSPs just don't provide ... knowing the full component heirarchy for the page,
      		and tracking which components are wrapped inside which others, no matter how dynamic the
      		rendering process is.  The way components can work together to generate different
      		portions of the page is both powerful and necessary -- 
      		that's how Tapestry builds the URLs for links and forms.
      		</para>
      		
      		<para>
      		By comparison, something like 
      		<ulink url="http://jakarta.apache.org/">Struts</ulink>
      		still relies on the developer to do most of the work, by defining Actions ... which are
      		little more than a dressed up version of a servlet.  Although it has some rudimentary
      		forms support (that can also be leveraged to process query parameters from ordinary links),
      		it's still an awful lot of coding.
      		</para>
      		
      	</answer>
      </qandaentry>
      
    </qandaset>
  </appendix>
</book>

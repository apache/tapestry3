<!-- $Id$ -->

  
  <chapter id="components">
    <title>Tapestry Components</title>
    <para>
Tapestry components are "black boxes" that are involved with both rendering 
HTML responses and responding to HTTP requests.
</para>
    <para>
A Tapestry component is defined by its specification.  
The specification is an XML file that defines the type of the component, it parameters, 
the template used by the component, any components embedded within it and 
how they are 'wired up', and (less often) any assets used by the component.
</para>
    <para>
At runtime, the specification is used to identify and instantiate a class 
for the component.  When the page containing the component is rendered, the 
component will access its HTML template to find the static HTML and embedded 
components it will render.
</para>
    <section id="components.params">
      <title>Parameters and Bindings</title>
      <para>
Tapestry components are designed to work with each other, 
within the context of a page and application.  The process of rendering a page 
is largely about pulling information from a source into a component  
and doing something with it.
</para>
      <para>
For example, on a welcome page, a component might get the <varname>userName</varname> property from 
the <varname>visit</varname> object and insert it into the HTML response.
</para>
      <para>
Each component has a specific set of parameters.  
Parameters have a name, a type and may be required or optional.
</para>
      <para>
To developers experienced with Java GUIs, it may appear that Tapestry 
component parameters are the same as JavaBeans properties.  This is not completely true.  
JavaBeans properties are set-and-forget; the designer sets a value 
for the property using a visual editor and the value 
is saved with the bean until it is used at runtime.
</para>
      <para>
Parameters define the type of value needed, but not the actual value.  
This value is provided by a special object called a binding.  
The binding is a bridge between the component and the parameter value,
exposing that value to the component as it is needed.  The reason for all this
is to allow pages, and the components within them, to be shared by many
concurrent sessions ... a major facet in Tapestry's strategy
for maintaining application scalability.
</para>

<para>
When a component needs the value of one of its parameters, it must
obtain the correct binding, an instance of interface &IBinding;,
and invoke methods on the binding to get the value from the binding.
Additional methods are used with output parameters to update the binding property.
</para>

<para>
In most cases, discussed in the <link linkend="components.connected-params">next section</link>,
Tapestry can hide the bindings from the developer.  In effect, it automates the process
of obtaining the binding, obtaining the value from it, and assigning it to a JavaBean
property of the component.
</para>

      <para>
There are two types of bindings:  static and dynamic.  
Static bindings are read-only; the value for the binding is 
specified in the component specification. 
</para>

      <para>
Dynamic bindings are more prevalent and useful.  A dynamic 
binding uses a JavaBeans property name to retrieve the value when needed 
by the component.  The source of this data is a property of some component.
</para>

      <para>
In fact, dynamic bindings use
<link linkend="beans.property-path">property paths</link>, allowing
a  binding to 
'crawl' deeply through an object graph to access the value it needs.  
This frees the components from relying totally on the properties of their container, 
instead they are free to access properties of more distant objects.
</para>

    </section>
    
<section id="components.connected-params">    
	<title>Connected Parameters</title>
    
<para>
In most cases, a developer is not interested in bindings; an easier model for developers is one
in which Tapestry uses the parameters and bindings to set properties of the component automatically.
Starting in release 2.1, Tapestry includes this behavior, with some constraints and limitations.
</para>

<para>
Part of the <link linkend="components.spec.parameter">specification for a parameter</link>
is the <emphasis>direction</emphasis>, which can be one of the following values:
</para>

<variablelist>

	<varlistentry>
		<term>in</term>
		<listitem>
		<para>
		Input parameter; the value is drawn from the binding (if bound)
		and applied to the corresponding component property just before rendering the component.
		</para>
		</listitem>
	</varlistentry>


	<varlistentry>
		<term>custom</term>
		<listitem>
		<para>
		Tapestry does not try to connect the parameter with any property; the component
		is responsible for accessing the binding and retrieving or setting values.
		</para>
		
		<para>
		This type must be used for any kind of output parameter, or for an input parameter
		where the property may be accessed other than during the rendering of the component.
		</para>
		</listitem>
	</varlistentry>			
</variablelist>
 
<note>
	<title>Why aren't output parameters connectable?</title>
	<para>
	The problem is the timing of output parameters.  Sometimes a parameter is only an output
	parameter when the containing form is submitted (for example, any of the form related components).
	Sometimes a parameter is output many times (for example, &Foreach;) while the component
	renders.
	</para>
	
	<para>
	The latter case may always be handled as custom; the former case may be handled
	in the future.
	</para>
</note>
 
<para>
Defining a parameter as direction <literal>in</literal> causes Tapestry to connect the parameter to the corresponding
property of the component.  The parameter specification must identify the Java type of the property.
Properties must be read/write (they must have both
getter and setter methods).
</para>

<para>
Tapestry will set properties from parameters just before rendering the component.  After the component renders, 
the parameters are
cleared; they are returned to inital values.  Tapestry reads these initial values just before it sets the
properties the first time.  This makes it very easy to set defaults for optional parameters: just provide a default value
for the correspoinding instance variable.
</para>

<para>
If the property is connected to an invariant binding (a static or field
binding), then the property is set just once, and never cleared.
</para>


<para>
There are times when the parameter name can't be used as the property name.  For example,
the &Page; component has a <literal>page</literal> parameter, the name of the page to link to.  
However, all components already have a <literal>page</literal>
property, the &IPage; that ultimately contains them.  The specification for the &Page; component
connects the <literal>page</literal> parameter to a property named <literal>targetPage</literal> instead.
</para>

<para>
Defining a connected parameter as required means that the parameter must be bound
<emphasis>and</emphasis> the binding must provide a non-null value.  A runtime exception
is thrown when a required parameter's binding yields a null value.
</para>

<para>
The following examples show how to declare and use a parameter:
</para>

<example>
	<title>Connected Parameter - Specification</title>
<programlisting><![CDATA[


<specification ...>

  <parameter name="color" direction="in" java-type="java.awt.Color"/>
  
  ...
]]>
</programlisting>
</example>

<example>
	<title>Connected Parameter - Java Code</title>
<programlisting><![CDATA[

public class ColorComponent extends AbstractComponent
{
  private Color color = Color.RED;
  
  public Color getColor()
  {
    return color;
  }
    
  public void setColor(Color color)
  {
    this.color = color;
  }
  
  protected void renderComponent(IMarkupWriter writer, IRequestCycle cycle)
  throws RequestCycleException
  {
    writer.begin("font");
    writer.attribute("color", RequestContext.encodeColor(color);
    
    renderWrapped(writer, cycle);
    
    writer.end();
  }
  
}


]]>
</programlisting>
</example>

<para>
In this example, the component writes its content inside a <sgmltag class="starttag">font</sgmltag>
element, with the HTML color attribute set from the <literal>color</literal> parameter.  &RequestContext;
includes a static convienience method for converting from a 
<classname>Color</classname> object to an encoded color
that will be meaningful to a web browser.
</para>

<para>
The parameter is optional and defaults to red if not specified (that is, if the parameter
is not bound).
</para>


<para>
At runtime, Tapestry will invoke <function>setColor()</function> first (if the <literal>color</literal>
parameter is bound).  It will then invoke <function>renderComponent()</function>.  Finally (even if
<function>renderComponent()</function> throws an exception) it will invoke <function>setColor()</function>
again, to restore it back to the default value, <literal>Color.RED</literal>.
</para>

<para>
This code includes a defect: because the parameter is optional, there is nothing to prevent
it from being bound to null.
</para>
    
</section>    
    
    <section id="components.informal-parameters">
      <title>Formal vs. Informal Parameters</title>
      <para>
Tapestry components have two types of parameters: formal and informal.
</para>
      <para>
Formal parameters are parameters defined in the 
<link linkend="components.spec.parameter">component specification</link>.  
Each formal parameter has a specific
(case sensitive) name and may be required or optional.
</para>
      <para>
In many cases, there is a one-to-one mapping between a Tapestry component and a specific
HTML tag.  For example, &Body; and <sgmltag class="starttag">body</sgmltag>,
&Form; and <sgmltag class="starttag">form</sgmltag>, etc.  In other cases, a Tapestry component
produces a known single HTML tag.  For example, &Action;, &Direct;, &Page; and &Service;
all produce an <sgmltag class="starttag">a</sgmltag> tag.
</para>
      <para>
To support truly rich interfaces, it is often necessary to specify additional attributes
of the HTML tags; usually this means setting the <varname>class</varname> of a tag so as to
get visual properties from a stylesheet.  In other cases, display attributes may be specified inline
(this is often the case with attributes related to display width and height, since
CSS support for these properties are inconsistent between the major HTML 4.0 browsers).
</para>
      <para>
In theory, these components <emphasis>could</emphasis> define additional formal parameters for
each possible HTML attribute ... but there are a huge number of possible attributes, many of
which are specific to a particular browser.
</para>
      <para>
Instead, Tapestry has the concept of an <emphasis>informal parameter</emphasis>.  
This is an "additional" parameter, not specified
in the component's specification.  In most cases, where informal parameters are allowed, they
are added as additional HTML attributes (there are a few special exceptions, such as the &Script; component).
</para>
      <para>
Informal parameters do have some limitations.  Informal parameters that conflict with the names of
any formal parameters, or with any of the HTML attributes generated directly by the component, are silently
ommitted.  The comparison is case-insensitve.  Thus, for a &Direct; component, you can not change
the <varname>href</varname> attribute, even if you supply a <varname>Href</varname> (or other variation) informal parameter.
</para>
      <para>
Not all Tapestry components even allow informal parameters; this is explicitly 
stated in the <link linkend="components.specification">component specification</link>.
</para>
      <note>
        <title>Informal Parameters that are Assets</title>
        <para>
Tapestry includes a special case when an informal parameter is actually an 
<link linkend="components.assets">asset</link>.  The URL for the asset is determined and that is the value
supplied for the attribute.
</para>
      </note>
    </section>
    <section id="components.embedded">
      <title>Embedded Components</title>
      <para>
Under Tapestry, it is common to define new components 
by combining existing components.  The existing components are 
embedded in the containing component.  This is always true at the top level; Pages, 
which are still Tapestry components, always embed other Tapestry components.
</para>
      <para>
Each embedded component has an <varname>id</varname> (an identifying string) 
that must be unique within the containing component.  
Every non-page component is embedded inside some other 
component forming a hierarchy that can get quite deep 
(in real Tapestry applications, some pages have components nested three to five levels deep).
</para>
      <para>
In some cases, a component will be referenced by its id path.  
This is a series of component ids separated by periods, representing a path from 
the page to a specific component.  The same notation as a property path 
is used, but the information being represented is quite different.
</para>
      <para>
For example, the id path <literal>border.navbar.homeLink</literal>
represents the component named <varname>homeLink</varname>, 
embedded inside a component named <varname>navbar</varname>, 
embedded inside a component named <varname>border</varname>, embedded inside some page.
</para>
      <para>
Tapestry components are "black boxes".  They have a set of parameters that may 
be bound, but their internals, how they are implemented, are not revealed.
</para>
      <para>
Primitive components may not embed other components, or even 
have a template.  Nearly all the built-in components are primitive; they are 
building blocks for constructing more complex components.
</para>
      <para>
Alternately, a component may be implemented using a template and embedded components.  
In either case, the names, types or very existence of embedded components is private, 
hidden inside the containing component's "black box".
</para>
    </section>
    
    
    <section id="components.html-template">
      <title>HTML Templates</title>
      
      <para>Nearly all Tapestry components combine static HTML
	<footnote>
          <para>
			The current releases of Tapestry is specifically oriented around HTML.  Some support for
			non-HTML languages, such as XML, XHTML or WML is already present
			and will be expanded in the future.
		</para>
        </footnote>
from a template with additional dynamic content 
(some few components are just dynamic content).  
Often, a Tapestry component embeds other Tapestry components.  
These inner components are referenced in the containing component's template.
</para>

<para>
One of the features of Tapestry is <emphasis>invisible instrumentation</emphasis>.  In most
web application frameworks, converting a static HTML page into a usable template is a destructive process:
the addition of new tags, directives or even Java code to the template means that it will no
longer preview properly in a <acronym>WYSIWYG</acronym> editor.
</para>

<para>
Tapestry templates are instrumented using a new HTML attribute, <varname>jwcid</varname>, to any existing
element.  Elements with such attributes are recognized by Tapestry as being dynamic, and driven by
a Tapestry component, but a <acronym>WYSIWYG</acronym> editor will simply ignore them.  Once a template
is instrumented, it may be worked on by 
<link linkend="components.html-production">both the  HTML producer and the Java developer</link>.
</para>

<section id="components.html-template.jwcid-attribute">
	<title>Using the <varname>jwcid</varname> attribute</title>

      <para>
Identifying a Tapestry component is accomplished by adding a <varname>jwcid</varname> attribute to a tag.
</para>
      <informalexample>
        <programlisting>
&lt;<replaceable>any</replaceable> jwcid="<replaceable>component id</replaceable>" ... &gt;  <replaceable>body</replaceable>  &lt;/<replaceable>any</replaceable>&gt;
</programlisting>

      <para>or
</para>

        <programlisting>
&lt;<replaceable>any</replaceable> jwcid="<replaceable>component id</replaceable>" ... /&gt;
</programlisting>
      </informalexample>
      <para>
Most often, the HTML element chosen is <sgmltag class="starttag">span</sgmltag>, though (in fact) Tapestry
completely ignores the element chosen by the developer, except to make sure the open and close tags balance.
</para>
      <para>
The parser used by Tapestry is relatively forgiving about case 
and white space.  Also, the component id (and any other attributes) can be enclosed in 
double quotes (as above), single quotes, or be left unquoted.
</para>
      <para>
You are free to specify additional
attributes.  These attributes will become
<link linkend="components.informal-parameters">informal parameters</link> for the Tapestry component.
</para>

      <para>
The start and end tags for Tapestry components must balance properly. This includes cases where the
end tag is normally ommitted, such as <sgmltag class="starttag">input</sgmltag> elements.  Either a closing
tag must be supplied, or the XML-style syntax for an empty element must be used (that is, 
a slash just before the end of the tag).
</para>

</section> <!-- components.html-template.jwcid-attribute -->

<section id="component.html-template.jwc-element">
	<title>Using the <sgmltag class="starttag">jwc</sgmltag> element</title>
	
      <para>
An alternative to using the <varname>jwcid</varname> attribute is to use
the &jwc-tag; element.  In fact, until Tapestry release 1.0.2, this was the only
way to use templates.
</para>

<para>
The &jwc-tag; element has two forms:
</para>

      <informalexample>
        <programlisting>
&lt;jwc id="<replaceable>component id</replaceable>"&gt;  <replaceable>body</replaceable>  &lt;/jwc&gt;
</programlisting>

      <para>or
</para>

        <programlisting>
&lt;jwc id="<replaceable>component id</replaceable>"/&gt;
</programlisting>
      </informalexample>
      
      <para>
When using the &jwc-tag; tag, you may only specify the <varname>id</varname> attribute.  You may
not specify any additional informal parameters, as you can when using the standard
notation.
</para>

</section> <!-- component.html-template.jwc-element -->

<section id="component.html-template.localization">
	<title>Localizing sections of a template</title>
	
<para>
Tapestry includes an additional template feature to assist with localization of a web application.
By specifying a <sgmltag class="starttag">span</sgmltag> element with a special attribute,
<varname>key</varname>, Tapestry will replace the entire 	
<sgmltag class="starttag">span</sgmltag> tag with a
<link linkend="components.localization.strings">localized string</link> for the component.
</para>


<para>
This construct takes one of two forms:
</para>

<informalexample>
<programlisting>
&lt;span key="<replaceable>key</replaceable>" ... &gt; ... &lt;/span&gt;
</programlisting>
<para>or</para>
<programlisting>
&lt;span key="<replaceable>key</replaceable>" ... /&gt;
</programlisting>
</informalexample>

<para>
If only the <varname>key</varname>
attribute is specified, then the <sgmltag class="starttag">span</sgmltag>
is simply replaced with the localized string.  However, if any additional attributes
are specified for the <sgmltag class="starttag">span</sgmltag> tag beyond
<varname>key</varname>, then
the <sgmltag class="starttag">span</sgmltag> tag will be part of the rendered HTML, with
the specified attributes.
</para>

<para>
The upshot of this is that sections of the HTML template can be invisibly localized
simply by wrapping the text to be replaced inside a <sgmltag class="starttag">span</sgmltag>
tag.  The wrapped text exists, once more, as sample text to be displayed
in a <acronym>WYSIWYG</acronym> editor.
</para>

</section> <!-- component.html-template.localization -->

<section id="component.html-template.body">
	<title>Components with Bodies</title>

<para>
In Tapestry, individual components may have their own HTML templates.   This is a very powerful
concept ... it allows powerful and useful components to be created with very little code.  During the rendering
of a page, Tapestry knits together the templates of the page and all the nested components to create
the HTML response sent back to the client web browser.
</para>


<informalexample>
<programlisting>
Container content <co id="component.html-template.body.container1"/>

&lt;span jwcid="component"&gt; <co id="component.html-template.body.component"/>

  Wrapped content <co id="component.html-template.body.wrapped"/>
  
&lt;/span&gt;

More container content <co id="component.html-template.body.container2"/>
</programlisting>
</informalexample>

<calloutlist>
	<callout arearefs="component.html-template.body.container1">
	<para>
	This portion of the container content is rendered first.
	</para>
	</callout>
	
	<callout arearefs="component.html-template.body.component">
	<para>
	The component is then rendered.  It will render, possibly using its
	own template.
	</para>
	</callout>
	
	<callout arearefs="component.html-template.body.wrapped">
	<para>
	The component controls <emphasis>if</emphasis>, <emphasis>when</emphasis> and
	<emphasis>how often</emphasis> wrapped content from its container
	is rendered.
	</para>
	
	<para>
	Wrapped content can be a mix of static HTML and additional components.
	</para>
	</callout>
	
	<callout arearefs="component.html-template.body.container2">
	<para>
	After the component finishes rendering, the remaining content
	from the container is rendered.
	</para>
	</callout>
</calloutlist>



      <para>
The body listed above can be either static HTML or other Tapestry 
components or both.  Elements in the body of a component are 
wrapped by the containing component.  The containing component controls the 
rendering of the elements it wraps in its body.  For example, 
the &Conditional; component may decide not to 
render its body and the &Foreach; component may render 
its body multiple times.
</para>
      <para>
Not all Tapestry components should have a body.  
For example, the &TextField; component creates an
<sgmltag class="starttag">input type=text</sgmltag>
form element and it makes no sense for it to contain anything else.  
Whether a component can have a body (and wrap other elements) is defined in the 
<link linkend="components.specification.root">component's specification</link>.
</para>
      <para>
Tapestry includes a special component, &InsertWrapped;, 
which is used to render wrapped content from a component's container.  
It makes it easy to create components that wrap other components.
</para>

</section> <!-- component.html-template.body -->

 
    </section> <!-- components.html-template -->
    
    <section id="components.html-production">
      <title>Tapestry and HTML Production</title>
      <para>
Tapestry is design to work in a large-scale environment, that typically features
two seperate teams: a "creative" team that produces HTML and a 
"technical" team that produces Tapestry pages, components and Java code.
</para>
      <para>
The division of skills is such that the creative team has virtually no knowledge of Java and
a minimal understanding of Tapestry, and the technical team has a limited understanding of HTML 
(and tend to be color blind).
</para>
      <para>
The typical workflow is that the technical team implements the application, using very minimal HTML 
... that is, minimal attention to layout, font size, colors, etc.  Just enough to be sure that
the functionality of the application is there.
</para>
      <para>
Meanwhile, the creative team is producing HTML pages of what the finished application will look like.  
These pages are like snapshots of the HTML produced by the running application.
</para>
      <para>
        <emphasis>Integration</emphasis> is the process of merging these two views of the application together.
Primarily, this involves marking up the HTML page with 
<link linkend="components.html-template.jwcid-attribute"><varname>jwcid</varname> attributes</link>, 
to indicate
to Tapestry which portions of the page are dynamic.  In this way, the 
page can be used as a Tapestry HTML template.  These changes are designed to be invisible to a
<acronym>WYSIWYG</acronym> HTML editor.
</para>

      <para>
Tapestry includes a number of additional features to allow the HTML producers to continue
working on HTML templates, <emphasis>even after</emphasis> their initial efforts have been
integrated with the Java developer's code.
</para>
      <section>
        <title>Implicitly removed bodies</title>
        <para>
In many cases, a component doesn't allow a body, but one may be present in the HTML template.
As usual, this is declared in
the <link linkend="components.specification.root">component's specification</link>.
Tapestry considers that body to be a sample value, that exists to allow the HTML producer
to verify the layout of the page.  Tapestry edits out the body.
</para>
        <para>For example, an HTML producer may create an HTML template that includes a table
cell to display the user's name.  The producer includes a sample value so that the
cell isn't empty (when previewing the HTML layout).
</para>
        <informalexample>
          <programlisting>
&lt;td&gt;&lt;span jwcid="insertName"&gt;John Doe&lt;/span&gt;&lt;/td&gt;
</programlisting>
        </informalexample>
        <para>
The &Insert; component doesn't allow a body, so Tapestry edits out the 
content of the <sgmltag class="starttag">span</sgmltag> tag from the HTML template.  The fact that
a <sgmltag class="starttag">span</sgmltag> was used to represent the &Insert; component in the
HTML template is irrelevant to Tapestry; any tag could have been used, Tapestry just
cares that the start and end tags balance.
</para>
        <para>
At runtime, Tapestry will combine the HTML template and the &Insert; component to produce the
final HTML:
</para>
        <informalexample>
          <programlisting>
&lt;td&gt;Frank N. Furter&lt;/td&gt;
</programlisting>
        </informalexample>
        <para>
This editting out isn't limited to simple text; any HTML inside the body is removed.  However,
none of that content may be dynamic ... the presence of a &jwc-tag; tag or a
<varname>jwcid</varname> attribute will cause a parsing exception.
</para>
      </section>
      <section>
        <title>Explicitly removed bodies</title>
        <para>
Another feature related to production and integration is the ability to remove sections of the HTML template.
Producers often include some optional portions on the page.  The canonical example of this is a page that 
shows a table of results; the HTML producer will usually include extra rows to demonstrate the look and layout of
a fully populated page.
</para>
        <para>
The first row will be wrapped by a &Foreach; and otherwise changed to include dynamic links and output, but what about
the other rows?
</para>
        <para>
To handle this case,
Tapestry recognizes a special <varname>jwcid</varname> attribute value: <literal>$remove$</literal>.  
Using this special id causes
Tapestry to edit out the tag and all of its contents.  Thus, each additional <sgmltag class="starttag">tr</sgmltag> in the
table should specify the value <literal>$remove$</literal> for attribute <varname>jwcid</varname>.
</para>
        <informalexample>
          <programlisting><![CDATA[
<table>
  <tr jwcid="foreach">
    <td><span jwcid="insertUserName">John Doe</span></td>
    <td><span jwcid="insertAge">42</span></td>
  </tr>
  <tr jwcid="$remove$">
  	<td>Frank N. Furter</td>
  	<td>47</td>
  </tr>
  <tr jwcid="$remove$">
    <td>Bob Doyle</td>
    <td>24</td>
  </tr>
</table>]]></programlisting>
        </informalexample>
      </section>
      <section>
        <title>Limiting template content
	</title>
        <para>
In a typical Tapestry application, some form of Border component provides a significant portion of every page.
This typically includes the outermost <sgmltag class="starttag">html</sgmltag>, <sgmltag class="starttag">head</sgmltag> and <sgmltag class="starttag">body</sgmltag>
tags, as well as <sgmltag class="starttag">table</sgmltag>s used to control layout.
</para>
        <para>
In the static HTML pages from the creative team, this is not directly visible ... they <emphasis>must</emphasis>
include all the content
normally generated by the Border component in order to see what the HTML page actually looks like.
</para>
        <para>
By default, the <emphasis>entire</emphasis> HTML template is the content for the page.  
This causes a problem, even after a <sgmltag class="starttag">span</sgmltag>
is added, to represent the Border component ... much of the HTML is duplicated, 
once from the static HTML, then dynamically from the Border component.
</para>
        <para>
To eliminate this problem, Tapestry has a second special <varname>jwcid</varname> attribute: <literal>$content$</literal>.
Using this special id causes Tapestry to limit its view of the HTML template to just the content inside the tag.  Anything outside
the defined content is completely ignored.
</para>
      </section>
      <section>
        <title>Limits</title>
        <para>
Ideally, the HTML pages created by the HTML producers would be used as is
as the HTML templates.  Changes made for integration, the adding of <varname>jwcid</varname> attributes and such,
would be copied back into the HTML pages.
</para>
        <para>
Given the use of the <literal>$remove$</literal> and <literal>$content$</literal>
          <varname>jwcid</varname>'s, 
this is practical
to a point.  Once the application starts using a number of re-usable components, there
isn't a good way to perform the integration short of cutting and replacing
some of the HTML page content to form the HTML template.
</para>
      </section>
    </section>
    <section id="components.localization">
      <title>Localization</title>
      <para>
Tapestry has built in support for localization, designed to be easy to use. This localization support
is defined in terms of transforming the user interface into a format appropriate the the locale
of the user.  This primarily takes the form of localized text (translated into the
end-user's language), but can also affect other aspects of look and feel including colors, images and layout.
</para>

<para>
Tapestry has two different methods for supporting localization; developers are free to
mix and match solutions according to their own preferences.
</para>

      <para>Each client connecting to the application will select a particular <classname>Locale</classname>. 
When a page for the application is created, the locale is used to select the correct localized
resources.  
Locales are defined by the ISO (International Standards Organization).  
A locale consists of a language code (such as 'en' for English, 'de' for German or 'fr' for French) 
and a country code (such as 'AU' for Australia, 'BE' for Belguim, or  'GB' for United Kingdom).
</para>


<para>
A client's initial locale is determined by analyzing HTTP headers provided with the initial request.
An application may override this default, which records a client-side cookie identifyng the desired locale.
An example of this is included in the Tapestry Workbench demonstration.
</para>

<section id="components.localization.strings">
	<title>Localization with Strings</title>
	
<para>
Each individual component may have a set of <emphasis>localized strings</emphasis>.
Remember that pages are just a specific kind of component.
This set is built, much like the properties of a &ResourceBundle;, from one
or more <literal>.properties</literal> files.  These files are located on the classpath, in the same
directory as the component specification (the <literal>.jwc</literal> file).
</para>

<para>
The search for strings is much the same as with &ResourceBundle;, except
that only <literal>.properties</literal> files are considered (&ResourceBundle; also looks for classes).
</para>

<para>
Example: for a component <filename>/com/skunkworx/skunkapp/Border.jwc</filename> and a locale of
<literal>fr_BE</literal> would be:
</para>

  <itemizedlist>
    <listitem>
      <para>
        <filename>/com/skunkworx/skunkapp/Border_fr_BE.properties</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        <filename>/com/skunkworx/skunkapp/Border_fr.properties</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        <filename>/com/skunkworx/skunkapp/Border.properties</filename>
      </para>
    </listitem>
  </itemizedlist>


<para>
Searching for individual keys works just as with &ResourceBundle;, the search starts in the most
specific file (<literal>Border_fr_BE.properties</literal>) and continues downward if not found.
</para>
	
	
<para>
Components can gain access to their container's localized strings
via the <link linkend="components.spec.bindings">&lt;string-binding&gt;</link>
element in the <link linkend="components.specification">component specification</link>.
</para>

</section>

<section id="components.localization.templates">
	<title>Localization with Templates</title>
 
<para>
Tapestry allows multiple versions of HTML templates and assets (described in a 
<link linkend="components.assets">later section</link>) 
to be deployed with the application.
</para>

      <para>
The base template name is derived from the specification name, 
by changing the <literal>jwc</literal> extension to <literal>html</literal>.  
For example, component <filename>/com/skunkworx/skunkapp/Border.jwc</filename>
will have a base template name of  <filename>/com/skunkworx/skunkapp/Border.html</filename>.
This resource name is used as the basis of a search that includes the locale.  
Various suffixes are inserted just before the '.html' extension.
</para>

      <para>
A French speaking Belgian visitor would provoke the following search:
</para>

      <itemizedlist>
        <listitem>
          <para>
            <filename>/com/skunkworx/skunkapp/Border_fr_BE.html</filename>
          </para>
        </listitem>
        <listitem>
          <para>
            <filename>/com/skunkworx/skunkapp/Border_fr.html</filename>
          </para>
        </listitem>
        <listitem>
          <para>
            <filename>/com/skunkworx/skunkapp/Border.html</filename>
          </para>
        </listitem>
      </itemizedlist>
   

<note>
	<para>
	This form of localization actually predates the alternate form,
	using <link linkend="components.localization.strings">localized strings</link>.
	Localizing the strings seperately from the rest of the HTML template
	is generally a better and easier way.  Localization of templates
	will, in the future, be used primarily when changing the layout of the template ...
	for example, to provide a right-to-left orientation in a Hebrew
	localization.
	</para>
</note>

</section>

</section> <!-- components.localization -->

    <section id="components.assets">
      <title>Assets</title>
      <para>
Assets are images (GIF, JPEG, etc.), movies, sounds or other collateral associated 
with a web application.  Assets come in three flavors:  external, context and private.
</para>
      <para>
External assets live at an arbitrary URL.  Context assets use a URL within the 
servlet context hosting the Tapestry application; 
these assets are deployed 
within the same Web Application Archive (WAR) as the application.
</para>
      <para>
Private assets come from the Java classpath and are 
resources not normally visible to the web server.
</para>
      <para>
Tapestry uses the assets concept to address two areas:  localization and deployment.
</para>
      <para>
For localization:  internal and private assets are localized, 
just like HTML templates.  That is, the path name provided is 
used as the basis for a search that takes into account the desired locale.  
External assets can't be localized in this way.
</para>
      <para>
Private assets allow for easy deployment because the assets are 
packaged with the HTML templates and Java code of the application, 
inside a Java Archive (JAR) file.
</para>
      <para>
Private assets support re-usability; a re-usable component may be 
packaged with supporting assets (typically, image files) and used in any 
Tapestry application without change, and without having to locate, extract or 
otherwise fiddle with those assets.
</para>
      <para>
The Tapestry framework provides two ways of exposing the assets to the client web browser.
</para>
      <para>
First, it provides a service that will access the asset dynamically.  
The URL encodes the application servlet and the resource to download, 
and Tapestry framework code will pump the bytes down to the client web browser.  
This is the default behavior (and is most useful during development).
</para>
      <para>
The second method involves copying the asset out to a directory visible 
to the web server, and creating a URL for it in its final location.  
This requires some extra configuration of the application.  
This method also has some implications when deploying new versions of the web application.  
These are addressed later in this document.
</para>
    </section>
    <section id="components.helper-beans">
      <title>Helper Beans</title>
      <para>
There is a second form of aggregation allowed with Tapestry components.  The first way, covered previously, is to use embedded
components to extend the functionality of the outer component.  In some cases, useful behavior can be isolated, 
not into an additional component, but into a simple JavaBean.
</para>
      <para>
These additional beans, called helper beans, are defined in the component specification, in the
<link linkend="components.spec.bean"><sgmltag class="starttag">bean</sgmltag></link> element.
Each bean has a unique name, a class to instantiate,
and a lifecycle (which controls how long the component keeps a reference to the bean).  The specification 
allows properties of the bean to be set as well, using
the 
<link linkend="components.spec.set-property"><sgmltag class="starttag">set-property</sgmltag></link> element.  
Helper beans are accessed through the <varname>beans</varname> property of the component.
</para>
      <para>
Beans are created as needed, they may then be cached for future use according to their declared lifecycle.
The default lifecycle is <varname>request</varname>, meaning that the same bean will be returned until the end of the current request cycle.
</para>
      <para>
An alternate lifecycle, <varname>page</varname>, means that once the bean is instantiated, it will continue to be available
for the lifetime of the page containing it.  Remember that helper beans should never contain any client-specific
state, since a page will be used by multiple sessions and clients.
</para>
      <para>
The last available lifecycle, <varname>none</varname>, indicates that the bean is not cached at all, and will be created fresh on
each property access.
</para>

      <para>
Tapestry includes a handful of useful helper beans.  &Default; is used to provide default values for optional parameters.
&ValidationDelegate; 
and several implementions of &IValidator;
used with &ValidField;, it allows simple handling of validation and presentating validation errors.
&EvenOdd; is used by the <link linkend="inspector">Tapestry Inspector</link>; it generates a stream of values alternating between "even" and "odd"; this is combined with cascading stylesheets to make the rows alternate between white and grey backgrounds.
</para>
    </section>
    <section id="components.specification">
      <title>Component Specification</title>
      <para>
The component specification is an XML document.  
This discussion assumes a passing familiarity with XML documents.   
The specification is located inside the running Java VMs classpath; 
in a deployed application, it will be a package resource, 
located (along with the Java class files) in the 
<filename class="directory">WEB-INF/classes</filename> 
directory of the WAR (Web Application Archive).
</para>
      <para>
These specifications can be somewhat verbose, 
it is strongly advised that a DTD-aware XML editor be used, 
rather than hand editting the files.
</para>

<para>
This description is for the current revision of the component specification, 1.3.
Tapestry still supports component specification 1.1 and 1.2 as well, though support
for the original 1.0 DTD has been removed.  See &SpecificationParser; for more
details.
</para>


      <section id="components.specification.root">
        <title>
          <sgmltag class="starttag">specification</sgmltag> element</title>
        <para>
Component specification files, which use the filename extension <literal>.jwc</literal>, consist of a
<sgmltag class="starttag">specification</sgmltag> element.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">component-specification</sgmltag> element</title>
          <programlisting><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE specification PUBLIC 
  "-//Howard Lewis Ship//Tapestry Specification 1.3//EN"
  "http://tapestry.sf.net/dtd/Tapestry_1_3.dtd">
]]>

&lt;component-specification 
  allow-body="<replaceable>yes|no</replaceable>" <co id="components.spec.co.allow-body"/>
  allow-informal-parameters="<replaceable>yes|no</replaceable>" <co id="components.spec.co.informal"/>
  class="<replaceable>java-type</replaceable>"&gt; <co id="components.spec.co.java-type"/>
  
  [ &lt;<link linkend="components.spec.description">description</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.parameter">parameter</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.reserved-parameter">reserved-parameter</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.property">property</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.bean">bean</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.component">component</link> ...&gt; ...]
  [ &lt;<link linkend="components.spec.assets"><replaceable>asset</replaceable></link> ...&gt; ...]
&lt;/specification&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="components.spec.co.allow-body">
              <para>
  	Whether the component is allowed to have a body, that is, wrap around other components
  	and static HTML.  The default is 'yes', so this attribute is usually ommitted.
  	</para>
            </callout>
            <callout arearefs="components.spec.co.informal">
              <para>
  	Whether informal parameters are allowed.  Informal parameters are additional parameters
  	beyond the ones formally defined.  These are typically used with components that map
  	directly to an HTML element, to allow additional HTML attributes to be specified.
  	The default is 'yes', so this attribute is usually ommitted.
  	</para>
            </callout>
            <callout arearefs="components.spec.co.java-type">
              <para>
	The complete class name of the component class, 
	for example, <classname>com.skunkworx.skunkapp.Border</classname>.
	</para>
            </callout>
          </calloutlist>
        </para>

        <para>
As previously described, the specification name is used to find the base 
HTML template name (by replacing the '.jwc' extension with '.html').  
</para>
        <para>
During development, such resources may be in the developer's work areas, 
but when the application is deployed, they will almost always be distributed inside a 
Java Archive (JAR) file or Web Application Archive (WAR) file.  
This is one of the ways that Tapestry eases deployment.
</para>
        <para>
The <sgmltag class="starttag">component-specification</sgmltag> element wraps around all other elements in
the specification (which are used to define parameters, embedded components and assets).  The following
sections describe these additional elements.
</para>
      </section>
      <section id="components.spec.description">
        <title>
          <sgmltag class="starttag">description</sgmltag> element</title>
        <para>
One or more <sgmltag class="starttag">description</sgmltag> 
elements may be included in the specification.  These are descriptions of 
the component's features and behavior, suitable for inclusion in some form of IDE
Multiple descriptions are used to support
multiple languages.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">description</sgmltag> element</title>
          <programlisting>
&lt;description 
  xml:lang="<replaceable>language code</replaceable>"&gt; <co id="component.specification.description.lang"/>
  ... <replaceable>text</replaceable> ... 
&lt;/description&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="component.specification.description.lang">
              <para>
	The language in which the descriptive text is written. This takes the form
	of a two letter code, defined by the ISO-639 standard.
	</para>
            </callout>
          </calloutlist>
        </para>
        <note>
          <title>
            <sgmltag class="starttag">description</sgmltag> usage</title>
          <para>
	The <sgmltag class="starttag">description</sgmltag> element is really used for future expansion, towards
	a time when an  integrated HTML / Tapestry Specification editor does exist.  
	Also, a Javadoc doclet may be created that can read
	Tapestry specifications and include them with Javadoc.  In the meantime, descriptions can be used
	like XML comments.
	</para>
        </note>
      </section>
      <section id="components.spec.parameter">
        <title>
          <sgmltag class="starttag">parameter</sgmltag> element</title>
        <para>
This element is used to describe formal parameters used by a component.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">parameter</sgmltag> element</title>
          <programlisting>
&lt;parameter
  name="<replaceable>name</replaceable>" <co id="components.spec.parameter.name"/>
  property-name="<replaceable>property-name</replaceable>" <co id="components.spec.parameter.property-name"/>
  direction="<replaceable>in|custom</replaceable>" <co id="components.spec.parameter.direction"/>
  java-type="<replaceable>type</replaceable>" <co id="components.spec.parameter.java-type"/>
  required="<replaceable>yes</replaceable>|<replaceable>no</replaceable>"&gt; <co id="components.spec.parameter.required"/>
  [ &lt;<link linkend="components.spec.description">description</link> ... &gt; ...] <co id="components.spec.parameter.description"/>
&lt;/parameter&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="components.spec.parameter.name">
              <para>
		Each parameter must have a unique name.  
		Parameter names must start with a letter and may contain letters, numbers 
		and the underscore.
		</para>
            </callout>
            
            
            <callout arearefs="components.spec.parameter.property-name">
            <para>
            Specifies the name of the JavaBean property of the component
            to connect the parameter to.  By default, the property name
            matches the parameter name, but this allows overrides for
            when the property name can't be used as is.
            </para>
            
            <para>
            See <link linkend="components.params">Parameters and Bindings</link>
            for full details about connecting parameters
            to properties.
            </para>
            </callout>
            
            <callout arearefs="components.spec.parameter.direction">
            <para>
            Used by the framework to connect parameters to JavaBean properties of the component.
            The default, if not specified, is <literal>custom</literal> meaning that
            the framework does not connect the parameter to any property.
            </para>
            
            <para>
            Specifying a value of <literal>in</literal> will cause Tapestry to set the
            property to the value specified by the parameter just before rendering the component,
            and reset the parameter (to its default value) just after rendering.
            </para>
            
            </callout>
            
            <callout arearefs="components.spec.parameter.java-type">
              <para>
		Identifies the Java class or scalar Java type of the property.  This is only
		required when connecting a parameter to a property; this value specifies the
		exact type of the property.
		
		</para>
              <para>
		The <varname>java-type</varname> attribute is optional for non-connected parameters.
		</para>
            </callout>
            <callout arearefs="components.spec.parameter.required">
              <para>
		If 'yes', then the parameter must be bound when the page is loaded.  The default, 'no',
		allows a parameter to not be bound.
		</para>
              <para>
		Individual components may do a second check, that the bound parameter provides a non-null value.
		</para>
		
		<para>
		For connected parameters, Tapestry automatically checks that the parameter is not only bound,
		but that the binding yields a non-null value for the parameter.
		</para>
		
            </callout>
            <callout arearefs="components.spec.parameter.description">
              <para>
		Each parameter is allowed to have its own set of localized descriptions.
		</para>
            </callout>
          </calloutlist>
        </para>
      </section>
      <section id="components.spec.reserved-parameter">
        <title>
          <sgmltag class="starttag">reserved-parameter</sgmltag> element</title>
        <para>
			The <sgmltag class="starttag">reserved-parameter</sgmltag> element is used
			to identify parameter names that may not be
			used as <link linkend="components.informal-parameters">informal parameters</link>.  Informal parameters
			may not match the name of any formal parameter, or any reserved parameter names
			(comparisons ignore case).
			</para>
        <para>
			The point of this is to allow components to declare HTML attributes generated by the
			component to be "off limits" to informal parameters.  For example, the &TextField; component
			declares that the <varname>input</varname> and <varname>name</varname> parameters
			are reserved, since those are generated by the component and should not be overriden
			in any way.
			</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">reserved-parameter</sgmltag> element</title>
          <programlisting>
&lt;reserved-parameter name="<replaceable>name</replaceable>"/&gt;
			</programlisting>
        </figure>
      </section>
      <section id="components.spec.property">
        <title>
          <sgmltag class="starttag">property</sgmltag> element</title>
        <para>
Allows arbitrary name / value pairs to be associated with the container
(a component or application).  These properties, which should not be confused
with JavaBeans properties, are used to store meta-information about other
specification objects.  This is primarily of use to visual editors or RAD (Rapid Application Development)
tools.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">property</sgmltag> element</title>
          <programlisting>
&lt;property name="<replaceable>name</replaceable>"&gt;
  [ <replaceable>value</replaceable> ]
&lt;/property&gt;
</programlisting>
        </figure>
      </section>
      <section id="components.spec.bean">
        <title>
          <sgmltag class="starttag">bean</sgmltag> element</title>
        <para>
The <sgmltag class="starttag">bean</sgmltag> element
is used to identify <link linkend="components.helper-beans">helper beans</link>
for the component.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">bean</sgmltag> element</title>
          <programlisting>
&lt;bean name="<replaceable>name</replaceable>"
  class="<replaceable>class</replaceable>"
  lifecycle="<replaceable>none|request|page|render</replaceable>"&gt;
  
  [ &lt;<link linkend="components.spec.description">description</link> ... &gt; ... ]
  [ &lt;<link linkend="components.spec.property">property</link> ... &gt; ... ]
  [ &lt;<link linkend="components.spec.set-property">set-property</link> ... &gt; ... ]

&lt;/bean&gt;
</programlisting>
        </figure>
        <para>
The name is the name of the bean, which must be unique for beans within the component.  The bean will be accessible
using the property path <varname>beans.<replaceable>name</replaceable>
          </varname>.  Beans are instantiated
as needed, they may be cached for later use.  The <replaceable>class</replaceable> is the complete Java class name
to instanatiate.
</para>
        <para>
The default lifecycle is <varname>request</varname>, if not specified.
</para>
        <para>
Any number of
<link linkend="components.spec.set-property"><sgmltag class="starttag">set-property</sgmltag></link>
elements may be specified, to intialize the properties of the bean.
</para>
      </section>
      <section id="components.spec.set-property">
        <title>
          <sgmltag class="starttag">set-property</sgmltag> element</title>
        <para>
This element is used to set a property of a helper bean, and
appears only inside the <link linkend="components.spec.bean">
            <sgmltag class="starttag">bean</sgmltag> element</link>.  Properties are
set just after the bean is instantiated.  For poolable beans, properties
are set just after the bean is retrieved from the pool.
</para>
        <para>
Values for properties are specified using the <sgmltag class="starttag">static-value</sgmltag>
and <sgmltag class="starttag">property-value</sgmltag> element.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">set-property</sgmltag> element</title>
          <programlisting>
&lt;set-property name="<replaceable>name</replaceable>"&gt;
  [ &lt;<link linkend="components.spec.field-value">field-value</link> ... &gt; 
    | &lt;<link linkend="components.spec.static-value">static-value</link> ... &gt; 
    | &lt;<link linkend="components.spec.property-value">property-value</link> ... &gt; 
    | &lt;<link linkend="components.spec.string-value">string-value</link> ... &gt; ]
&lt;/set-property&gt;
</programlisting>
        </figure>
        <para>
The name attribute identifies the property to be changed.  The value is provided
by wrapped element.
</para>
      </section>
      <section id="components.spec.field-value">
        <title>
          <sgmltag class="starttag">field-value</sgmltag> element</title>
        <para>
 This element, which appears only within a
<link linkend="components.spec.set-property"><sgmltag class="starttag">set-property</sgmltag></link> element
provides a static value with which to set the property obtained from a public static
variable of some class.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">field-value</sgmltag> element</title>
          <programlisting>
&lt;field-value field-name="<replaceable>field-name</replaceable>"/&gt;
</programlisting>
        </figure>
        <para>
The field name specifies the complete class name (including package name) and the name of a field within the class.  
As a convienience, the package name may be ommitted if the class is in the
<property>java.lang</property>
package.

       </para>
      </section>
      <section id="components.spec.static-value">
        <title>
          <sgmltag class="starttag">static-value</sgmltag> element</title>
        <para>
This element, which appears only within a
<link linkend="components.spec.set-property"><sgmltag class="starttag">set-property</sgmltag></link>
element provides a static value with which to set the property.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">static-value</sgmltag> element</title>
          <programlisting>
&lt;static-value type="<replaceable>boolean|int|long|double|String</replaceable>"&gt;
  [ <replaceable>value</replaceable> ]
&lt;/static-value&gt;
</programlisting>
        </figure>
        <para>
The value is the simple text content inside the element.  It is converted from a string representation
to one of the available types (more types will be added in the future).  The default
is <varname>String</varname>, in which case the value is used as is, after leading and trailing
whitespace is removed.
</para>
      </section>
      <section id="components.spec.property-value">
        <title>
          <sgmltag class="starttag">property-value</sgmltag> element</title>
        <para>
This element appears inside a
<link linkend="components.spec.set-property"><sgmltag class="starttag">set-property</sgmltag></link>
element
to set a property of the bean from a dynamic property of the containing 
component.  The component property, which may be a property path, is evaulated
when the bean is instantiated.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">property-value</sgmltag> element</title>
          <programlisting>
&lt;property-value property-path="<replaceable>property path</replaceable>"/&gt;
</programlisting>
        </figure>
      </section>
      <section id="components.spec.string-value">
      	<title>
      		<sgmltag class="starttag">string-value</sgmltag> element</title>
      		
      	<para>
This element appears inside a
<link linkend="components.spec.set-property"><sgmltag class="starttag">set-property</sgmltag></link>
           element, and sets a property of a bean
          from a localized string provided by the component.
      </para>
      
        <figure>
          <title>Component specification: <sgmltag class="starttag">string-value</sgmltag> element</title>
          <programlisting>
&lt;string-value key="<replaceable>key</replaceable>"/&gt;
</programlisting>
        </figure>      		
      		
      </section>
      
      <section id="components.spec.component">
        <title>
          <sgmltag class="starttag">component</sgmltag> element</title>
        <para>
The <sgmltag class="starttag">component</sgmltag> element is used to describe an embedded component, a
component identified in the containing component's HTML template.
</para>
        <figure>
          <title>Component specification: <sgmltag class="starttag">component</sgmltag> element</title>
          <programlisting>
&lt;component
  id="<replaceable>id</replaceable>" <co id="component.spec.component.id"/>
  type="<replaceable>type</replaceable>" <co id="component.spec.component.type"/>
  copy-of="<replaceable>id</replaceable>"&gt; <co id="component.spec.component.copy-of"/>
  [ &lt;<link linkend="components.spec.property">property</link> ... &gt; ] ...
  [ &lt;binding|field-binding|inherited-binding|static-binding|string-binding ...&gt; ... ]
&lt;/component&gt;
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="component.spec.component.id">
              <para>
  	Each component must have a unique identifier within its container.  The <varname>id</varname>
  	attribute must conform to an XML id:  start with a letter, and contain only letters, numbers
  	and underscores.
  	</para>
            </callout>
            <callout arearefs="component.spec.component.type">
              <para>
  	The component type is either the the complete path to a component specification, or a well known alias.
  	All the components provided with the framework have well known aliases, at it is possible
  	to create additional aliases in the Tapestry application specification.  A type may also have a
  	prefix identifying the library in which it is defined.
  	</para>
            </callout>
            <callout arearefs="component.spec.component.copy-of">
              <para>
	Instead of specifying a type, a component may be a copy of one of its siblings.  In this case,
	the new component is created by copying the type and bindings of the existing component.  It is possible
	to specify additional bindings as well.
	</para>
              <para>
	The component being copied from must be declared first.
	</para>
            </callout>
          </calloutlist>
        </para>
        <para>
  	You must specify either the <varname>type</varname> or <varname>copy-of</varname> attributes, but not both.
  	</para>
        <para>
Each component must also have a type.  Types are resource paths for a component 
specification.  Specifications end with '.jwc'.  An example would be 
<filename>/com/skunkworx/skunkapp/Border.jwc</filename>.
</para>
        <para>
Unlike HTML templates, specifications are never localized.
</para>
        <para>
As a convenience, aliases may be defined for components.  
An alias is a short name that takes the place of the specification resource path.  
All built-in components for Tapestry have aliases, and an 
application specification may define additional aliases.
</para>
        <para>
For example, the component 
<filename>/net/sf/tapestry/links/Action.jwc</filename>
has a standard alias of &Action;.
</para>
      </section>
      <section id="components.spec.bindings">
        <title>Binding elements</title>
        <para>
There are four different types of bindings.  The standard binding is most common, as it binds a parameter
to a property of an object, and may be read, write or read/write.
</para>
        <figure>
          <title>Component specification: binding elements</title>
          <programlisting>
&lt;binding
  name="<replaceable>name</replaceable>" <co id="components.spec.binding.name"/>
  property-path="<replaceable>property-path</replaceable>"/&gt; <co id="components.spec.binding.path"/>
  
&lt;field-binding
  name="<replaceable>name</replaceable>"
  field-name="<replaceable>field-name</replaceable>"/&gt; <co id="components.spec.binding.field-name"/>
  
&lt;inherited-binding
  name="<replaceable>name</replaceable>"
  parameter-name="<replaceable>parameter-name</replaceable>"/&gt; <co id="components.spec.binding.parameter-name"/>
  
&lt;static-binding
  name="<replaceable>name</replaceable>"&gt;
  	... <replaceable>value</replaceable> ... <co id="components.spec.binding.static-value"/>
&lt;/static-binding&gt;

&lt;string-binding
  name="<replaceable>name</replaceable>"
  key="<replaceable>key</replaceable>"/&gt;  <co id="components.spec.binding.string-binding-key"/>
</programlisting>
        </figure>
        <para>
          <calloutlist>
            <callout arearefs="components.spec.binding.name">
              <para>
		A name of the parameter to bind.  This usually matches the name of
		a formal parameter of the component.  For components which
		allow informal parameters, this may be any value.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.path">
              <para>
		The name of a property reachable from the containing component.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.field-name">
              <para>
		The name of a public static field.  This takes the form
		<replaceable>class name</replaceable>.<replaceable>field name</replaceable>.  The class name is the complete
		class name (including the package names), unless the package is <varname>java.lang</varname>, in which
		case the package portion can be ommitted.
		</para>
              <para>
		Field bindings are often more useful than static bindings, because the value does't have to
		be a convertable from a string.  This means true objects, not just holders of single values,
		can be used, this is quite useful when dealing with the form element components.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.parameter-name">
              <para>
		The name of a formal or informal parameter of the containing component.  The contained component
		will share the same binding.  This is one of the ways in which it is possible to build complex
		components by combining simple ones.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.static-value">
              <para>
		Unlike the other binding types, the <sgmltag class="starttag">static-binding</sgmltag> element
		wraps around its static value, which allows for maximum flexibility.  It does, however,
		remove all leading and trailing whitespace from the value.
		</para>
            </callout>
            <callout arearefs="components.spec.binding.string-binding-key">
            <para>
            Specifies a key in the containing component's
            <link linkend="components.localization.strings">localized strings</link>.
            </para>
            </callout>
          </calloutlist>
        </para>
        <para>
An example of using an
<sgmltag class="starttag">inherited-binding</sgmltag> is the <classname>Border</classname> component, 
which has a <varname>title</varname> parameter that gives the name of the page.  
The <classname>Border</classname> component embeds an &Insert; component, 
and uses an inherited binding to set the 
&Insert; component's <varname>value</varname> parameter to the 
containing <classname>Border</classname> component's <varname>title</varname> parameter.
</para>
      </section>
      <section id="components.spec.assets">
        <title>Asset elements</title>
        <para>
Assets are a way of identifying resources whose URLs will appear in a web page.  
Most often, the assets are image files used with an &Image; or 
&Rollover; components.
</para>
        <figure>
          <title>Component specification: Asset elements</title>
          <programlisting>
&lt;context-asset
	name="<replaceable>name</replaceable>"
	path="<replaceable>path</replaceable>"/&gt;
	
&lt;external-asset
	name="<replaceable>name</replaceable>"
	URL="<replaceable>URL</replaceable>"/&gt;
	
&lt;private-asset
	name="<replaceable>name</replaceable>"
	resource-path="<replaceable>resource-path</replaceable>"/&gt;
</programlisting>
        </figure>
        <para>
Assets may be stored at some arbitrary URL, may be within the same web application context as the 
Tapestry application, or may be stored as a resource inside Java VM classpath.
</para>
        <para>
In all three cases, the name must be very simple:  
start with a letter and contain only letters, numbers and underscores or dashes.  
Assets names must be unique within the component.
</para>
        <para>
For external assets, the URL must be complete:  it will be inserted into the HTML unchanged.
</para>
        <para>
For context assets
the path must be relative to the servlet context.  
Context assets may be localized; this will be reflected in the 
actual file chosen and in the URL inserted into the HTML.  
The final URL inserted into the HTML will include the servlet context prefix and may reflect 
a localized path.
</para>
        <para>
For private assets, the resource path must be a resource path within the 
Java VM classpath, as with a specification or HTML template resource path.  
This means the asset can be stored in the 
<filename class="directory">WEB-INF/classes</filename> directory of the application's WAR, 
or inside some JAR in the classpath.  Like context assets, private assets may be localized.
</para>
      </section>
    </section>
  </chapter>
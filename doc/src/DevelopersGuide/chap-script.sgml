<!-- $Id$ -->

<chapter id="script">
	<title>Tapestry and JavaScript</title>
	
<para>
Building cutting edge Web applications is not entirely about the server side.
A significant amount of work must be done on the client side to support truly dynamic
user experiences.  Typically, this scripting is done using the JavaScript language embedded
into major web browsers such as Internet Explorer and Netscape Navigator.
</>

<para>
These effects range from simple effects such as image rollovers (changing 
the icon used for a link whent he cursor is over it) to more involved
patterns such as client side validation of forms or even complex animations.
</>

<para>
In traditional, static web page development, the author is completely responsible
for this aspect of development, usually aided by a web page authoring tool, such as
Dreamweaver.  Ultimately, though, the web page developer assigning unique names or ids to
various elements on the page, and attaches JavaScript event handlers to 
the elements.

<example>
	<title>Traditional JavaScript usage</title>
	<programlisting><![CDATA[

var preload = new Array();
preload[0] = new Image();
preload[0].src = "/images/button.gif";
preload[1] = new Image();
preload[1].src "/images/button-highlight.gif";

function rollover(image, index)
{
  image.src = preload[index].src;
}

.
.
.
  <a href="..."
    onMouseOver="javascript:rollover(document.button, 1);"
    onMouseOut="javascript:rollover(document.button, 0);">
    <img name="button" src="/images/button.gif">
  </a>

]]></programlisting></example>

<para>
The preloading business is all about forcing the browser to load the image <emphasis>before</>
it is needed, so that it is already in memory when the mouseover event handler
needs it.
</>

<para>
From here, adding additional rollovers means extending the <varname>preload</> array, providing
names for the additional <sgmltag class=starttag>img</> elements and writing the additional
event handlers for the <sgmltag class=starttag>a</> elements.
</>

<para>
Now, envision a running Tapestry application.  With everything so dynamic (especially when you add things like the
&Foreach; component), it's all but impossible to even know how many links and buttons will be on the page, never what they'll
all be named.  At first glance, it may appear that Tapestry prevents the use of this kind of scripting.
</>

<para>
In fact, Tapestry is structured to enhance this kind of scripting.  This is faciliated by the &Body; component, which replaces
the <sgmltag class=starttag>body</> element of the page.  Virtually all of a page's content will be wrapped by the &Body; component,
including everything that has need for dynamic scripting.
</>

	<section id="script.body">
		<title>The Body component</title>
	
<para>
The &Body; component provides a number of services to the components it wraps.  It handles preloading of
images.  It provides the ability to add aribrary JavaScript to the page, or to the
<sgmltag class=starttag>body</> element's onload event handler.  Finally, it provides an easy way 
to generate unique identifiers needed for things like image names.
</>

<para>
When rendering is complete, the &Body; component will have produced three distinct portions of the
HTML response:

<informalexample>
<programlisting>
&lt;script language="JavaScript"&gt;&lt;!-- <co id="script.body.script">

...

function onload_body()  <co id="script.body.onload">
{
}

// --&gt; &lt;/script&gt;
&lt;body onload="javascript:onload_body();"&gt; <co id="script.body.tag">

... <co id="script.body.wrapped">

&lt;/body&gt;

</programlisting>
</informalexample>

<para>
<calloutlist>
  <callout arearefs="script.body.script">
  <para>
  This script block is only emitted when necessary; that is, because some component
  needed to generate scripting or initialization (or preloaded images).  The block
  is properly "commented" so that older browsers, that don't support scripting,
  will not be confused by the JavaScript code.
  </>
  </>
  
  <callout arearefs="script.body.onload">
  <para>
  The onload event handler function is only generated if some component needs some
  onload initialization.
  </>
  </>
  
  <callout arearefs="script.body.tag">
  <para>
  The <sgmltag class=starttag>body</> tag only specfies a <varname>onload</>
  event handler function if one is needed.
  </>
  </>
  
  <callout arearefs="script.body.wrapped">
  <para>
  The content of the <sgmltag class=starttag>body</> element is defined by the
  Tapestry components it wraps.  Importantly, the rollovers, JavaScript, event handlers and
  the content are all generated in parallel (the &Body; component uses buffering so that
  the JavaScript portion is written out first).
  </>
  </>
</calloutlist>
</para>

	</section>
	
	<section id="script.script">
		<title>Script documents</>
		
<para>
Scripting in Tapestry requires some extra thought; in the examples above, the web developer
specifically new the URLs of the images to preload and the name of the 
<sgmltag class=starttag>img</> element to be affected.  For Tapestry, those things are not
known ahead of time; scripting is a matter of plugging in variable content to a template.
</>

<para>
Tapestry supports scripting with the Tapestry Script document, another XML document type.  A Tapestry
script takes as input a number of <emphasis>symbols</> and uses them to construct 
the desired JavaScript event handlers, and to provide initializations for them.
</>
  
	<section>
		<title><sgmltag class=starttag>script</> element
		
<para>
Script documents, which use the filename extension <literal>.script</>, consist
of a <sgmltag class=starttag>script</> element.
</>

<figure>
	<title>Script document: <sgmltag class=starttag>script</> element
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script PUBLIC 
  "-//Howard Ship//Tapestry Script 1.1//EN"
  "http://tapestry.sf.net/dtd/Script_1_1.dtd">
]]>

&lt;script&gt;

  [ &lt;let ...&gt; ...] <co id="script.dtd.script.let">
  [ &lt;body&gt; ] <co id="script.dtd.script.body">
  [ &lt;initialization&gt; ] <co id="script.dtd.script.initialization">
  
&lt;/script&gt;
</programlisting>
</figure>

<para>
<calloutlist>
  <callout arearefs="script.dtd.script.let">
  <para>
  The <sgmltag class=starttag>script</> may contain any number of 
  <sgmltag class=starttag>let</> elements, used to define new symbols.
  </>
  </>
  <callout arearefs="script.dtd.script.initialization">
  <para>
  The <sgmltag class=starttag>body</> element contains
  JavaScript event handling logic.  This is optional, and may appear
  only once.
  </>
  </>
  <callout arearefs="script.dtd.script.initialization">
  <para>
  The <sgmltag class="starttag">initialization</> element
  contains JavaScript statements added to the HTML
  <sgmltag class="starttag">body</> element's 
  <function>onLoad</> event handler.
  </>
  </>
</calloutlist>
</para>

	</section>
	
	<section>
		<title><sgmltag class=starttag>let</> element

<figure>
	<title>Script document: <sgmltag class=starttag>let</> element
<programlisting>
&lt;let key="<replaceable>symbol-name</>"&gt; <co id="script.dtd.let.key">
  [
     [ <replaceable>text</> ] <co id="script.dtd.let.text">
     [ &lt;insert ...&gt; ] 
     [ &lt;if ...&gt; ] 
     [ &lt;if-not ...&gt; ] 
     [ &lt;foreach ...&gt; ] 
  ... ] <co id="script.dtd.let.full-content">
&lt;/let&gt;

</programlisting>
</figure>
  
<para>
<calloutlist>
 <callout arearefs="script.dtd.let.key">
 <para>
 The new symbol to define.  This should be a new name, though no check is made.  The
 symbol gets the result of evaluating the body of the
 <sgmltag class=starttag>let</> element, though leading and trailing whitespace
 is removed.
 </>
 </>
 <callout arearefs="script.dtd.let.text">
 <para>
 The <sgmltag class=starttag>let</> element
 consists of static text intermixed with the other elements (which produce
 dynamic text).
 </>
 </>
 <callout arearefs="script.dtd.let.full-content">
 <para>
 The allowed content of the <sgmltag class=starttag>let</> element is called
 <emphasis>full content</>.  Most of the other elements defined by the document type
 also use full content.  <sgmltag class=starttag>let</> elements generally don't have
 a need for other than text and the <sgmltag class=starttag>insert</> element.
 </>
 </>
  </calloutlist>
  </para>

<para>
This element is used to define new symbols.  The most common use of this is to define the
name of a function, usually by combining some unique name of id with other text.  This new
symbol is then used in the <sgmltag class=starttag>body</> element to define the function, and
in the <sgmltag class=starttag>initialization</> element to establish the function as the
handler for some HTML element's event.
</>
  
<para>
The <sgmltag class=starttag>let</> elements are evaluated in order.  Often, some building
blocks are estabilished first, to which are added suffixes and prefixes to form the final
names of functions.
</>

  	</section>
  	
  	
  	<section>
  		<title><sgmltag class=starttag>insert</> element

<figure>
	<title>Script document: <sgmltag class=starttag>insert</> element
<programlisting>
&lt;insert property-path="<replaceable>property-path</>"/&gt;
</programlisting>
</figure>

<para>
The <sgmltag class=starttag>insert</> element is used to insert the value of a property.
Simple names are just the names of symbols passed to the script, or the names can be
a full property path (operating like a <sgmltag class=starttag>binding</> element
in a component specification).
	</section>
	
  	<section>
  		<title><sgmltag class=starttag>if</> element

<figure>
	<title>Script document: <sgmltag class=starttag>if</> element
<programlisting>
&lt;if property-path="<replaceable>property-path</>"&gt;
  [ <replaceable>full content</> ]
&lt;/if&gt;
</programlisting>
</figure>

<para>
The <sgmltag class=starttag>if</> element provides some conditional content.  It evaluates
its property and, if true (generally, non-null, non-empty or non-zero, depending on the type),
it includes its content.  The content is full content, meaning just about anything can be
contained (including <sgmltag class=starttag>if</>, <sgmltag class=starttag>foreach</>, etc.).
</>

	</section>
	
  	<section>
  		<title><sgmltag class=starttag>if-not</> element

<figure>
	<title>Script document: <sgmltag class=starttag>if-not</> element
<programlisting>
&lt;if-not property-path="<replaceable>property-path</>"&gt;
  [ <replaceable>full content</> ]
&lt;/if&gt;
</programlisting>
</figure>

<para>
The <sgmltag class=starttag>if-not</> element is the same as the
<sgmltag class=starttag>if</> element, but it inverts the meaning of the
property, including its content if the property is false.
</>
	</section>


  	<section>
  		<title><sgmltag class=starttag>foreach</> element

<figure>
	<title>Script document: <sgmltag class=starttag>foreach</> element
<programlisting>
&lt;foreach key="<replaceable>key</>"
  property-path="<replaceable>property-path</>"&gt;
  [ <replaceable>full content</> ]
&lt;/foreach&gt;
</programlisting>
</figure>

<para>
The <sgmltag class=starttag>foreach</> element is an analog of the &Foreach; component;
it iterates through a list of objects.  On each iteration, it sets the named symbol
(via the <property>key</> attribute) and inserts its body.
</>

	</section>
		
  	<section>
  		<title><sgmltag class=starttag>body</> element

<figure>
	<title>Script document: <sgmltag class=starttag>body</> element
<programlisting>
&lt;body&gt;
  [ <replaceable>full content</> ]
&lt;/body&gt;
</programlisting>
</figure>

<para>
The <sgmltag class=starttag>body</> element evaluates its content and the result is added to the
script block preceding the HTML <sgmltag class=starttag>body</> element in the response HTML.
</>

	</section>
	
  	<section>
  		<title><sgmltag class=starttag>initialization</> element

<figure>
	<title>Script document: <sgmltag class=starttag>initialization</> element
<programlisting>
&lt;initialization&gt;
  [ <replaceable>full content</> ]
&lt;/initialization&gt;
</programlisting>
</figure>

<para>
The <sgmltag class=starttag>initialization</> element evaluates its content and the result is 
added to the 
HTML <sgmltag class=starttag>body</> element's 
<property>onLoad</> event handler function.
</>

	</section>
	
	</section>
	
<section id="script.script-component">
	<title>Script component
	
	
<para>
The &Script; component is one of the more common ways to add scripting to a Tapestry page.
</>

<para>
The component has a single required parameter, <property>script</> that is the path to
a Script document within the classpath.  The optional <property>symbols</> property
allows a &Map; to be specified as the base set of symbols, to which are added any informal
parameters.
</>

<para>
A handful of scripts are included with the framework.  The following script
is used by the Tapestry Inspector to force a &Form; to submit when a &PropertySelection;
changes value.
</>

<figure>
	<title>SelectSubmit.script</>
<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE script PUBLIC 
  "-//Howard Ship//Tapestry Script 1.1//EN"
  "http://tapestry.sf.net/dtd/Script_1_1.dtd"&gt;
&lt;!--

Adds a handler that forces the form containing a particular select element
to submit when the select changes its value.

Input symbols:
  component: The PropertySelection component the script is to be attached to.
--&gt;
&lt;script&gt;
&lt;let key="formName"&gt; <co id="script.ex.formName">
  &lt;insert property-path="component.form.name"/&gt;
&lt;/let&gt;
&lt;let key="selectName"&gt;
  &lt;insert property-path="component.name"/&gt;
&lt;/let&gt;
&lt;let key="formPath"&gt; <co id="script.ex.formPath">
  document.&lt;insert property-path="formName"/&gt;
&lt;/let&gt;
&lt;let key="selectPath"&gt;
  &lt;insert property-path="formPath"/&gt;.&lt;insert property-path="selectName"/&gt;
&lt;/let&gt;
&lt;let key="functionName"&gt; <co id="script.ex.functionName">
  onChange_&lt;insert property-path="formName"/&gt;_&lt;insert property-path="selectName"/&gt;
&lt;/let&gt;

&lt;body&gt;

function &lt;insert property-path="functionName"/&gt;()
{
  &lt;insert property-path="formPath"/&gt;.submit();
}

&lt;/body&gt;

&lt;initialization&gt;
&lt;insert property-path="selectPath"/&gt;.onchange = &lt;insert property-path="functionName"/&gt;;
&lt;/initialization&gt;
&lt;/script&gt;
</programlisting>
</figure>

<para>
<calloutlist>
	<callout arearefs="script.ex.formName">
	<para>
	The property path makes it easy to find the &Form; containing the &PropertySelection;
	component.  Part of the necessity for this script is that form and form element names
	are assigned by Tapestry.
	</>
	</>
	<callout arearefs="script.ex.formPath">
	<para>
	Here, the <emphasis>path</> refers to how to identify the HTML element in the
	browser's DOM.
	</>
	</>
	<callout arearefs="script.ex.functionName">
	<para>
	The function name is used twice; to define the function and to setup the event handler.
	Note how the name incorporates the unique form name and element name, this ensures
	that any number of &PropertySelection; components, inside any number of &Form;s can
	use this script without concern for naming conflicts.
	</>
	</>
</calloutlist>	

<para>
Using the script simply involves declaring it in the component specification and configuring
its input parameters.  It must also be in the HTML template, before the closing
<sgmltag class=endtag>jwc</> tag of the &Form; component.
</>

<figure>
	<title>SubmitScript usage</>
	
<programlisting>
&lt;component id="submitScript" type="Script"&gt;
  &lt;static-binding name="script"&gt;/com/primix/tapestry/form/SelectSubmit.script&lt;/static-binding&gt;
  &lt;binding name="component" property-path="components.selectPage"/&gt;
&lt;/component&gt;
</programlisting>
</figure>

</section>

</chapter>

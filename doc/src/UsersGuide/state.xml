<!-- $Id$ -->

<chapter id="state">
	<title>Managing Server-Side State</title>
	
<para>
Server-side state is any information that exists on the server, and persists between request cycles.
This can be anything from a single flag all the way up to a large database result set.  In a typical
application, server-side state is the identity of the user (once the user logs in) and, perhaps,
a few important domain objects (or, at the very least, primary keys for those objects).
</para>

<para>
In a typical servlet application, managing server-side state is 
entirely the application's responsibility.  The Servlet API provides just the &HttpSession;, which
acts like a &Map;, relating keys to arbitrary objects.  It is the application's responsibility
to obtain values from the session, and to update values into the session when they change.
</para>

<para>
Tapestry takes a different tack; it defines server-side state in terms of the Engine,
the Visit and persistent page properties.
</para>

<para>
The Engine is important because, ultimately, it is the lone object stored into the &HttpSession;.  Because it
is persistent, the Visit and all page properties are also persistent.
</para>

<section id="state.visit">
	<title>Visit Object</title>
	
<para>
The Visit object is an application-defined object that may be obtained from the engine (via the
<varname>visit</varname> property of the &IEngine; or &IPage;).  By convention, the class is usually named <classname>Visit</classname>, but it can be
any class whatsoever, even &Map;.
</para>

<para>
The following example demonstrates how a listener method
may access the visit object.
</para>

<example>
	<title>Accessing the Visit object</title>
<programlisting>
public void formSubmit(&IRequestCycle; cycle)
{
    Visit visit = (Visit)getPage().getVisit();
    
    visit.<emphasis>doSomething()</emphasis>;   
}
</programlisting>
</example>

<para>
The Visit object is instantiated lazily, the first time it is needed.  Method
<function>createVisit()</function> of &AbstractEngine; is responsible for this.
</para>

<para>
In most cases, the Visit is an ordinary JavaBean, and therefore, has a no-arguments
constructor.  In this case, the complete class name of the
Visit is specified as 
<link linkend="configuration.search-path">configuration property</link>
<literal>net.sf.tapestry.visit-class</literal>.
</para>

<para>
Typically, the Visit class is defined in the application specification.
</para>

<example>
	<title>Defining the Visit class</title>
<programlisting>
<![CDATA[
<application name="Tapestry Component Workbench">
  <property name="net.sf.tapestry.visit-class" value="tutorial.workbench.Visit"/>

  ...
]]>
</programlisting>
</example>

<para>
In cases where the Visit object does not have a no-arguments contructor, or
has other special initialization requirements, the method
<function>createVisit()</function> of &AbstractEngine; can be overridden.
</para>

<para>
There is a crucial difference between accessing the visit via the 
<varname>visit</varname> property of &IPage; and the
<varname>visit</varname> property of &IEngine;.  In the former case, accessing the visit
via the page, the visit <emphasis>will</emphasis> be created if it does not already exist.
</para>

<para>
Accessing the visit via the &IEngine; is different, the visit will <emphasis>not</emphasis>
be created if it does not already exist.
</para>

<para>
Carefully crafted applications will take heed of this difference and try to avoid
creating the visit unnecessarilly.  It is not just the creation of this one object that is
to be avoided ... creating the visit will likely force the entire application
to go stateful (create an &HttpSession;), and applications are more efficient
while <link linkend="state.stateless">stateless</link>.
</para>

</section> <!-- state.visit -->

<section id="state.page-properties">
	<title>Persistent Page Properties</title>
	
<para>
Servlets, and by extension, JavaServer Pages, are inherently stateless.  That is, they will be used
simultaneously by many threads and clients.  Because of this, they must not store (in instance variables)
any properties or values that are specified to any single client.
</para>

<para>
This creates a frustration for developers, because ordinary programming techniques must be avoided.
Instead, client-specific state and data must be stored in the &HttpSession; or as &HttpServletRequest; attributes.
This is an awkward and limiting way to handle both <emphasis>transient</emphasis> state (state that is only needed
during the actual processing of the request) and
<emphasis>persistent</emphasis> state (state that should be available during the processing of this
and subsequent requests).
</para>

<para>
Tapestry bypasses most of these issues by <emphasis>not</emphasis> sharing objects between threads and clients.
For the duration of a request, a page and all components within the page are reserved to the single request.
There is no chance of conflicts because only the single thread processing the request will have access
to the page.  At the end of the request cycle, the page is returned to a pristine state and returned to the shared pool,
ready for reuse by the same client, or by a different client.
</para>

<para>
In fact, even in a high-volume Tapestry application, there will rarely be more than a few instances of any
particular page in the page pool.
</para>

<para>
For this scheme to work it is important that at the end of the request cycle, the page must return
to its pristine state.  The prisitine state is equivalent to a freshly created instance of the page.  In other words, any
properties of the page that changed during the processing of the request must be returned to thier initial values.
</para>

<note>
<para>
The following sections describe a scheme used through Tapestry release 2.3.  In release 2.4
<link linkend="state.declarative-properties">declarative properties</link> are used instead, since
they are much easier.
</para>
</note>

<para>
The best way to do this is to implement the method <function>initialize()</function> on your page.  This method is invoked
once when the page is first created; it is invoked again at the end of each request cycle.  An empty implementation
of this method is provided by &AbstractPage;.
</para>



<example>
	<title>Use of <function>initialize()</function> method</title>
<programlisting>
public class MyPage extends &BasePage;
{
    private String _message;
    
    public String getMessage()
    {
        return _message;
    }
    
    public void setMessage(String message)
    {
        _message = message;
    }
    
    protected void initialize()
    {
        _message = null;
    }
}
</programlisting>
</example>


<para>
If your page has additional attributes, they should also be reset inside
the <function>initialize()</function> method.
</para>

<para>
Now that we've shown how Tapestry allows pages to have <emphasis>transient</emphasis> state, we'll
show how to handle <emphasis>persistent</emphasis> state.
</para>	

<para>
Tapestry separates the persistent state of a page from any instance.  This is very important, because
from one request cycle to another, a different instance of the page may be used ... even when clustering is
not used.  Again, Tapestry has many copies of any page in a pool, and pulls one instance out of the pool
for each request.
</para>

<para>
In Tapestry, a page may have many properties
and may have many components, each with many properties but only a tiny number of all those
properties needs to persist between request cycles.
On a later request, the same or different page instance may be used.  With a little
assistance from the developer, 
the Tapestry framework can create the illusion that the same page instance is being used in
a later request.
</para>

<para>
For a property to be persistent, all that's necessary is that the accessor method notify
the framework of changes.  Tapestry will record the changes (using an &IPageRecorder;)
and, in later request cycles, will restore the property
using using the recorded value and whichever page instance is taken out of the page pool.
</para>

<para>
This notification takes the form of an invocation of the method
<function>fireObservedChange()</function>.  This method is provided by &AbstractComponent;
and is overloaded for all the scalar types, and for &Object;.
</para>

<example>
<title>Persistent Page Property</title>
<programlisting>
public class MyPage extends &BasePage;
{
    private int _itemsPerPage;
    
    public int getItemsPerPage()
    {
        return _itemsPerPage;
    }
    
    public void setItemsPerPage(int itemsPerPage)
    {
        _itemsPerPage = itemsPerPage;
        
        fireObservedChange("itemsPerPage", itemsPerPage);
    }
    
    protected void initialize()
    {
        _itemsPerPage = 10;
    }
}
</programlisting>
</example>

<para>
This sets up a property, <varname>itemsPerPage</varname> with a default value of 10.  If
the value is changed (perhaps by a form or a listener method),
the changed value will "stick" with the user who changed it, for the duration of their
session.
</para>
	
</section> <!-- state.page-properties -->

<section id="state.component-properties">
	<title>Persistent Component Properties</title>
	
<para>
Transient and persistent properties are not limited just to pages.  The can be implemented
by components as well, though this takes slightly more work.  The <function>fireObservedChange()</function>
method is available to components as well as pages, but the initialization is slightly more complicated.
</para>

<para>
Components do not have the equivalent of the <function>initialize()</function> method.  Instead,
they must register for an event notification to tell them when the page is being <emphasis>detached</emphasis>
from the engine (prior to be stored back into the page pool).  This event is generated by the page itself.
</para>

<para>
The Java interface &PageDetachListener; is the event listener interface for this purpose.  
By simply implementing this interface
, Tapestry will register the component as a listener and ensure that
it receives event notifications at the right time (this works for the two other
page event interfaces, &PageRenderListener; and &PageCleanupListener; as well; simply
implement the interface and leave the rest to the framework).
</para>

<para>
Tapestry provides a method, <function>finishLoad()</function>, for just this purpose: late initialization.
</para>

<example>
	<title>Persistent Component Properties</title>
<programlisting>
public class MyComponent extends &BaseComponent; implements &PageDetachListener;
{
    private String _myProperty;
    
    public void setMyProperty(String myProperty)
    {
        _myProperty = myProperty;
        
        fireObservedChange("myProperty", myProperty);
    }
    
    public String getMyProperty()
    {
        return _myProperty;
    }
    
    protected void initialize()
    {
        _myProperty = "<emphasis>a default value</emphasis>";
    }
    
    protected void finishLoad()
    {
        initialize();
    }
    
    /**
     *  The method specified by &PageDetachListener;
     *
     **/
    
    public void pageDetached(PageEvent event)
    {
        initialize();
    }
}
</programlisting>
</example>
	
</section> <!-- state.component-properties -->

<section id="state.declarative-properties">
	<title>Declarative Properties</title>
	
<para>
If all those extra methods are at all intimidating, don't fear, Tapestry provides another approach
to dealing with transient and persistent properties in pages and components: 
<emphasis>declarative properties</emphasis>.
</para>

<para>
Declarative properties make use of a &spec.property-specification; element in the
page or component specification.  Tapestry does something special when a component
contains any such elements; it dynamically generates a subclass that provides the desired fields,
methods and whatever extra initialization or cleanup is required.
</para>

<para>
You may also, optionally, make your class abstract, and define abstract accessor methods that will
be filled in by Tapestry in the generated subclass.  This allows you to read and update properties inside
your class, inside listener methods.
</para>

<para>
Properties defined this way may be either transient or persistent.
</para>

<para>
The previous example, of a persistent page property, can be reworked as the following:
</para>
	
<example>
<title>Declarative Persistent Page Property: Java Class</title>
<programlisting>
public abstract class MyPage extends &BasePage;
{
    abstract public int getItemsPerPage();
	
    abstract public void setItemsPerPage(int itemsPerPage);
}
</programlisting>
</example>	

<example>
<title>Declarative Persistent Page Property: Page Specification</title>
<programlisting>
<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE page-specification PUBLIC 
	"-//Howard Lewis Ship//Tapestry Specification 1.4//EN" 
	"http://tapestry.sf.net/dtd/Tapestry_1_4.dtd">
	
<page-specification class="MyPage">

  <property-specification name="itemsPerPage" persistent="yes" type="int" initial-value="10"/>

</page-specification>
]]>
</programlisting>
</example>	

<para>
Again, making the class abstract, and defining abstract accessors is <emphasis>optional</emphasis>.
It is only useful when a listener method will need to update the property.
</para>

<para>
This exact same technique can be used with components as well as pages, which vastly simplifies
the coding necessary, since it is not longer necessary to directly use
the &PageDetachListener; interface.
</para>

<para>
A last note about initialization.  After Tapestry invokes the <function>finishLoad()</function>
method, it processes the initial value provided in the specification.  If 
the <literal>initial-value</literal> attribute is ommitted or blank, no change takes place.
Tapestry then takes a snapshot of the property value, which is retains 
and uses it at the end of each request cycle
to reset the property back to its "pristine" state.
</para>

<para>
This means that you may perform initialization for the property inside
<function>finishLoad()</function> (instead of providing a <literal>initial-value</literal>).  However,
don't attempt to update the property from <function>initialize()</function> ... the order of operations
when the page detaches is not defined and is subject to change.
</para>


</section>  <!-- state.declarative-persistent-properties  -->


<section id="state.stateless">
	<title>Stateless Applications</title>
	
<para>
In a Tapestry application, the framework acts as a buffer between the application code and
the Servlet API ... in particular, it manages how data is stored into the &HttpSession;.
In fact, the framework controls <emphasis>when</emphasis> the session is first created.
</para>

<para>
This is important and powerful, because an application that runs, even just initially, without
a session consumes less resources that a stateful application.  This is even more important
in a clustered environment with multiple servers; any data stored into the &HttpSession; will
have to be replicated to other servers in the cluster, which can be expensive in terms of resources.  Using
less resources means better throughput and more concurrent clients, always a good thing
in a web application.
</para>

<para>
Tapestry defers creation of the &HttpSession; until one of two things happens:  When
the visit is created, or when the first persistent page property is recorded.  At this point,
Tapestry will create the &HttpSession; and store the engine into it.
</para>

<para>
Earlier, we said that the &IEngine; instance is stored in the &HttpSession;, but this is not always the case.
Tapestry maintains a pool of &IEngine; instances that are used for stateless requests.  An instance
is checked out of the pool and used to process a single request, then checked back into the pool for
reuse in a later request, by the same or different client.
</para>


<para>
For the most part, your application will be unaware of when it is stateful or stateless; statefulness
just happens on its own.  Ideally, at least the first, or "Home" page, should be stateless (it should be
organized in such a way that the visit is not created, and no persistent state is stored).  This will help
speed the initial display of the application, since no processing time will be used in creating the session.
</para>	
	
</section> <!-- state.stateless -->

</chapter>
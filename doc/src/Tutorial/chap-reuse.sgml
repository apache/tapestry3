<chapter id="reuse">
	<title>Creating Reusable Components</>
    
<para>
In this tutorial, we'll show how to create a reusable component.  One common use of components 
it to create a common "border" for the application that includes basic navigation.  We'll be 
creating a simple, three page application with a navigation bar down the left side.
</>


<figure>
	<title>Border Home Page</>
	<mediaobject>
		<imageobject>
			<imagedata fileref="images/border-home.jpg" format="jpg">
		</imageobject>
	</>
</figure>

<para> 
Navigating to another page results in a similar display:
</>

<figure>
	<title>Border Credo Page</>
	<mediaobject>
		<imageobject>
			<imagedata fileref="images/border-credo.jpg" format="jpg">
		</imageobject>
	</>
</figure>


<para> 
Each page's content is confined to the silver area in the center.  Note that the border adapts itself 
to each page:  the title "Home" or "Credo" is specific to the page, and the current page doesn't 
have an active link (in the above page, "Credo" is the current page, so only "Home" and "Legal" 
are usable as navigation links).
</>

<para>
The "i" in the circle is the Show Inspector link.  It will be described in the next chapter.
</>

<para>
Because this tutorial is somewhat large, we'll only be showing excerpts from some of the files.  
The complete source of the tutorial examples is available seperately, in the 
<classname>tutorial.border</> package.
</>

<para>
Each of the three pages has a similar HTML template:
</>

<figure>
	<title>Home.html</>
<programlisting><![CDATA[<jwc id="border">

Nothing much doing here on the <b>home</b> page.  Visit one of our other 
fine 
pages.

</jwc>]]></programlisting></figure>

<para> 
Remember that Tapestry components can wrap around other HTML elements or components.  
For the border, we have an HTML template where everything on the page is wrapped by the 
<varname>border</> component.
</>


<para>
Note that we don't specify any
<sgmltag class=starttag>html</> or 
<sgmltag class=starttag>body</> tags; those are provided by the <classname>Border</>
component (as well as the matching close tags).
</>


<para>
This illustrates a key concept within Tapestry:  embedding vs. wrapping.  The 
<classname>Home</> page embeds 
the <varname>border</> component (as we'll see in the <classname>Home</> page's specification).  
This means that the <classname>Home</>
page is implemented using the <varname>border</> component.
</>

<para>
However, the <varname>border</> component wraps the content of the <classname>Home</> page,
the <classname>Home</> page 
HTML template indicates the <emphasis>order</> in which components (and static HTML elements) are  
renderred.  On the <classname>Home</> page, the <varname>border</> component 'bats' first and cleanup.
</>

<para>
The construction of the <classname>Border</> component is driven by how it differs from page to page.  
You'll 
see that on each page, the title (in the upper left corner) changes.  The names of all three pages are 
displayed, but only two of the three will have links (the third, the current page, is just text).  
Lastly,  each page contains the specific content from its own HTML template.

<figure>
	<title>Border.html</>
<programlisting>
&lt;jwc id="shell"&gt; <co id="reuse.border.shell">
&lt;jwc id="body"&gt; <co id="reuse.border.body">
&lt;table border=0 bgcolor=gray cellspacing=0 cellpadding=4&gt;
  &lt;tr valign=top&gt;
    &lt;td colspan=3 align=left&gt;
      &lt;font size=5 color="White"&gt;&lt;jwc id="insertPageTitle"/&gt;&lt;/font&gt; 
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=top&gt;
    &lt;td align=right&gt;
      &lt;font color=white&gt;
&lt;jwc id="e"&gt; <co id="reuse.border.e">
        &lt;br&gt;&lt;jwc id="link"&gt;&lt;jwc id="insertName"/&gt;&lt;/jwc&gt; <co id="reuse.border.insertName">
&lt;/jwc&gt;
      &lt;/font&gt;
    &lt;/td&gt;
    &lt;td rowspan=2 valign=top bgcolor=silver&gt;
      &lt;jwc id="wrapped"/&gt; <co id="reuse.border.wrapped">
    &lt;/td&gt;
    &lt;td rowspan=2 width=4&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
	&lt;td&gt;&lt;jwc id="showInspector"/&gt;&lt;/td&gt; <co id="reuse.border.showInspector">
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td colspan=3 height=4&gt;&nbsp;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/jwc&gt;
&lt;/jwc&gt;
</PROGRAMLISTING></figure>

<para> 
<calloutlist>
	 <callout arearefs="reuse.border.shell">
	 <para>
	 The <varname>shell</> component provides the <sgmltag class=starttag>html</> and
	 <sgmltag class=starttag>head</> elements of the response HTML.
	 </>
	 </>
	 
	 <callout arearefs="reuse.border.body">
	 <para>
	 The <varname>body</> components provides the <sgmltag class=starttag>body</> element.
	 It also provides support for JavaScript related to &Rollover; buttons, such as
	 the <varname>showInspector</> component.
	 </>
	 </>
	 
	 <callout arearefs="reuse.border.e">
	 <para>
	 The <varname>e</> component is a &Foreach; configured to work through
	 a list of page names (provided by the engine).
	 </>
	 </>
	 
	 <callout arearefs="reuse.border.insertName">
	 <para>	 
The <varname>link</> and <varname>insertName</>
components provide the inter-page navigation links.  
</>
</>


	<callout arearefs="reuse.border.wrapped">
<para>
The <varname>wrapped</> component provides the actual content for the page.  The
<classname>Border</> component is used on all three pages, but its a different
instance on each page, wrapping around different content specific to the page.
</>
</>


	<callout arearefs="reuse.border.showInspector">
<para>
The <varname>showInspector</> component provides the button below the 
page names (the italicized "i" in a 
circle) and will be explained shortly.  
</>
</>
</calloutlist>

<para>
The <classname>Border</> component is designed to be usable in other Tapestry 
applications, so it doesn't hard 
code the list of page names.  These must be provided to the component as a parameter. 
In fact, the 
application engine provides the list.
</para>

<figure>	
	<title>Border specification</>
<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE specification PUBLIC
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd"&gt;
  
&lt;specification class="tutorial.border.Border" allow-informal-parameters="no"&gt;
  
  &lt;parameter name="title" java-type="java.lang.String" required="yes"/&gt; <co id="reuse.border.spec.title">
  
  &lt;parameter name="pages" required="yes"/&gt; <co id="reuse.border.spec.pages">
  
  &lt;component id="shell" type="Shell"&gt;
    &lt;binding name="title" property-path="page.engine.specification.name"/&gt; <co id="reuse.border.spec.shell-title">
  &lt;/component&gt;
  
  &lt;component id="insertPageTitle" type="Insert"&gt;
    &lt;inherited-binding name="value" parameter-name="title"/&gt; <co id="reuse.border.spec.insertPageTitle">
  &lt;/component&gt;
  
  &lt;component id="body" type="Body"/&gt;
  
  &lt;component id="e" type="Foreach"&gt; <co id="reuse.border.spec.e">
    &lt;inherited-binding name="source" parameter-name="pages"/&gt;
    &lt;binding name="value" property-path="pageName"/&gt;
  &lt;/component&gt;
  
  &lt;component id="link" type="Page"&gt; <co id="reuse.border.spec.link">
    &lt;binding name="page" property-path="pageName"/&gt;
    &lt;binding name="disabled" property-path="disablePageLink"/&gt;
  &lt;/component&gt;
  
  &lt;component id="insertName" type="Insert"&gt;
    &lt;binding name="value" property-path="pageName"/&gt;
  &lt;/component&gt;
  
  &lt;component id="wrapped" type="InsertWrapped"/&gt;
  
  &lt;component id="showInspector" type="ShowInspector"/&gt; <co id="resuse.border.spec.showInspector">
&lt;/specification&gt;
</programlisting>
</figure>

<para>
<calloutlist>
	<callout arearefs="reuse.border.spec.title">
<para>
Declares a required parameter for the border, the title that will appear on the 
page.
</>
</>

<callout arearefs="reuse.border.spec.pages">
<para>
Declares a parameter to specify the list of page names.  We don't specify a
particular type because its pretty unbounded; the framework will accept
&List;, &Iterator; or a Java array.
</>
</>

<callout arearefs="reuse.border.spec.shell-title">

<para>
We then provide the <varname>shell</> component with its <varname>title</> parameter; 
this will be the window title.  We 
use the application's name, with is extracted from the application's specification.
</>
</>

<callout arearefs="reuse.border.spec.insertPageTitle">
<para>
The <sgmltag class=starttag>inherited-binding</> element allows a component to
share its parameters.  Here the <classname>Border</>'s <varname>title</>
is used as the <varname>value</> parameter of the <varname>insertPageTitle</> 
component (an &Insert;).
Using these 
inherited bindings simplifies the process of creating complex components from simple ones.
</>
</>

<callout arearefs="reuse.border.spec.e">
<para>
Likewise, the <varname>e</> component (a <classname>Foreach</>) 
needs as its source the list of pages, which it inherits from 
the <classname>Border</> component's <varname>pages</> parameter.  
It has been configured to store each succesive page 
name into the <varname>pageName</> property of the <classname>Border</> component; 
this is necessary so that the <classname>Border</>
component can determine which page link to disable (it disables the current page since we're 
already there).
</>
</>

<callout arearefs="reuse.border.spec.link">
<para>
The <varname>link</> component creates the link to the other pages.  It has a
<varname>disabled</> parameter; which, 
when true, causes the link component to not create the hyperlink (though it still allows the 
elements it wraps to render).  The Java class for the <classname>Border</> component, 
<classname>tutorial.border.Border</>, provides a method, <function>getDisablePageLink()</>, 
that returns true 
when the <varname>pageName</> instance variable (set by the <varname>e</> component) 
matches the current page's name.
</>
</>

<callout arearefs="resuse.border.spec.showInspector">
<para>
The <varname>showInspector</> component creates a rollover button (the "i" lights up when the mouse is 
moved over it):
</>
</>
</calloutlist>
</para>

<para> 
So, the specification for the <classname>Border</> component must identify the 
parameters it needs, but also the 
components it uses and how they are configured.
</>

<figure>
	<title>Show Inspector Button</>
	<mediaobject>
		<imageobject>
			<imagedata fileref="images/show-inspector-button.jpg" format="jpg">
		</imageobject>
	</>
</figure>

<para>
Clicking on the button raises a second window that describes the current page in the application 
(this is used when debugging a Tapestry applicaton).  The Inspector is described in the next 
chapter.
</>

<para>
The final mystery is the <varname>wrapped</> component.  It is used to render the elements wrapped by the 
<classname>Border</> on the page containing the <classname>Border</>. 
Those elements  will vary from page to page; running 
the application shows that they are different on the home, credo and legal pages (different text 
appears in the central light-grey box).  There is no limitation on the elements either:  Tapestry is 
specifically designed to allow components to wrap other components in this way, without any 
arbitrary limitations.
</>

<para>
This means that the different pages could contain forms, images or any set of components at all, 
not just static HTML text.
</>

<para>
The specification for the home page shows how the title and pages parameters are set.  The title is 
static, the literal value "Home" (this isn't the best approach if localization is a concern).
</>

<figure>
	<title>Home page specification</>
	<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE specification PUBLIC
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd"&gt;

&lt;specification class="com.primix.tapestry.BasePage"&gt;

  &lt;component id="border" type="Border"&gt;
    &lt;static-binding name="title"&gt;Home&lt;/static-binding&gt;
    &lt;binding name="pages" property-path="engine.pageNames"/&gt;
  &lt;/component&gt;

&lt;/specification&gt;
</programlisting></figure>

<para>  
The <varname>pages</> property is retrieved from the application engine, 
which implements a <varname>pageNames</> JavaBeans property:
</>

<figure>
	<title>BorderEngine.java (excerpt)</>
	<programlisting><![CDATA[  
  private static final String[] pageNames =
    { "Home", "Credo", "Legal" };

  public String[] getPageNames()
  {
    return pageNames;
  }
]]>
</programlisting>
</figure>

<para>
How did Tapestry know that the type 'Border' 
corresponded to the specification <filename>/tutorial/border/Border.jwc</>?  Only because we defined 
an alias in the application specification:
</>

<figure>
	<title>Border.application (excerpt)</>
	<programlisting>
  &lt;component-alias type="Border" specification-path="/tutorial/border/Border.jwc"/&gt;
</programlisting></figure>

<para> 
Had we failed to do this, we would have had to specify the complete resource path, 
<filename>/tutorial/border/Border.jwc</>, on each page's specification, instead of the short alias 
'Border'.  There is no magic about the existing Tapestry component types 
(&Insert;, &Foreach;, &Page;, etc. ... they each have an 
alias pre-registered into every application specification.  These short 
aliases are simply a convienience.
</>


</chapter>


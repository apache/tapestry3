<?xml version="1.0" encoding="utf-8"?>
<!-- $Id$ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN"
  "http://www.oasis-open.org/docbook/xml/4.1/docbookx.dtd" [
  <!ENTITY jwc-tag "<sgmltag class='starttag'>jwc</sgmltag>">
  <!ENTITY start-jwc "<emphasis>&lt;">
  <!ENTITY end-jwc "&gt;</emphasis>">
  
  <!ENTITY % TapestryLinks SYSTEM "../common/TapestryLinks.xml">
  
  %TapestryLinks;

<!ENTITY Action '<ulink url="&ApiRoot;/link/Action.html"><classname>Action</classname></ulink>'>
<!ENTITY Conditional '<ulink url="&ApiRoot;/components/Conditional.html"><classname>Conditional</classname></ulink>'>
<!ENTITY Direct '<ulink url="&ApiRoot;/link/Direct.html"><classname>Direct</classname></ulink>'>
<!ENTITY Foreach '<ulink url="&ApiRoot;/components/Foreach.html"><classname>Foreach</classname></ulink>'>
<!ENTITY Form '<ulink url="&ApiRoot;/form/Form.html"><classname>Form</classname></ulink>'>
<!ENTITY Insert '<ulink url="&ApiRoot;/components/Insert.html"><classname>Insert</classname></ulink>'>
<!ENTITY ImageSubmit '<ulink url="&ApiRoot;/form/ImageSubmit.html"><classname>ImageSubmit</classname></ulink>'>
<!ENTITY Page '<ulink url="&ApiRoot;/link/Page.html"><classname>Page</classname></ulink>'>
<!ENTITY PropertySelection '<ulink url="&ApiRoot;/form/PropertySelection.html"><classname>PropertySelection</classname></ulink>'>
<!ENTITY Radio '<ulink url="&ApiRoot;/form/Radio.html"><classname>Radio</classname></ulink>'>
<!ENTITY RadioGroup '<ulink url="&ApiRoot;/form/RadioGroup.html"><classname>RadioGroup</classname></ulink>'>
<!ENTITY Rollover '<ulink url="&ApiRoot;/html/Rollover.html"><classname>Rollover</classname></ulink>'>
<!ENTITY TextField '<ulink url="&ApiRoot;/form/TextField.html"><classname>TextField</classname></ulink>'>

]>
<!-- Conventions:

	Component ids are <varname>
	Java packages and class names are <classname>
	Tapestry component aliases are <classname>

	In-line code snippets use <function>
	Property paths and JavaBeans property names used <varname>
-->
<book>
  <title>Tapestry Tutorial</title>
  <bookinfo>
    <author>
      <firstname>Howard</firstname>
      <surname>Ship</surname>
      <affiliation>
        <orgname>Primix</orgname>
      </affiliation>
    </author>
    <copyright>
      <year>2000</year>
      <year>2001</year>
      <holder>Primix</holder>
    </copyright>
  </bookinfo>
  <!-- $Id$ -->
  <chapter id="intro">
    <title>Introduction</title>
    <para>
Tapestry is a new application framework developed at Primix.
</para>
    <para>
Tapestry uses a component object model to represent the pages of a web application.  This is 
similar to spirit to using the Java Swing component object model to build GUIs.
</para>
    <para>
Just like using a GUI toolkit, there's some preparation and some basic ideas that must be cleared 
before going to more ambitious things.  Nobody writes a word processor off the top of their head 
as their first GUI project; nobody should attempt a full-featured e-commerce site as their first 
attempt using Tapestry.
</para>
    <para>
The goal of Tapestry is to eliminate most of the coding in a web application.  Under Tapestry, 
nearly all code is directly related to application functionality, with very little "plumbing".  If you 
have previously developed a web application using Microsoft Active Server Pages, JavaServer 
Pages or Java Servlets, you may take for granted all the plumbing:  writing servlets, assembling 
URLs, parsing URLs, managing objects inside the &HttpSession;, etc.
</para>
    <para>
Tapestry takes care of nearly all of that, for free.  It allows for the development of rich, highly 
interactive applications.
</para>
    <para>
This tutorial will start with basic concepts, such as the "Hello World" application, and will 
gradually build up to more sophisticated examples.
</para>
    <para>
The tutorial uses &Jetty;, 
a freely available servlet engine, which is packaged with 
the Tapestry 
distribution.
</para>
    <para>
The format of this tutorial is to describe (visually and with text) an application within the tutorial, 
then describe how it is constructed, using code excerpts.  The reader is best served by having an 
IDE open so that they can look at the code in detail, as well as run the applications.
</para>
  </chapter>
  <!-- $Id$ -->
  <chapter id="setup">
    <title>Setting up the Tutorial</title>
    <para>
This document expects that you will have extracted the full Tapestry distribution to your 
<filename class="directory">C:</filename> drive
	<footnote>
        <para>
		If you are using Solaris or another non-Windows operating system, you're expected
		to be savvy enough to translate to a sensibly constructed file system.
		</para>
      </footnote>
    </para>
    <para>
This will have created a directory <filename class="directory">C:\Tapestry-<replaceable>x.x.x</replaceable>
      </filename>
and, beneath it, several more directories.
	<footnote>
        <para>
		The three numbers are the release number.  At the time of this writing, the release
		was 1.0.3, but this is constantly changing.  Simply adjust the actual pathname to
		reflect the release of Tapestry you downloaded.
		</para>
      </footnote>
    </para>
    <para>
The Tapestry Tutorial will be in <filename class="directory">
C:\Tapestry-<replaceable>x.x.x</replaceable>\examples\Tutorial</filename>.
</para>
    <section id="setup.build">
      <title>Building the Tutorial</title>
      <para>
Building the Tutorial is quite easy.  You first need to download and install
<ulink url="http://jakarta.apache.org/ant/index.html">Ant</ulink>, a standard Java build tool.  Tapestry
is pre-configured to build and execute using Ant.
</para>
      <para>
Change to the Tapestry distribution directory,
<filename class="directory">C:\Tapestry-<replaceable>x.x.x</replaceable>
        </filename>.
</para>
      <para>
Execute the command <command>ant run-tutorial</command>, which will launch the
Jetty server for the Tutorial.
</para>
      <para>
Once Jetty is running, you can access the Tutorials using the URL 
<ulink url="http://localhost:8080/tutorial">
          <filename>http://localhost:8080/tutorial</filename>
        </ulink>.
</para>
      <figure>
        <title>Tutorial Index Page</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/tutorial-index.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </chapter>
  <!-- $Id$ -->
  <chapter id="hello">
    <title>Hello World</title>
    <para>
In this first example, we'll create a very simple "Hello World" kind of application.  It won't have 
any real functionality but it'll demonstrate the simplest possible variation of a number of key 
aspects of the framework.
</para>
    <para>
We'll define our application, define the lone page of our application, configure everything and 
launch it.
</para>
    <para>
The code for this section of the tutorial is in the Java package <classname>tutorial.hello</classname>, i.e., 
<filename class="directory">C:\Tapestry-<replaceable>x.x.x</replaceable>\examples\Tutorial\src\tutorial\hello</filename>.
</para>
    <section id="hello.engine">
      <title>Application Engine</title>
      <para>
As each new client connects to the application, an instance of the application engine is created for 
them.  The application engine is used to track that client's activity within the application.
</para>
      <para>
The application engine is an instance, or subclass of, the Tapestry class 
&SimpleEngine;.
</para>
      <para>
In these first few examples, we have no additional behavior to add to the provided base class, so 
we simply use &SimpleEngine; directly.
</para>
    </section>
    <section id="hello.servlet">
      <title>Application Servlet</title>
      <para>
The application servlet is a "bridge" between the servlet container and the application engine.  Its 
job is simply to create (on the first request) or locate (on subsequent requests) the application 
engine.
</para>
      <para>
The application servlet must subclass 
&ApplicationServlet; and 
implement the method:  <function>getApplicationSpecificationPath()</function>.  
This method provides the 
path to the application specification file; the servlet reads this file when it is initialized.
</para>
      <figure>
        <title>HelloWorldServlet.java</title>
        <programlisting>
package tutorial.hello;

import com.primix.tapestry.*;

public class HelloWorldServlet extends ApplicationServlet
{
  protected String getApplicationSpecificationPath()
  {
    return "/tutorial/hello/HelloWorld.application";
  }

}
</programlisting>
      </figure>
    </section>
    <section id="hello.appspec">
      <title>Application Specification</title>
      <para>
The application specification is used to describe the application to the Tapestry framework.  It 
provides the application with a name, an engine class, and a list of pages.
</para>
      <para>
This specification is a file that is located on the Java class path.  In a deployed Tapestry 
application, the specification lives with the application's class files, in the 
<filename class="directory">WEB-INF/classes</filename> directory of a War file.
</para>
      <figure>
        <title>HelloWorld.application</title>
        <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE application PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">
<application
  name="Hello World Tutorial"
  engine-class="com.primix.tapestry.engine.SimpleEngine">
  
  <page name="Home" 
    specification-path="/tutorial/hello/Home.jwc"/>

</application>]]></programlisting>
      </figure>
      <para> 
Our application is very simple; we give the application a name, use the standard engine, and define 
a single page, named "Home".  In Tapestry, pages and components are specified with the path to their 
specification file (a file that end with '.jwc').
</para>
      <para>
Page "Home" has a special meaning to Tapestry: when you first launch a Tapestry application, it 
loads and displays the "Home" page.  All Tapestry applications are required to have such a home 
page.
</para>
    </section>
    <section id="hello.home-page-spec">
      <title>Home Page Specification</title>
      <para>
The page specification defines the Tapestry component responsible for the page.  In this first 
example, our component is very simple.
</para>
      <figure>
        <title>Home.jwc</title>
        <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE specification PUBLIC
  "-//Howard Ship//Tapestry Specification 1.1//EN"
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">

<specification class="com.primix.tapestry.BasePage"/>
]]></programlisting>
      </figure>
      <para>
This simply says that <classname>Home</classname> is a kind of page.  We use the supplied Tapestry class 
<classname>com.primix.tapestry.BasePage</classname> since we aren't adding any behavior to the page.
</para>
    </section>
    <section id="hello.home-page-template">
      <title>Home Page Template</title>
      <para>
Finally, we get to the content of our application.  This file is also a Java resource; 
it isn't directly 
visible to the web server.  It has the same location and name as the component specification, 
except that it ends in "html".
</para>
      <figure>
        <title>Home.html</title>
        <programlisting><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<title>Hello World</title>
</head>

<body>

Welcome to your first <b>Tapestry Application</b>.

</body>
</html>]]></programlisting>
      </figure>
    </section>
    <section id="hello.run">
      <title>Run the Application</title>
      <para>
You should already be running the Jetty server in a window, and have a browser running the 
tutorials page.  Select the first option, Hello World, from the list.  You will be presented with the 
first (and only) page generated by Tapestry for this application:
</para>
      <figure>
        <title>Hello World Application</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/hello-world.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
Not much of an application ... there's no interactivity.  It might as well be a static web page, but it's 
a start.  Remember, there was no JavaServer page here, and no HTML directly visible to the web 
server.  There was an application consisting of a single component.
</para>
      <para>
In the following chapters, we'll see how to add dynamic content and then true interactivity.
</para>
    </section>
  </chapter>
  <!-- $Id$ -->
  <chapter id="dynamic">
    <title>Dynamic Content</title>
    <para>
In this chapter, we'll create a new web application that will show some dynamic content.  We'll also 
begin to show some interactivity by adding a link to the page.
Our dynamic content will simply be to show the current date and time. The interactivity will be a 
link to refresh the page.  It all looks like this:
</para>
    <figure>
      <title>Dynamic Application</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/dynamic.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
Clicking the word "here" will update the page showing the new data and time.  Not incredibly 
interactive, but it's a start.
</para>
    <para>
The code for this section of the tutorial is in the package 
<classname>tutorial.simple</classname>.
</para>
    <para>
We need to create a new servlet, but its almost identical to our earlier 
one.  The real action in this section will be the new 
version of the home page.
</para>
    <figure>
      <title>SimpleServlet.java</title>
      <programlisting><![CDATA[
package tutorial.simple;

import com.primix.tapestry.*;
import com.primix.tapestry.app.*;

public class SimpleServlet extends ApplicationServlet
{
  protected String getApplicationSpecificationPath()
  {
    return "/tutorial/simple/Simple.application";
  }
}]]></programlisting>
    </figure>
    <para>
The application specification is also straight forward:
</para>
    <figure>
      <title>Simple.application</title>
      <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE application PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">

<application name="Simple Tutorial" engine-class="com.primix.tapestry.engine.SimpleEngine">
  <page name="Home" specification-path="/tutorial/simple/Home.jwc"/>
</application>
]]></programlisting>
    </figure>
    <para>
Things only begin to get more interesting when we look at the HTML template for the home 
page:
</para>
    <figure>
      <title>Home.html</title>
      <programlisting><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>Simple</title>
</head>
<body>
This application demonstrates some dynamic behavior using Tapestry 
components.

<p>The current date and time is: <b><jwc id="insertDate"/></b>

<p>Click <jwc id="refresh">here</jwc> to refresh.

</body>
</html>]]></programlisting>
    </figure>
    <para> 
This looks like ordinary HTML, except for the special &jwc-tag; tags.  "jwc" is an 
abbreviation for "Java Web Component"; these tags are placeholders for the dynamic content 
provided by Tapestry components.
</para>
    <para>
We have two components.  The first inserts the current date and time into the HTML response. 
The second component 
creates a hyperlink that refreshes the page when clicked.</para>
    <para>
One of the goals of Tapestry is that the HTML should have the minimum amount of special 
markup.  This is demonstrated here ... the &jwc-tag;  tags blend into the standard HTML of the 
template.  We also don't confuse the HTML by explaining exactly what an <varname>insertDate</varname>
or <varname>refresh</varname>
is; that comes out of the specification (described shortly).  The ids used here are meaningful only 
to the developer
	<footnote>
        <para>Of course, good and consistent naming is important.
		</para>
      </footnote>, the particular type and configuration of each component is defined in the 
component specification.
</para>
    <para>
Very significant is the fact that a Tapestry component can 
<emphasis>wrap</emphasis> around other elements of the 
template.  The <varname>refresh</varname> component wraps around the word "here".  
What this means is that the 
<varname>refresh</varname> component will get a chance to emit some HTML (an 
<sgmltag class="starttag">a</sgmltag> hyperlink tag), then emit the 
HTML it wraps (the word "here"), then get a chance to emit more HTML (the 
<sgmltag class="endtag">a</sgmltag> closing tag).
</para>
    <para>
What's more important is that the component can not only wrap static HTML from the template 
(as shown in this example), but may wrap around other Tapestry components  and those 
components may themselves wrap text and components, to whatever depth is required.
</para>
    <para>
And, as we'll see in later chapters, a Tapestry component itself may have a template and more 
components inside of it.  In a real application, the single page of HTML produced by the 
framework may be the product of dozens of components, effectively "woven" from dozens of 
HTML templates.
</para>
    <para>
Again, the HTML template doesn't define what the components are, it is simply a mix of static 
HTML that will be passed directly back to the client web browser, with a few placeholders (the 
&jwc-tag; tags) for where dynamic content will be plugged in.
</para>
    <para>
The page's component specification defines what types of components are used and how data 
moves between the application, page and any components.
</para>
    <figure>
      <title>Home.jwc</title>
      <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE specification PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">

<specification class="tutorial.simple.Home">

  <component id="insertDate" type="Insert">
    <binding name="value" property-path="currentDate"/>
  </component>

  <component id="refresh" type="Page">
    <static-binding name="page">Home</static-binding>
  </component>

</specification>]]></programlisting>
    </figure>
    <para>
Here's what all that means:  The <varname>Home</varname> page is implemented with a custom class, 
<classname>tutorial.simple.Home</classname>.  It contains two components, 
<varname>insertDate</varname> and <varname>refresh</varname>.
</para>
    <para>
The two components used within this page are provided by the Tapestry framework.
</para>
    <para>
The <varname>insertDate</varname> component is type &Insert;. 
&Insert; components have a <varname>value</varname> parameter used to 
specify what should be inserted into the HTML produced by the page.  The 
<varname>insertDate</varname>
component has its <varname>value</varname> parameter bound to a JavaBeans property of its container 
(the page), the <varname>currentDate</varname> property.
</para>
    <para>
The <varname>refresh</varname> component is type &Page;, meaning it creates a 
link to some other page in the 
application. &Page; components have a parameter, named <varname>page</varname>, 
which defines the name of the 
page to navigate to.  The name is matched against a page named in the application specification.
</para>
    <para>
In this case, we only have one page in our application (named "Home"), so we can use a static 
binding for the page parameter.  A static binding provides a value for the component parameter 
statically, the same value every time.  The value is defined right in the specification.
</para>
    <para>
That just leaves the implementation of the Home page component:
</para>
    <figure>
      <title>Home.java</title>
      <programlisting><![CDATA[
package tutorial.simple;

import java.util.*;
import com.primix.tapestry.*;

public class Home extends BasePage
{
  public Date getCurrentDate()
  {
    return new Date();
  }
}]]></programlisting>
    </figure>
    <para>
      <classname>Home</classname> implements a  read-only JavaBeans property, <varname>currentDate</varname>.  
This is the same <varname>currentDate</varname>
that the <varname>insertDate</varname> component needs.  When asked for the current date, the 
<varname>Home</varname> object returns 
a new instance of the <classname>java.util.Date</classname> object.
</para>
    <para>
The <varname>insertDate</varname> component converts objects into strings by invoking 
<function>toString()</function> on the object.
</para>
    <para>
Now all the bits and pieces are working together.
</para>
    <para>
Run the application, and use the View Source command to examine the HTML generated by 
by framework.
</para>
    <figure>
      <title>HTML generated for Home page</title>
      <programlisting><![CDATA[
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>Simple</title>
</head>
<body>

This application demonstrates some dynamic behavior using Tapestry 
components.

<p>The current date and time is: <b>Thu Nov 09 17:23:31 EST 2000</b>

<p>Click 
<a href="/tutorial/simple/page/Home">here</a> to refresh.

</body>
</html>]]></programlisting>
    </figure>
    <para> 
This should look very familiar, in that it is mostly the same as the HTML template for the page.
Tapestry not only inserted simple text (the current date and time, 
obtained from an <classname>java.util.Date</classname> object), but the 
<varname>refresh</varname> component inserted the <sgmltag class="starttag">a</sgmltag> and 
<sgmltag class="endtag">a</sgmltag> tags, and created an appropriate URL for the href attribute.
</para>
  </chapter>
  <chapter id="interactive">
    <title>Interactive Application</title>
    <para>
Now it's time to build a real, interactive application.  We'll still use just a single page, but it will 
demonstrate many of the more interesting features of Tapestry, including maintenance of server 
side page state.
</para>
    <para>
Our Adder application allows the user to sum up a list of numbers.
</para>
    <figure>
      <title>Adder Application</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/adder.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
The user enters a number into the value field and clicks "Add to list".  The number is added to the 
list of items and factored into the total.
</para>
    <para>
A &Form; component containing a &TextField; component will 
be used to collect information from 
the user.  A &Foreach; component will be used to run though the list of items, and 
&Insert; components will be used to present each item in the list, as well as the total.
</para>
    <para>
If the user enter in a non-number, then an error message is displayed.
</para>
    <para>
As with the previous examples, the servlet and application objects are simple variations on the 
previous two sets (they are ommited here).
</para>
    <para>
The application specification is, likewise, a variation on the prior example.
</para>
    <para>
The code for this section is in the <classname>tutorial.adder</classname> package.
</para>
    <para>
We'll start with the HTML template for the home page:
</para>
    <figure>
      <title>Home.html</title>
      <programlisting><![CDATA[
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>Adder Tutorial</title>
</head>
<body>

<jwc id="ifError">
<table border=1>
  <tr>
    <td bgcolor=red>
      <span style="font: bolder 14pt; color:white">
        <jwc id="insertError"/>
      </span>
    </td>
  </tr>
</table>
<p>
</jwc>

<jwc id="form">

<table>
  <tr>
    <td align=right>Value:</td>
    <td><jwc id="inputNewValue"/></td>
  </tr>
  <tr>
    <td> </td>
    <td><input type=submit value="Add to list"></td>
  </tr>
</table>

</jwc>

<table>
  <tr> <th>Items</th> </tr>
<jwc id="e">
  <tr align=right>
    <td>
      <jwc id="insertCurrentValue"/> 
    </td>
  </tr>
</jwc>

  <tr align=right>
    <td> 
      <hr>
      <br><jwc id="insertTotal"/>
    </td>
  </tr>
</table>

</body>
</html>]]></programlisting>
    </figure>
    <para>
Again, Tapestry takes care of most of the details.  The <varname>form</varname> component will turn into an HTML 
<sgmltag class="starttag">form</sgmltag> element, and the correct URL is automatically generated.  
The <varname>inputNewValue</varname> component 
will become an <sgmltag class="starttag">input type=text</sgmltag>, 
with the necessary smarts to collect the value 
submitted by the user and provide it to the page.
</para>
    <para>
The <varname>e</varname> component is type &Foreach;, 
used for running through a list of elements (supplied as a &List;, 
&Iterator; or an array of Java objects).   
We've already see the &Insert; component.
</para>
    <para>
Next we have the specification:
</para>
    <figure>
      <title>Home.jwc</title>
      <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE specification PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">
  
<specification class="tutorial.adder.Home">

  <component id="ifError" type="Conditional">
    <binding name="condition" property-path="error"/>
  </component>
  
  <component id="insertError" type="Insert">
    <binding name="value" property-path="error"/>
  </component>
  
  <component id="form" type="Form">
    <binding name="listener" property-path="formListener"/>
  </component>
  
  <component id="inputNewValue" type="TextField">
    <binding name="text" property-path="newValue"/>
  </component>
  
  <component id="e" type="Foreach">
    <binding name="source" property-path="items"/>
  </component>
  
  <component id="insertCurrentValue" type="Insert">
    <binding name="value" property-path="components.e.value"/>
  </component>
  
  <component id="insertTotal" type="Insert">
    <binding name="value" property-path="total"/>
  </component>
  
</specification>
]]></programlisting>
    </figure>
    <para>  
We only want to display the error message if there is one, so the 
<varname>ifText</varname> is conditional on there 
being a non-null error message (the &Conditional; component treats 
<literal>null</literal> as <literal>false</literal>).
</para>
    <para>
For the <varname>form</varname> component, all we have to do is supply a 
<varname>listener</varname>, an object that is informed when 
the form is submitted.
</para>
    <para>
For the <varname>inputNewValue</varname> component, we provide a <varname>text</varname> parameter 
that provides the default value for the 
<sgmltag class="starttag">input</sgmltag> element.  The same property is updated with the value
submitted with the form.
</para>
    <para>
The property must be of type &String;, so we need to do a little 
translation (in our Java class), since internally 
we want to store the value as a double.
</para>
    <para>
For the <varname>e</varname> component, we supply a binding for the <varname>source</varname> parameter.  
For each item in the source 
list, it will update its own <varname>value</varname> property, which is later accessed by the 
<varname>insertCurrentValue</varname> component.  The 
property path <varname>components.e.value</varname> accomplishes this:  
the page has a <varname>components</varname> property, which 
is a &Map; of the components on the page.  
<varname>e</varname> is the id of a component, and a key in the &Map;. It has 
a property named <varname>value</varname>, which is the current item from the source list.
</para>
    <para>
A &Foreach; component also has a parameter named <varname>value</varname>.  
By creating a binding for this parameter, the 
&Foreach; can update a property of the page, or some other component.  
This is more commonly 
used when the items in the list are business objects and the application needs to invoke business 
methods on them.
</para>
    <para>
Finally, the Java code for the home page puts everything together:
</para>
    <figure>
      <title>Home.java</title>
      <programlisting><![CDATA[
package tutorial.adder;

import com.primix.tapestry.*;
import com.primix.tapestry.components.*;
import java.util.*;

public class Home extends BasePage
{
  private List items;
  private String newValue;
  private String error;

  public List getItems()
  {
    return items;
  }

  public void setItems(List value)
  {
    items = value;

    fireObservedChange("items", value);
  }

  public void setNewValue(String value)
  {
    newValue = value;
  }

  public String getNewValue()
  {
    return newValue;
  }

  public void detach()
  {
    items = null;
    newValue = null; 
    error = null;

    super.detach();
  }

  public void beginResponse(IResponseWriter writer,
					  IRequestCycle cycle)
			   throws RequestCycleException
  {
    super.beginResponse(writer, cycle);
	
	if (items == null)
	  setItems(new ArrayList());
  }

  public void addItem(double value)
  {
    if (items == null)
    {
      items = new ArrayList();
      fireObservedChange("items", items);
    }

    items.add(new Double(value));

    fireObservedChange();
  }

  public double getTotal()
  {
    Iterator i;
    Double item;
    double result = 0.0;

    if (items != null)
    {
      i = items.iterator();
      while (i.hasNext())
      {
        item = (Double)i.next();
        result += item.doubleValue();
      }
    }

    return result;
  }

  public IActionListener getFormListener()
  {
    return new IActionListener()
    {
      public void actionTriggered(IComponent component, 
                                  IRequestCycle cycle)
      {
        try
        {
          double item = Double.parseDouble(newValue);
          addItem(item);

          newValue = null;
        }
        catch (NumberFormatException e)
        {
          error = "Please enter a valid number.";
        }
      }
    };

  }

  public String getError()
  {
    return error;
  }
}]]></programlisting>
    </figure>
    <para>
That may seem like a lot of code for what we're doing, but in reality, very much is going that we 
don't have to write:
</para>
    <itemizedlist>
      <listitem>
        <para>
		Processing the submitted form
		</para>
      </listitem>
      <listitem>
        <para>
		Storing the List of items persistently between request cycles
		</para>
      </listitem>
      <listitem>
        <para>
		Encoding and decoding URLs
		</para>
      </listitem>
      <listitem>
        <para>
		Very robust exception support
		</para>
      </listitem>
    </itemizedlist>
    <para>
Tapestry components, using JavaBeans properties, take care of moving data to and from the 
HTML form.  Our application merely has to supply the logic to properly respond when the form 
is submitted.  In this case, converting the text into a double that can be added to the list.
</para>
    <para>
Because we let Tapestry set the names of our form elements, there's no possibility of mismatched 
names between the Java code (setting defaults and interpreting the posted request) and the 
HTML template.
</para>
    <para>
Enter a few values into the text field to see how the application works, adding them together into 
an ever larger list.
</para>
    <section id="interactive.listeners">
      <title>Adding Interactivity using Listeners</title>
      <para>
To understand the relationship between the home page specification, the home page class and the 
components used by the home page, it is necessary to understand the JavaBeans properties 
provided by the home page class.
</para>
      <para>
We implement several JavaBeans properties on this page:
</para>
      <table>
        <title>JavaBeans Properties</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Property name</entry>
              <entry>Type</entry>
              <entry>R / W</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>newItem</entry>
              <entry>String</entry>
              <entry>R / W</entry>
              <entry>Stores the string entered into the form.</entry>
            </row>
            <row>
              <entry>items</entry>
              <entry>List (of Double)</entry>
              <entry>R / W</entry>
              <entry>Items in the list.  Persists between request cycles.</entry>
            </row>
            <row>
              <entry>formListener</entry>
              <entry>IActionListener</entry>
              <entry>Read Only</entry>
              <entry>Informed when form is submitted.</entry>
            </row>
            <row>
              <entry>total</entry>
              <entry>double</entry>
              <entry>Read Only</entry>
              <entry>Total of items; computed on the fly.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
This example demonstrates how to provide interactivity to an application.  For Tapestry, 
interactivity is defined as a request cycle initiated by a user clicking on a hyperlink or submitting a 
form.
</para>
      <para>
In our case, we want to know when the form containing the text field is submitted so that we can 
provide application specific behavior:  adding the value enterred by the user to the list of 
items.
</para>
      <para>
This is accomplished using a listener, an object that implements the Java interface 
&IActionListener;.  
This interface defines a single method, <function>actionTriggered()</function>.  When the 
form is submitted, all the components wrapped by the form (in this case, the &TextField;) 
are given 
a chance to retrieve their values from the request and update properties of the application (the 
&TextField; sets the <varname>currentItem</varname> property).  
The form then gets its listener and invokes the 
<function>actionTriggered()</function> method.
</para>
      <para>
In the specification, the listener parameter was bound to the <varname>formListener</varname> 
property of the page.  
The code in the <function>getFormListener()</function> method creates an anonymous inner class and 
returns it.
</para>
      <para>
Inner classes have access to the private fields and methods of the class.  In this case, the inner 
class invokes the <function>addItem()</function> method to add the <varname>currentItem</varname>
(with a value provided by the 
&TextField; component) to the items &List;.
</para>
      <para>
A listener is free to do anything it wants.  It can change the state of the application, or can retrieve 
other pages (by name) from the request cycle object, and can change properties of those pages.  It 
can even chose a different page to render, by invoking <function>setPage()</function> on the request cycle.
</para>
    </section>
    <section id="interactive.pooling">
      <title>Persistant Page State and Page Pooling</title>
      <para>
The Home page of this application uses a persistant page property, a &List; that contains 
&Double;s, the items in the list.
</para>
      <para>
Persistent page state is one of the most important concepts in Tapestry.  Each page in the 
application (and in fact, even components within the page) may have some properties that should 
persist between requests.  This can be values such as the user's name and address, or (in this case) 
the list of numbers enterred so far.
</para>
      <para>
In traditional JavaServer Pages or servlet applications, a good chunk of code must be written to 
manage this.  The values must be encoded in cookies, as hidden form fields, as named attributes 
of the &HttpSession;, or stored into a server-side flat file or database.  
Each servlet (or JSP) is 
directly responsible for managing access to these values which leads to many half realized, ad-
hoc solutions and an avalanche of bugs, and even security holes.
</para>
      <para>
With Tapestry, the framework takes care of these persistence issues.  When a persistent property 
of a page is changed the accessor method also invokes the method 
<function>fireObservedChange()</function>. 
This method informs a special object, the page's recorder, about the property and its new value.
</para>
      <para>
When the page is next used, the value is restored automatically.  This may not seem natural; an 
obvious question is:  why wasn't the page in the same state?  Then answer is that that page 
instance is shared, and may be used by a different client in the interrum.
</para>
      <para>
Within the Tapestry framework, all of these pages, components, specifications and templates are 
converted into Java objects.  Assembling a page is somewhat expensive:  it involves reading all 
those specifications and templates , creating and initializating component objects, creating binding 
objects for the components, and organizing the components into a hierarchy.
</para>
      <para>
Creating a page object for just one request cycle only to discard it is simply unacceptible.  Pages 
should be kept around as long as they are needed; they should be re-used in subsequent request 
cycles, both for the same client session, or for other sessions.
</para>
      <para>
The Tapestry framework accomplishes this by pooling instances of page objects; there could 
concievably be a handful of different instances being shared by thousands of client sessions.  This 
is a kind of shell game that is important to maintain scalability.
</para>
      <para>
What this means for the developer is some minor extra work.  On each request cycle, a different 
instance of the page object may be used to handle the request.  This means that data can't simply 
be stored in the instance variables of the page between request cycles.
</para>
      <para>
Tapestry isolates the persistent state of a page from the actual page objects.  The state is stored 
seperately, making use of the page recorder objects.  When needed, a page can be created or 
reclaimed from the page pool and have all of its persistant properties set by the page recorder.  
</para>
      <para>
The developer has three responsibilities when coding a page with persistant state:
</para>
      <itemizedlist>
        <listitem>
          <para>
        The property must be serializable; this includes Java scalar types (boolean, int, double, 
etc.), &String;s, common collection classes
(<classname>ArrayList</classname>, <classname>HashMap</classname>, etc.) and other classes 
that implement <classname>java.io.Serializable</classname>.
		</para>
        </listitem>
        <listitem>
          <para>
        	When the value of the property changes, the 
            <function>fireObservedChange()</function> method must be 
invoked, to inform the page recorder about the change.
		</para>
        </listitem>
        <listitem>
          <para>
        When the request cycle ends and the page is returned to the pool, the persistant state 
must be reset to its initial value (as if the page object was newly instantiated).  This is done 
in the <function>detach()</function> method.
		</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="interactive.dynamic">
      <title>Dynamic Page State</title>
      <para>
This page has a bit of dynamic state; state that changes as the page is being renderred. The 
<varname>value</varname>
property  of the &Foreach; component takes on different values from the <varname>items</varname>
&List; as the page is 
renderred.  Dynamic state is easier to handle than persistant state; for completeness, it must also 
be reset in the <function>detach()</function> method.
</para>
    </section>
  </chapter>
  <chapter id="errors">
    <title>Tapestry Run Time Errors</title>
    <para>
0ne of the benefits to developing using Tapestry is its robust exception handling support.
We'll demonstrate these by creating invalid URLs.
</para>
    <section id="errors.stale-session">
      <title>Stale Sessions</title>
      <para>
As we just demonstrated, Tapestry is quite careful about conversational state.  What happens if all 
the conversation state is lost?
</para>
      <para>
Start up adder application then enter a few numbers.  Go back to the window executing Jetty and 
stop it, then restart it.
</para>
      <para>
Now, try to add an additional number to the list.
</para>
      <figure>
        <title>Session Timeout Page</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/timeout.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
Because Tapestry can't find any information about your session, it assumes the session timed out 
and was discarded, and so presents the default error page for this situation.
</para>
      <para>
Remember that most Tapestry URLs are very conversational, they only make sense as the most 
recent request in a series of requests exchanged between the client and the server.
</para>
      <para>
This means that many pages in a Tapestry application can't be bookmarked; the URL that would 
be stored in the client's web browser is not meaningful.  Creating bookmarkable pages is a subject 
of a later tutorial.
</para>
    </section>
    <section id="errors.exception-handling">
      <title>Exception Handling</title>
      <para>
Tapestry handles exceptions that are thrown during the processing of any request.
Exceptions are caught when they occur and result in the generation of a page with 
all the details.  Of course, in your own application, such exceptions will never occur, or will be 
caught and handled by your own code.
</para>
      <para>
Still, it's nice that Tapestry can assist when debugging during development, when uncaught 
exceptions may in fact be thrown.
</para>
      <para>
To demonstrate what Tapestry does for exceptions, we need to do a little bit of sneaky work.
</para>
      <para>
First, start up the adder application and enter a few numbers:
</para>
      <figure>
        <title>Adder application before error</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/adder-error-before.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para> 
Now, edit the URL in the Address field, and change the word "action" to "acion" (i.e, remove the 
letter 't') and hit return.
</para>
      <figure>
        <title>Error in Adder application</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/adder-error-after.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para> 
Tapestry has discovered that the URL was invalid ... in this case that the word "action" was 
changed to "acion".  Since Tapestry normally produces all the URLs it must later interpret, it 
doesn't make an effort to pretty this up (as it does with stale links and sessions), instead it throws 
an exception which is caught and displayed.
</para>
      <para>
As you may notice, the exception report is extremely complex.  Tapestry displays all the 
information it can about the exception that was thrown ... it can even break apart nested 
exceptions and dig down to the deepest one.  It shows the stack trace where the deepest 
exception was thrown.  It also provides information about the &HttpServletRequest;,
&HttpSession;, &ServletContext; and Java VM.
</para>
      <para>
Finally, it includes a link that will 
restart the application from scratch, invaliding the current &HttpSession; and
creating a new one as necessary.
</para>
    </section>
  </chapter>
  <!-- $Id$ -->
  <chapter id="hangman">
    <title>Poutpourri!</title>
    <para>
So far, these examples have been a little bit cut-and-dried.  Lets do a meatier example that uses a 
few more interesting components.  Let's play Hangman!
</para>
    <para>
Our Hangman application consists of four pages.  The Home page allows a new game to be 
started, which includes selecting the difficulty of the game (how many wrong guesses you are 
allowed).
</para>
    <figure>
      <title>Hangman Home Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/hangman-home.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para> 
The main page is the Guess page, where the partially filled out word is displayed, and the user can 
make guesses (from a shrinking list of possible letters):
</para>
    <figure>
      <title>Hangman Guess Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/hangman-guess.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
After you give up, or when you make too many mistakes, you end up on the the Failed page:
</para>
    <figure>
      <title>Hangman Failed Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/hangman-lose.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para> 
But, if you guess all the letters, you are sent to the Success page:
</para>
    <figure>
      <title>Hangman Success Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/hangman-win.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section id="hangman.visit">
      <title>The Visit Object</title>
      <para>
The center of this application is an object that represents game, an object of class 
<classname>HangmanGame</classname>. This object is used to track the word being guessed, 
the letters that have been 
used, the number of misses and the letters that have been correctly guessed.
</para>
      <para>
This object is a property of the <emphasis>visit</emphasis> object.  What's the visit object?  
The visit object is a holder of 
all information about a single client's visit to your web application.  It contains data and methods 
that are needed by the pages and components of your application.
</para>
      <para>
The visit object is owned and created by the engine object.  It is serialized and de-serialized with 
the engine.
</para>
      <para>
The application specification includes a little extra segment at the bottom to specify the class of 
the visit object.
</para>
      <figure>
        <title>Hangman.application</title>
        <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE application PUBLIC
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd"&gt;

&lt;application name="Tapestry Hangman" engine-class="com.primix.tapestry.engine.SimpleEngine"&gt; 

  &lt;property name="com.primix.tapestry.visit-class"&gt;tutorial.hangman.Visit&lt;/property&gt; <co id="hangman.app.visit"/>

  &lt;page name="Home" specification-path="/tutorial/hangman/Home.jwc"/&gt;

  &lt;page name="Guess" specification-path="/tutorial/hangman/Guess.jwc"/&gt;

  &lt;page name="Failed" specification-path="/tutorial/hangman/Failed.jwc"/&gt;

  &lt;page name="Success" specification-path="/tutorial/hangman/Success.jwc"/&gt;

&lt;/application&gt;    
</programlisting>
      </figure>
      <para>
        <calloutlist>
          <callout arearefs="hangman.app.visit">
            <para>
  This property specifies that the engine should instantiate an instance of
  <classname>tutorial.hangman.Visit</classname> when a visit object is first required.
  This is the default way in which the visit object is specified, though if
  the visit object doesn't have an empty constructor method, the engine method
  <function>createVisit()</function> must be implemented instead.
  </para>
          </callout>
        </calloutlist>
      </para>
      <para>
So, returning from that distraction, the game object is a property of the visit object, which is 
accessible from any page (via the page's visit property).
</para>
    </section>
    <section id="hangman.home-page">
      <title>The Home Page</title>
      <para>
The Home page's job is to collect the difficulty and initiate a game:
</para>
      <figure>
        <title>Home.java</title>
        <programlisting><![CDATA[
public class Home
extends BasePage
implements IActionListener
{
  public static final int EASY = 10;
  public static final int MEDIUM = 5;
  public static final int HARD = 3;

  private int misses;
  private String error;

  public void detach()
  {
    misses = 0;
    error = null;
      
    super.detach();
  }

  public int getMisses()
  {
    return misses;
  }

  public void setMisses(int value)
  {
    misses = value;

    fireObservedChange("misses", value);
  }

  public String getError()
  {
    return error;
  }

  public IActionListener getFormListener()
  {
    return this;
  }

  public void actionTriggered(IComponent component, IRequestCycle cycle)
  throws RequestCycleException
  {
    if (misses == 0)
    {
      error = "Please select a game difficulty.";
      return;
    }

    Visit visit = (Visit)getVisit();

    visit.start(misses);

    cycle.setPage("Guess");
  }

}]]></programlisting>
      </figure>
      <para>
We're seeing all the familiar ideas:  The 
<varname>misses</varname> property is a persistent page property (which means 
the page will "remember" the value previously selected by the user).
</para>
      <para>
We use a common trick for simple pages:  the page contains a single 
&Form; component, so we use 
the page itself as the form's listener, and have the page implement the 
&IActionListener; interface.  
</para>
      <para>
This saves a bit of code for creating an inner class as the form listener.
</para>
      <para>
Initially, we don't select a difficulty level, and the user can click "Play!" without selecting a value 
from the list, so we check that.
</para>
      <para>
Otherwise, we get the visit object and ask it to start a new game with the selected number of 
misses.  We then jump to the Guess page to start accepting guesses from the user.
</para>
      <para>
The interesting part of the Home page HTML template is the form:
</para>
      <figure>
        <title>Home.html (excerpt)</title>
        <programlisting><![CDATA[
<jwc id="form">

<jwc id="group">

<jwc id="ifError">
<font size=+2 color=red><jwc id="insertError"/></font>
</jwc>

<table>
  <tr>
    <td><jwc id="inputEasy"/></td>
    <td>Easy game; you are allowed ten misses.</td>
  </tr>

  <tr>
    <td><jwc id="inputMedium"/></td>
    <td>Medium game; you are allowed five misses.</td>
  </tr>

  <tr>
    <td><jwc id="inputHard"/></td>
    <td>Hard game; you are only allowed three misses.</td>
  </tr>

  <tr>
    <td></td>
    <td><input type="submit" value="Play!"></td>
  </tr>

</table>

</jwc>
</jwc>]]></programlisting>
      </figure>
      <para>
 Here, the interesting components are <varname>group</varname>, 
 <varname>inputEasy</varname>, <varname>inputMedium</varname> and <varname>inputHard</varname>.  
<varname>group</varname> is 
type &RadioGroup;, a wrapper that must go around the &Radio;
 components (the other three).  The 
&RadioGroup; determines what property of the page is to be read and updated 
(its bound to the 
<varname>misses</varname> property).  Each &Radio; button is associated with 
a particular value to be assigned to the 
property, when that radio button is selected by the user.
</para>
      <para>
This comes together in the Home page specification:
</para>
      <figure>
        <title>Home.jwc (excerpt)</title>
        <programlisting>
  &lt;component id="group" type="RadioGroup"&gt;
    &lt;binding name="selected" property-path="misses"/&gt;
  &lt;/component&gt;
  
  &lt;component id="inputEasy" type="Radio"&gt;
    &lt;field-binding name="value" field-name="tutorial.hangman.Home.EASY"/&gt; <co id="hangman.home.spec.field-binding"/>
  &lt;/component&gt;
  
  &lt;component id="inputMedium" type="Radio"&gt;
    &lt;field-binding name="value" field-name="tutorial.hangman.Home.MEDIUM"/&gt;
  &lt;/component&gt;
  
  &lt;component id="inputHard" type="Radio"&gt;
    &lt;field-binding name="value" field-name="tutorial.hangman.Home.HARD"/&gt;
  &lt;/component&gt;

</programlisting>
      </figure>
      <para>
        <calloutlist>
          <callout arearefs="hangman.home.spec.field-binding">
            <para>
  A <sgmltag class="starttag">field-binding</sgmltag> is like a
  <sgmltag class="starttag">static-binding</sgmltag>, except that
  the static value is taken from a public static field of
  some class.  This makes it easy to coordinate behaviors between
  the specification and the class.
  </para>
            <para>
This is a good thing, since if you decide to make a <varname>HARD</varname>
game only allow two mistakes, you can 
make the change in exactly one place .. your Java code.
</para>
          </callout>
        </calloutlist>
      </para>
      <para>
So the end result is: when the user clicks the radio button for a Hard game, the static constant 
<varname>HARD</varname> is assigned to the page's <varname>misses</varname> property.
</para>
    </section>
    <section id="hangman.guess-page">
      <title>The Guess Page</title>
      <para>
This is the page where uses make letter guesses.  The page has four sections:
</para>
      <itemizedlist>
        <listitem>
          <para>
        A display of the word, with underscores replacing unguessed letters.
        </para>
        </listitem>
        <listitem>
          <para>
        A status area, showing the number of bad guesses and an optional error message after an 
    invalid guess.
        </para>
        </listitem>
        <listitem>
          <para>
        A list of letters that may be guessed.  Letters disappear after they are used.
        </para>
        </listitem>
        <listitem>
          <para>
        An option to give up and see the word, terminating the game.
        </para>
        </listitem>
      </itemizedlist>
      <para>
Let's start with the HTML template this time:
</para>
      <figure>
        <title>Guess.html (excerpt)</title>
        <programlisting><![CDATA[<h1>Make a Guess</h1>

<font size=+3>
  <jwc id="insertGuess"/>
</font>

<p>

You have made <jwc id="insertMissed"/> bad guesses,
out of a maximum of <jwc id="insertMaxMisses"/>.

<jwc id="ifError">
<p>
<font size=+3 color=red><jwc id="insertError"/></font>
</jwc>

<p>Guess:
<font size=+1>
<jwc id="e">
<jwc id="guess"><jwc id="insertLetter"/></jwc>
</jwc>
</font>

<p><jwc id="giveUp">Give up?</jwc>
]]></programlisting>
      </figure>
      <para> 
Most of these components should be fairly obvious by now; let's focus on the components that 
allow the user to guess a letter.  This could have been implemented in a number of ways  using 
more radio buttons, a drop down list or a text field the user could type into.  In this example, we 
chose to simply create a series of links, one for each letter the user may still guess.
</para>
      <para>
Let's look at the specification for those three components (<varname>e</varname>, 
<varname>guess</varname> and <varname>insertLetter</varname>).
</para>
      <figure>
        <title>Guess.jwc (excerpt)</title>
        <programlisting>
&lt;component id="e" type="Foreach"&gt;
  &lt;binding name="source" property-path="unused"/&gt;
&lt;/component&gt;

&lt;component id="guess" type="Direct"&gt;
  &lt;binding name="listener" property-path="guessListener"/&gt;
  &lt;binding name="context" property-path="components.e.value"/&gt;
&lt;/component&gt;

&lt;component id="insertLetter" type="Insert"&gt;
  &lt;binding name="value" property-path="components.e.value"/&gt;
&lt;/component&gt;
</programlisting>
      </figure>
      <para> 
Component <varname>e</varname> is simply a &Foreach;, 
the <varname>source</varname> is the <varname>unused</varname> property of the page (we'll see in a 
moment how the page gets this list of unused letters from the game object).
</para>
      <para>
Component <varname>insertLetter</varname> inserts the current letter from the list of unused letters.  
It gets this current letter directly from the <varname>e</varname> component.  
On successive iterations, a &Foreach; component's 
<varname>value</varname> property is the value for the iteration.
</para>
      <para>
Component <varname>guess</varname> is type &Direct;, which creates a 
hyperlink on the page and notifies its listener 
when the user clicks the link.  Just knowing that the component was clicked isn't very helpful 
though;  the application needs to know which letter was actually clicked.
</para>
      <para>
Passing that kind of information along is accomplished by setting the 
<varname>context</varname> parameter for the 
component.  The <varname>context</varname> parameter is a &String;, or array of 
&String;s, that will be encoded into the 
URL for the hyperlink.  When the component's listener is notified, it is passed the same 
&String;s.
</para>
      <para>
The context is often used to encode primary keys of objects, names of columns or other 
information specific to the application.
</para>
      <para>
In this case, the context is simply the letter to be guessed.
</para>
      <para>
All of this comes together in the Java code for the Guess page.
</para>
      <figure>
        <title>Guess.java (excerpt)</title>
        <programlisting><![CDATA[
public IDirectListener getGuessListener()
{
  return new IDirectListener()
  {
    public void directTriggered(IDirect direct,
                String[] context, IRequestCycle cycle)
    throws RequestCycleException
    {
      makeGuess(context[0], cycle);
    }
  };
}

private void makeGuess(String guess, IRequestCycle cycle)
throws RequestCycleException
{
  HangmanGame game = getGame();
  char letter = guess.charAt(0);

  try
  {
    game.guess(letter);
  }
  catch (GameException ex)
  {
    error = ex.getMessage();

    if (game.getFailed())
    cycle.setPage("Failed");

    return;
  }

  // A good guess.

  if (game.getDone())
    cycle.setPage("Success");
  }
}
]]></programlisting>
      </figure>
      <para> 
So the <varname>listener</varname> for the 
<varname>guess</varname> component gets the first &String; in the context and invokes the 
<function>makeGuess()</function> method.  We pass the guessed letter to the game object which throws a 
GameException if the guess is invalid.
</para>
      <para>
The method <function>HangmanGame.getFailed()</function> returns 
<literal>true</literal> when all the missed guesses are used up, at 
which point we go to the <varname>Failed</varname> page to tell the user what the word was.
</para>
      <para>
On the other hand, if an exception isn't thrown, then the guess was good.  
<function>getDone()</function> returns <literal>true</literal>
if all letters have been guessed, in which go to the <varname>Success</varname> page.
</para>
      <para>
If all letters weren't guessed, we stay on the <varname>Guess</varname> page, 
which will display the word with the 
guessed letter filled in, and with fewer options in the list of possible guesses.
</para>
    </section>
    <section id="hangman.limitations">
      <title>Limitations</title>
      <para>
This is a very, very simple implementation of the game.  For example, it's easy to cheat; you can 
give up, then use your browser's back button to return to the <varname>Guess</varname>
page and keep guessing (with accuracy, if your memory is any good).
</para>
    </section>
  </chapter>
  <chapter id="reuse">
    <title>Creating Reusable Components</title>
    <para>
In this tutorial, we'll show how to create a reusable component.  One common use of components 
it to create a common "border" for the application that includes basic navigation.  We'll be 
creating a simple, three page application with a navigation bar down the left side.
</para>
    <figure>
      <title>Border Home Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/border-home.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para> 
Navigating to another page results in a similar display:
</para>
    <figure>
      <title>Border Credo Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/border-credo.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para> 
Each page's content is confined to the silver area in the center.  Note that the border adapts itself 
to each page:  the title "Home" or "Credo" is specific to the page, and the current page doesn't 
have an active link (in the above page, "Credo" is the current page, so only "Home" and "Legal" 
are usable as navigation links).
</para>
    <para>
The "i" in the circle is the Show Inspector link.  It will be described in the next chapter.
</para>
    <para>
Because this tutorial is somewhat large, we'll only be showing excerpts from some of the files.  
The complete source of the tutorial examples is available seperately, in the 
<classname>tutorial.border</classname> package.
</para>
    <para>
Each of the three pages has a similar HTML template:
</para>
    <figure>
      <title>Home.html</title>
      <programlisting><![CDATA[
<jwc id="border">

Nothing much doing here on the <b>home</b> page.  Visit one of our other 
fine 
pages.

</jwc>]]></programlisting>
    </figure>
    <para> 
Remember that Tapestry components can wrap around other HTML elements or components.  
For the border, we have an HTML template where everything on the page is wrapped by the 
<varname>border</varname> component.
</para>
    <para>
Note that we don't specify any
<sgmltag class="starttag">html</sgmltag> or 
<sgmltag class="starttag">body</sgmltag> tags; those are provided by the <classname>Border</classname>
component (as well as the matching close tags).
</para>
    <para>
This illustrates a key concept within Tapestry:  embedding vs. wrapping.  The 
<classname>Home</classname> page embeds 
the <varname>border</varname> component (as we'll see in the <classname>Home</classname> page's specification).  
This means that the <classname>Home</classname>
page is implemented using the <varname>border</varname> component.
</para>
    <para>
However, the <varname>border</varname> component wraps the content of the <classname>Home</classname> page,
the <classname>Home</classname> page 
HTML template indicates the <emphasis>order</emphasis> in which components (and static HTML elements) are  
renderred.  On the <classname>Home</classname> page, the <varname>border</varname> component 'bats' first and cleanup.
</para>
    <para>
The construction of the <classname>Border</classname> component is driven by how it differs from page to page.  
You'll 
see that on each page, the title (in the upper left corner) changes.  The names of all three pages are 
displayed, but only two of the three will have links (the third, the current page, is just text).  
Lastly,  each page contains the specific content from its own HTML template.
</para>
    <figure>
      <title>Border.html</title>
      <programlisting>
&lt;jwc id="shell"&gt; <co id="reuse.border.shell"/>
&lt;jwc id="body"&gt; <co id="reuse.border.body"/>
&lt;table border=0 bgcolor=gray cellspacing=0 cellpadding=4&gt;
  &lt;tr valign=top&gt;
    &lt;td colspan=3 align=left&gt;
      &lt;font size=5 color="White"&gt;&lt;jwc id="insertPageTitle"/&gt;&lt;/font&gt; 
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=top&gt;
    &lt;td align=right&gt;
      &lt;font color=white&gt;
&lt;jwc id="e"&gt; <co id="reuse.border.e"/>
        &lt;br&gt;&lt;jwc id="link"&gt;&lt;jwc id="insertName"/&gt;&lt;/jwc&gt; <co id="reuse.border.insertName"/>
&lt;/jwc&gt;
      &lt;/font&gt;
    &lt;/td&gt;
    &lt;td rowspan=2 valign=top bgcolor=silver&gt;
      &lt;jwc id="wrapped"/&gt; <co id="reuse.border.wrapped"/>
    &lt;/td&gt;
    &lt;td rowspan=2 width=4&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
	&lt;td&gt;&lt;jwc id="showInspector"/&gt;&lt;/td&gt; <co id="reuse.border.showInspector"/>
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td colspan=3 height=4&gt;&nbsp;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/jwc&gt;
&lt;/jwc&gt;
</programlisting>
    </figure>
    <para>
      <calloutlist>
        <callout arearefs="reuse.border.shell">
          <para>
	 The <varname>shell</varname> component provides the <sgmltag class="starttag">html</sgmltag> and
	 <sgmltag class="starttag">head</sgmltag> elements of the response HTML.
	 </para>
        </callout>
        <callout arearefs="reuse.border.body">
          <para>
	 The <varname>body</varname> components provides the <sgmltag class="starttag">body</sgmltag> element.
	 It also provides support for JavaScript related to &Rollover; buttons, such as
	 the <varname>showInspector</varname> component.
	 </para>
        </callout>
        <callout arearefs="reuse.border.e">
          <para>
	 The <varname>e</varname> component is a &Foreach; configured to work through
	 a list of page names (provided by the engine).
	 </para>
        </callout>
        <callout arearefs="reuse.border.insertName">
          <para>	 
The <varname>link</varname> and <varname>insertName</varname>
components provide the inter-page navigation links.  
</para>
        </callout>
        <callout arearefs="reuse.border.wrapped">
          <para>
The <varname>wrapped</varname> component provides the actual content for the page.  The
<classname>Border</classname> component is used on all three pages, but its a different
instance on each page, wrapping around different content specific to the page.
</para>
        </callout>
        <callout arearefs="reuse.border.showInspector">
          <para>
The <varname>showInspector</varname> component provides the button below the 
page names (the italicized "i" in a 
circle) and will be explained shortly.  
</para>
        </callout>
      </calloutlist>
    </para>
    <para>
The <classname>Border</classname> component is designed to be usable in other Tapestry 
applications, so it doesn't hard 
code the list of page names.  These must be provided to the component as a parameter. 
In fact, the 
application engine provides the list.
</para>
    <figure>
      <title>Border specification</title>
      <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE specification PUBLIC
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd"&gt;
  
&lt;specification class="tutorial.border.Border" allow-informal-parameters="no"&gt;
  
  &lt;parameter name="title" java-type="java.lang.String" required="yes"/&gt; <co id="reuse.border.spec.title"/>
  
  &lt;parameter name="pages" required="yes"/&gt; <co id="reuse.border.spec.pages"/>
  
  &lt;component id="shell" type="Shell"&gt;
    &lt;binding name="title" property-path="page.engine.specification.name"/&gt; <co id="reuse.border.spec.shell-title"/>
  &lt;/component&gt;
  
  &lt;component id="insertPageTitle" type="Insert"&gt;
    &lt;inherited-binding name="value" parameter-name="title"/&gt; <co id="reuse.border.spec.insertPageTitle"/>
  &lt;/component&gt;
  
  &lt;component id="body" type="Body"/&gt;
  
  &lt;component id="e" type="Foreach"&gt; <co id="reuse.border.spec.e"/>
    &lt;inherited-binding name="source" parameter-name="pages"/&gt;
    &lt;binding name="value" property-path="pageName"/&gt;
  &lt;/component&gt;
  
  &lt;component id="link" type="Page"&gt; <co id="reuse.border.spec.link"/>
    &lt;binding name="page" property-path="pageName"/&gt;
    &lt;binding name="disabled" property-path="disablePageLink"/&gt;
  &lt;/component&gt;
  
  &lt;component id="insertName" type="Insert"&gt;
    &lt;binding name="value" property-path="pageName"/&gt;
  &lt;/component&gt;
  
  &lt;component id="wrapped" type="InsertWrapped"/&gt;
  
  &lt;component id="showInspector" type="ShowInspector"/&gt; <co id="resuse.border.spec.showInspector"/>
&lt;/specification&gt;
</programlisting>
    </figure>
    <para>
      <calloutlist>
        <callout arearefs="reuse.border.spec.title">
          <para>
Declares a required parameter for the border, the title that will appear on the 
page.
</para>
        </callout>
        <callout arearefs="reuse.border.spec.pages">
          <para>
Declares a parameter to specify the list of page names.  We don't specify a
particular type because its pretty unbounded; the framework will accept
&List;, &Iterator; or a Java array.
</para>
        </callout>
        <callout arearefs="reuse.border.spec.shell-title">
          <para>
We then provide the <varname>shell</varname> component with its <varname>title</varname> parameter; 
this will be the window title.  We 
use the application's name, with is extracted from the application's specification.
</para>
        </callout>
        <callout arearefs="reuse.border.spec.insertPageTitle">
          <para>
The <sgmltag class="starttag">inherited-binding</sgmltag> element allows a component to
share its parameters.  Here the <classname>Border</classname>'s <varname>title</varname>
is used as the <varname>value</varname> parameter of the <varname>insertPageTitle</varname> 
component (an &Insert;).
Using these 
inherited bindings simplifies the process of creating complex components from simple ones.
</para>
        </callout>
        <callout arearefs="reuse.border.spec.e">
          <para>
Likewise, the <varname>e</varname> component (a &Foreach;) 
needs as its source the list of pages, which it inherits from 
the <classname>Border</classname> component's <varname>pages</varname> parameter.  
It has been configured to store each succesive page 
name into the <varname>pageName</varname> property of the <classname>Border</classname> component; 
this is necessary so that the <classname>Border</classname>
component can determine which page link to disable (it disables the current page since we're 
already there).
</para>
        </callout>
        <callout arearefs="reuse.border.spec.link">
          <para>
The <varname>link</varname> component creates the link to the other pages.  It has a
<varname>disabled</varname> parameter; which, 
when true, causes the link component to not create the hyperlink (though it still allows the 
elements it wraps to render).  The Java class for the <classname>Border</classname> component, 
<classname>tutorial.border.Border</classname>, provides a method, <function>getDisablePageLink()</function>, 
that returns true 
when the <varname>pageName</varname> instance variable (set by the <varname>e</varname> component) 
matches the current page's name.
</para>
        </callout>
        <callout arearefs="resuse.border.spec.showInspector">
          <para>
The <varname>showInspector</varname> component creates a rollover button (the "i" lights up when the mouse is 
moved over it):
</para>
        </callout>
      </calloutlist>
    </para>
    <para> 
So, the specification for the <classname>Border</classname> component must identify the 
parameters it needs, but also the 
components it uses and how they are configured.
</para>
    <figure>
      <title>Show Inspector Button</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/show-inspector.gif" format="GIF"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
Clicking on the button raises a second window that describes the current page in the application 
(this is used when debugging a Tapestry applicaton).  The Inspector is described in the next 
chapter.
</para>
    <para>
The final mystery is the <varname>wrapped</varname> component.  It is used to render the elements wrapped by the 
<classname>Border</classname> on the page containing the <classname>Border</classname>. 
Those elements  will vary from page to page; running 
the application shows that they are different on the home, credo and legal pages (different text 
appears in the central light-grey box).  There is no limitation on the elements either:  Tapestry is 
specifically designed to allow components to wrap other components in this way, without any 
arbitrary limitations.
</para>
    <para>
This means that the different pages could contain forms, images or any set of components at all, 
not just static HTML text.
</para>
    <para>
The specification for the home page shows how the title and pages parameters are set.  The title is 
static, the literal value "Home" (this isn't the best approach if localization is a concern).
</para>
    <figure>
      <title>Home page specification</title>
      <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE specification PUBLIC
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd"&gt;

&lt;specification class="com.primix.tapestry.BasePage"&gt;

  &lt;component id="border" type="Border"&gt;
    &lt;static-binding name="title"&gt;Home&lt;/static-binding&gt;
    &lt;binding name="pages" property-path="engine.pageNames"/&gt;
  &lt;/component&gt;

&lt;/specification&gt;
</programlisting>
    </figure>
    <para>  
The <varname>pages</varname> property is retrieved from the application engine, 
which implements a <varname>pageNames</varname> JavaBeans property:
</para>
    <figure>
      <title>BorderEngine.java (excerpt)</title>
      <programlisting><![CDATA[  
  private static final String[] pageNames =
    { "Home", "Credo", "Legal" };

  public String[] getPageNames()
  {
    return pageNames;
  }
]]></programlisting>
    </figure>
    <para>
How did Tapestry know that the type 'Border' 
corresponded to the specification <filename>/tutorial/border/Border.jwc</filename>?  Only because we defined 
an alias in the application specification:
</para>
    <figure>
      <title>Border.application (excerpt)</title>
      <programlisting>
  &lt;component-alias type="Border" specification-path="/tutorial/border/Border.jwc"/&gt;
</programlisting>
    </figure>
    <para> 
Had we failed to do this, we would have had to specify the complete resource path, 
<filename>/tutorial/border/Border.jwc</filename>, on each page's specification, instead of the short alias 
'Border'.  There is no magic about the existing Tapestry component types 
(&Insert;, &Foreach;, &Page;, etc. ... they each have an 
alias pre-registered into every application specification.  These short 
aliases are simply a convienience.
</para>
  </chapter>
  <chapter id="inspector">
    <title>The Tapestry Inspector</title>
    <para>
Unlike scripting systems (such as JavaServer Pages and the like), Tapestry applications are gifted 
with a huge amount of information about how they are implemented. The same component 
object model that allows Tapestry to perform so many ordinary functions can be leveraged to 
provide some unusual functionality.
</para>
    <para>
Run the Border tutorial from the previous chapter and click on the show inspector button (the 
gear icon in the lower right corner).  A new window will launch, containing the Inspector:
</para>
    <figure>
      <title>Tapestry Inspector</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Inspector-Spec.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
The Inspector displays live information from the running application; in fact, it is simply another 
part of the application (the drop-down list of pages will include the Inspector page itself).  The 
Inspector is most often used to debug HTML generation by viewing the HTML templates.
It is also very useful in debugging problems where the wrong data is displayed, since it 
allows the developer to navigate to the particular components and see directly what properties
are used.
</para>
    <section id="inspector.navigation">
      <title>Navigation</title>
      <para>
The inspector allows the user to navigate to any page and any component on a page.
The drop down list in the upper left corner lists all pages in the application; changing
the selection immediately updates the Inspector.
</para>
      <para>Next to the drop down list is the component path; a list of nested component ids, starting
with "page" to represent the page.  Clicking on any id in the path changes the information displayed
below.
</para>
      <para>
Underneath the component navigation tools are a set of tab buttons for the different
inspector views.
</para>
    </section>
    <section id="inspector.specification">
      <title>Specification View</title>
      <figure>
        <title>Specification View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Spec.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The specification view shows several sets of information about the selected component.
</para>
      <para>
First shown are basic properties, such as the specification path and Java class.
</para>
      <para>
Each formal parameter is displayed.  Unbound parameters will show no value in
the Binding column.
</para>
      <para>
Beneath formal parameters are informal parameters (the <classname>Border</classname>
component has none, so there is nothing to see).  Informal parameters are
usually mapped directly to HTML attributes.  They are most often used with
components that generate a single HTML tag, such as the &Action;,
&Direct; or &TextField; components.
</para>
      <para>
If the component contains assets, they are shown next.
</para>
      <para>
Any helper beans for the component are displayed last.
</para>
      <para>
On the right side is a list of each embedded component and its type.  Clicking
the component id will navigate to the selected component.
</para>
    </section>
    <section id="inspector.template">
      <title>Template View</title>
      <figure>
        <title>Template View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Template.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The template view shows the HTML template for the component.  It shows dynamic tags in bold,
and makes the component id a clickable link (which navigates to the component, but maintains
the Template View).  This allows the developer to quickly drill down through the components.
</para>
    </section>
    <section id="inspector.properties">
      <title>Properties View</title>
      <figure>
        <title>Properties View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Properties.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The properties view shows persistant properties stored by the page (or any components on
the page).  Most pages do not store any persistent state (it is more often stored
in the application's visit object).
</para>
    </section>
    <section id="inspector.engine">
      <title>Engine View</title>
      <figure>
        <title>Engine View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Engine.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The engine view shows information about the running application engine, as well as some details
from the application specification.
</para>
      <para>
Under Operations are two buttons:  the first restarts the application.  The 
second (when enabled
	<footnote>
          <para>
		By default, the reset service (used by the reset button) is disabled.  
		To enable it, set the JVM system property
		<varname>com.primix.tapestry.enable-reset-service</varname> to true.
		The service is disabled since it is too tempting a target for a denial
		of service attack.
		</para>
        </footnote>) resets the application, which forces a reload of all component specifications
and HTML templates.  This is useful during development, since it allows for incremental development
without stopping and restarting the servlet container.
</para>
      <para>
Below the operations is a binary dump of the application engine.  This is useful when
developing to see how large the serialized state is, and perhaps gleam how it might be trimmed.
</para>
      <para>
Further below (and not visible in the screen shot above), is a dump of the request context.  This
is that vast amount of data also displayed when an unexpected exception is thrown.
</para>
    </section>
    <section id="inspector.logging">
      <title>Logging View</title>
      <figure>
        <title>Logging View (Level Selection)</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Inspector-Logging.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
The Logging view allows dynamic integration with the 
<ulink url="http://jakarta.apache.org/log4j">Log4J</ulink> logging framework.  The top half
of the page allows the logging level of any category to be
dynamically set.  This is useful when debugging, since logging output for specific
classes
	<footnote>
          <para>
			By convention, logging categories match the complete class name
			of the corresponding class.  All Tapestry logging categories
			conform to this convention.
		</para>
        </footnote>
can be individually enabled or disable.
</para>
      <para>
The right side is a small second form, allowing new categories to be created.
This can be useful to make broad changes in logging levels.  For instance, creating
a category "com.primix.tapestry" would allow the logging level of all Tapestry classes to be
set in a single place.
</para>
    </section>
  </chapter>
  <chapter id="forms">
    <title>Complex Forms and Output</title>
    <para>
Tapestry includes a number of components designed to simplify interactions with the client, 
especially when handling forms.
</para>
    <para>
In this chapter, we'll build a survey-taking application that collects information from the user, 
stores it in an in-memory database, and produces tabular results summarizing what has been 
entered.
</para>
    <para>
We'll see how to validate input from the client, how to create radio groups and pop-up selections 
and how to organize information for display.
</para>
    <para>
The application has three main screens; the first is a home page:
</para>
    <figure>
      <title>Surver Home Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/survey-home.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
The second page is for entering survey data:
</para>
    <figure>
      <title>Survey Data Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/survey-form.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
The last page is used to present results collected from many surveys:
</para>
    <figure>
      <title>Survey Results Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/survey-results.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para> 
In addition, we are re-using the <classname>Border</classname> component from the previous chapter.
</para>
    <para>
The application does not use an actual database; the survey information is stored in memory (the 
amount of work to set up a JDBC database is beyond the scope of this tutorial).  
</para>
    <para>
The source code for this chapter is in the <filename>tutorial.survey</filename> package.
</para>
    <section id="forms.survey">
      <title>Survey</title>
      <para>
At the root of this application is an object that represents a survey taken by a user. We want to 
collect the name (which is optional), the sex and the race, the age and lastly, which pets the survey 
taker prefers.
</para>
      <figure>
        <title>Survey.java</title>
        <programlisting><![CDATA[
package tutorial.survey;

import java.util.*;
import com.primix.tapestry.*;
import java.io.*;

public class Survey implements Serializable, Cloneable
{
  private Object primaryKey;
  private String name;
  private int age = 0;
  private Sex sex = Sex.MALE;
  private Race race = Race.CAUCASIAN;
  
  private boolean likesDogs = true;
  private boolean likesCats;
  private boolean likesFerrits;
  private boolean likesTurnips;
  
  public Object getPrimaryKey()
  {
    return primaryKey;
  }
  
  public void setPrimaryKey(Object value)
  {
    primaryKey = value;
  }
  
  public String getName()
  {
    return name;
  }
  
  public void setName(String value)
  {
    name = value;
  }
  
  public int getAge()
  {
    return age;
  }
  
  public void setAge(int value)
  {
    age = value;
  }
   
  public void setSex(Sex value)
  {
    sex = value;
  }
  
  public Sex getSex()
  {
    return sex;
  }
  
  public void setRace(Race value)
  {
    race = value;
  }
  
  public Race getRace()
  {
    return race;
  }
  
  public boolean getLikesCats()
  {
    return likesCats;
  }

  public void setLikesCats(boolean value)
  {
    likesCats = value;
  }
  
  public boolean getLikesDogs()
  {
    return likesDogs;
  }
  
  public void setLikesDogs(boolean value)
  {
    likesDogs = value;
  }
  
  public boolean getLikesFerrits()
  {
    return likesFerrits;
  }
  
  public void setLikesFerrits(boolean value)
  {
    likesFerrits = value;
  }
  
  public boolean getLikesTurnips()
  {
    return likesTurnips;
  }
  
  public void setLikesTurnips(boolean value)
  {
    likesTurnips = value;
  }
  
  /**
   *  Validates that the survey is acceptible; throws an {@link 
IllegalArgumentException}
   *  if not valid.
   *
   */
   
  public void validate()
  throws IllegalArgumentException
  {
    if (race == null)
      throw new IllegalArgumentException("Race must be 
specified.");
    
    if (sex == null)
      throw new IllegalArgumentException("Sex must be 
specified.");
      
    if (age < 1)
      throw new IllegalArgumentException("Age must be at least 
one.");
  }  
  
  public Object clone()
  {
    try
    {
      return super.clone(); 
    }
    catch (CloneNotSupportedException e)
    {
      return null;
    }
  }
}]]></programlisting>
      </figure>
      <para> 
The <varname>race</varname> and <varname>sex</varname> properties are defined in terms of the 
<classname>Race</classname> and <classname>Sex</classname> classes, which are derived 
from &Enum;.  &Enum; classes act like 
C enum types; a specific number of 
pre-defined values are declared by the class (as static final constants of the class).
</para>
      <figure>
        <title>Race.java</title>
        <programlisting><![CDATA[
package tutorial.survey;

import com.primix.foundation.Enum;

/**
 *  An enumeration of different races.
 *
 */
 
public class Race extends Enum
{
  public static final Race CAUCASIAN = new Race("CAUCASIAN");
  public static final Race AFRICAN = new Race("AFRICAN");
  public static final Race ASIAN = new Race("ASIAN");
  public static final Race INUIT = new Race("INUIT");
  public static final Race MARTIAN = new Race("MARTIAN");

  private Race(String enumerationId)
  {
    super(enumerationId);
  }

  private Object readResolve()
  {
    return getSingleton();
  }

}]]></programlisting>
      </figure>
      <para> 
This is better than using &String; or <classname>int</classname> constants because 
of type safety; the Java compiler will 
notice if you pass <classname>Race.INUIT</classname> as a parameter that expects an instance of 
<classname>Sex</classname> ... if they were both 
encoded as numbers, the compiler wouldn't know that there was a programming error.
</para>
    </section>
    <section id="forms.surveydatabase">
      <title>SurveyDatabase</title>
      <para>
The <classname>SurveyDatabase</classname> class is a mockup of a database for storing 
<classname>Survey</classname>s, it has methods such as 
<function>addSurvey()</function> and <function>getAllSurveys()</function>.  
To emulate a database, it even allocates primary keys for 
surveys.  Additionally, when surveys are added to the database, they are copied and when surveys 
are retrieved from the database, they are copied (that is, modifying a 
<classname>Survey</classname> instance after adding 
it to, or retrieving it from, the database doesn't affect the persistently stored 
<classname>Surveys</classname> within the 
database ... just as if they were in external storage).
</para>
    </section>
    <section id="forms.surveyengine">
      <title>SurveyEngine</title>
      <para>
The database is accessed via the <classname>SurveyEngine</classname> object.
</para>
      <figure>
        <title>SurveyEngine.java (excerpt)</title>
        <programlisting><![CDATA[

  private transient SurveyDatabase database;

  public SurveyDatabase getDatabase()
  {
    return database;
  }
  
  protected void setupForRequest(RequestContext context)
  {
    super.setupForRequest(context);
    
    if (database == null)
    {
      String name = "Survey.database";
      ServletContext servletContext;
      
      servletContext = context.getServlet().getServletContext();
      
      database = (SurveyDatabase)servletContext.getAttribute(name);
      
      if (database == null)
      {
        database = new SurveyDatabase();
        servletContext.setAttribute(name, database);
      }
    }
  }
]]></programlisting>
      </figure>
      <para> 
The <classname>SurveyDatabase</classname> instance is stored as a 
named attribute of the &ServletContext;, a shared space 
available to all sessions.
</para>
    </section>
    <section id="forms.surveypage">
      <title>SurveyPage</title>
      <para>
The <classname>SurveyPage</classname> is where survey information is collected.  It initially creates 
a <classname>Survey</classname> instance as 
a persistent page property.  It uses a &Form; component
and a number of other components to edit the survey.
</para>
      <para>
When the survey is complete and valid, it is added to the database and the results page is used as 
an acknowledgment.
</para>
      <para>
The SurveyPage also demonstrates how to validate data from a TextField component<footnote>
          <para>
		Since this tutorial was written, a suite of more powerful components for
		validating input have been added to the Tapestry framework.
	</para>
        </footnote>, and how to 
display validation errors.  If invalid data is enterred, then the user is notified (after submitting the 
form):
</para>
      <figure>
        <title>Surver Form (w/ error)</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/survey-form-error.jpg" format="JPEG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para> 
The HTML template for the page is relatively short.  All the interesting stuff comes later, in the 
specification and the Java class.
</para>
      <figure>
        <title>SurveyPage.html</title>
        <programlisting><![CDATA[
<jwc id="border">

<jwc id="ifError">
<table border=1>
<tr>
<td bgcolor=red>
<font style=bold color=white>
<jwc id="insertError"/>
</font> </tr> </tr> </table>
</jwc>

<jwc id="surveyForm">

<table border=0>

<tr valign=top> <th>Name</th>
	 <td colspan=3><jwc id="inputName"/></td></tr>

<tr valign=top>  <th>Age</th>
	 <td colspan=3><jwc id="inputAge"/></td></tr>

<tr valign=top> <th>Sex</th>
	  <td> <jwc id="inputSex"/>  
	  </td>

	  <th>Race</th>

      <td><jwc id="inputRace"/>
      </td> </tr>

<tr valign=top> <th>Favorite Pets</th>
	<td colspan=3>
	<jwc id="inputCats"/> Cats
<br><jwc id="inputDogs"/> Dogs
<br><jwc id="inputFerrits"/> Ferrits
<br><jwc id="inputTurnips"/> Turnips</td> </tr>
<tr>
<td></td>
<td colspan=3><input type=submit value="Submit"></td> </tr>
</table>

</jwc>
</jwc>]]></programlisting>
      </figure>
      <para> 
Most of this page is wrapped by the 
<varname>surveyForm</varname> component which is of type &Form;.  The form 
contains two text fields (<varname>nameField</varname> and <varname>ageField</varname>),
a group of radio buttons (<varname>ageSelect</varname>) a pop-
up list (<varname>raceSelect</varname>), and a number of check boxes (<varname>inputCats</varname>,
<varname>inputDogs</varname>, <varname>inputFerrits</varname> and <varname>inputTurnips</varname>).
</para>
      <para>
Most of these components are pretty straight forward:  <varname>nameField</varname> 
and <varname>ageField</varname> are setting &String;
properties, and the check boxes are setting boolean properties.  The two other components, 
<varname>raceSelect</varname> and <varname>ageSelect</varname>, are more interesting.
</para>
      <para>
Both of these are of type &PropertySelection; they are used for 
setting a specific property of some 
object to one of a number of possible values.
</para>
      <para>
The &PropertySelection; component has some difficult tasks:  It must 
know what the possible 
values are (including the correct order).  It must also know how to display the values (that is, what 
labels to use on the radio buttons or in the pop up).  These will often not be the same value; 
for instance, in a database-driven application, the values may be primary keys and the labels
may be attributes of database objects.
</para>
      <para>
This information is provided by a model (an object that implements the interface 
&IPropertySelectionModel;), 
an object 
that exists just to provide this information to a &PropertySelection; component.
</para>
      <para>
There's a secondary question with &PropertySelection;: how the component is rendered.  
By default, 
it creates a pop-up list, but this can be changed by providing an alternate renderer (using the 
component's renderer parameter).  A rendered is an object that generates HTML from the component and
its model.  In our case, we used a secondary, radio-button renderer.  
</para>
      <para>
Applications can also create their own renderers, if they need to do something special with fonts, 
styles or images.
</para>
      <para>
All of these concepts come together in the SurveyPage specification:
</para>
      <figure>
        <title>SurveyPage.jwc</title>
        <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE specification PUBLIC
  "-//Howard Ship//Tapestry Specification 1.1//EN"
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">

<specification class="tutorial.survey.SurveyPage">

  <component id="border" type="Border">
    <static-binding name="title">Survey</static-binding>
    <binding name="pages" property-path="engine.pageNames"/>
  </component>
  
  <component id="ifError" type="Conditional">
    <binding name="condition" property-path="error"/>
  </component>
  
  <component id="insertError" type="Insert">
    <binding name="value" property-path="error"/>
  </component>
  
  <component id="surveyForm" type="Form">
    <binding name="listener" property-path="formListener"/>
  </component>
  
  <component id="inputName" type="TextField">
    <static-binding name="displayWidth">30</static-binding>
    <static-binding name="maximumLength">100</static-binding>
    <binding name="text" property-path="survey.name"/>
  </component>
  
  <component id="inputAge" type="TextField">
    <static-binding name="displayWidth">4</static-binding>
    <static-binding name="maximumLength">4</static-binding>
    <binding name="text" property-path="age"/>
  </component>
  
  <component id="inputSex" type="PropertySelection">
    <binding name="value" property-path="survey.sex"/>
    <binding name="model" property-path="sexModel"/>
    <binding name="renderer" property-path="components.inputSex.defaultRadioRenderer"/>
  </component>
  
  <component id="inputRace" type="PropertySelection">
    <binding name="value" property-path="survey.race"/>
    <binding name="model" property-path="raceModel"/>
  </component>
  
  <component id="inputCats" type="Checkbox">
    <binding name="selected" property-path="survey.likesCats"/>
  </component>
  
  <component id="inputDogs" type="Checkbox">
    <binding name="selected" property-path="survey.likesDogs"/>
  </component>
  
  <component id="inputFerrits" type="Checkbox">
    <binding name="selected" property-path="survey.likesFerrits"/>
  </component>
  
  <component id="inputTurnips" type="Checkbox">
    <binding name="selected" property-path="survey.likesTurnips"/>
  </component>
  
</specification>
]]></programlisting>
      </figure>
      <para>
Several of the components, such as 
<varname>inputName</varname> and <varname>inputTurnips</varname>, modify properties of the 
<classname>Survey</classname>
directly.  The <classname>SurveyPage</classname> class has a <varname>survey</varname> property, 
which allows for property paths like 
<varname>survey.name</varname> and <varname>survey.likesTurnips</varname>.
</para>
      <para>
The <varname>age</varname> field is more complicated, since it must be converted from a 
&String; to an int before being 
assigned to the survey's <varname>age</varname> property ... and the page must check that 
the user enterred a valid 
number as well.
</para>
      <para>
Finally, the <classname>SurveyPage</classname> class shows how all the details fit together:
</para>
      <figure>
        <title>SurveyPage.java</title>
        <programlisting><![CDATA[
package tutorial.survey;

import com.primix.tapestry.*;
import com.primix.tapestry.components.html.form.*;
import java.util.*;

public class SurveyPage extends BasePage
{
  private Survey survey;
  private String error;
  private String age;
  private IPropertySelectionModel sexModel;
  private IPropertySelectionModel raceModel;
  
  public IPropertySelectionModel getRaceModel()
  {
    if (raceModel == null)
      raceModel = new EnumPropertySelectionModel(
        new Race[] 
        {
          Race.CAUCASIAN, Race.AFRICAN, Race.ASIAN, 
Race.INUIT, Race.MARTIAN
        },  getBundle("tutorial.survey.SurveyStrings"), 
"Race");
        
    return raceModel;
  }
    
  public IPropertySelectionModel getSexModel()
  {
    if (sexModel == null)
      sexModel = new EnumPropertySelectionModel(
        new Sex[] 
        {
          Sex.MALE, Sex.FEMALE, Sex.TRANSGENDER, 
Sex.ASEXUAL  
        },  getBundle("tutorial.survey.SurveyStrings"), 
"Sex");
        
    return sexModel;
  }  
  
    private ResourceBundle getBundle(String resourceName)
    {
        return ResourceBundle.getBundle(resourceName, getLocale());
    }
    
  public IActionListener getFormListener()
  {
    return new IActionListener()
    {
      public void actionTriggered(IComponent component, 
IRequestCycle cycle)
      {
        try
        {
          survey.setAge(Integer.parseInt(age));
          
          survey.validate();
        }
        catch (NumberFormatException e)
        {
          // NumberFormatException doesn't provide 
any useful data
          
          setError("Value entered for age is not a 
number.");
          return;
        }
        catch (Exception e)
        {
          setError(e.getMessage());
          return;
        }
        
        // Survey is OK, add it to the database.
        
      
  ((SurveyApplication)getApplication()).getDatabase().addSurvey(survey
);
        
        setSurvey(null);  
        
        // Jump to the results page to show the totals.
        
        cycle.setPage("Results");
      }  
    };
  }
    
  public Survey getSurvey()
  {
    if (survey == null)
      setSurvey(new Survey());
        
    return survey;
  }
  
  public void setSurvey(Survey value)
  {
    survey = value;
    fireObservedChange("survey", survey);
  }
  
  public void detach()
  {
    super.detach();
    
    survey = null;
    error = null;
    age = null;
    
    // We keep the models, since they are stateless
  }
  
  public void setError(String value)
  {
    error = value;
  }
  
  public String getError()
  {
    return error;
  }
  
  public String getAge()
  {
    int ageValue;
    
    if (age == null)
    {
      ageValue = getSurvey().getAge();
      
      if (ageValue == 0)
        age = "";
      else 
        age = Integer.toString(ageValue);
    }  
    
    return age;  
  }
  
  public void setAge(String value)
  {
    age = value;
  }
}
]]></programlisting>
      </figure>
      <para> 
A few notes.  First, the <varname>raceModel</varname> and 
<varname>sexModel</varname> properties are created on-the-fly as needed.  The 
&EnumPropertySelectionModel; is a provided class that simplifies using a 
&PropertySelection; component to set an Enum-typed property.  We provide the list of possible values, and the 
information needed to extract the corresponding labels from a properties file.
</para>
      <para> 
Only <varname>survey</varname> is a persistent page property.  The 
<varname>error</varname> property is transient (it is set to null at the 
end of the request cycle).  The <varname>error</varname> property doesn't need 
to be persistent ... it is generated during 
a request cycle and is not used on a subsequent request cycle (because the survey will be re-
validated).
</para>
      <para>
Likewise, the <varname>age</varname>
property isn't page persistent.  If an invalid value is submitted, then its value will 
come up from the &HttpServletRequest; 
parameter and be plugged into the <varname>age</varname> property of the 
page.  If validation of the survey fails, then the <classname>SurveyPage</classname>
will be used to render the HTML 
response, and the invalid age value will still be there.
</para>
      <para>
In the <function>detach()</function> method, the <varname>survey</varname>, <varname>error</varname> and 
<varname>age</varname> properties are properly 
cleared.  The <varname>raceModel</varname> and <varname>ageModel</varname> properties are 
not ... they are stateless and leaving them in 
place saves the trouble of creating identical objects later.
</para>
    </section>
  </chapter>
  <chapter id="local">
    <title>Localization</title>
    <para>
One of the most powerful and useful features of the Tapestry framework is the way in which it 
assists with localization of a web application.  This is normally an ugly area in web applications, 
with tremendous amounts of ad-hoc coding necessary.
</para>
    <para>
Because Tapestry does such a strong job of seperating the presentation of a component (its 
HTML template) from its control logic (its specification and Java class) it becomes easy for it to 
perform localization automatically.  It's as simple as providing additional localized HTML 
templates for the component, and letting the framework select the proper one.
</para>
    <para>
However, the static text of an application, provided by the HTML templates, is not all.
</para>
    <para>
Applications also have assets (images, stylesheets and the like) that must also be localized: that 
fancy button labeled "Search" is fine for your English clients, but your 
French clients will require 
a similar button labeled "Recherche".
</para>
    <para>
Again, the framework assists, because it can look for localized versions of the assets as it runs.
</para>
    <para>
The locale application demostrates this.  It is a very simply application that demonstrates changing 
the locale of a running application
	<footnote>
        <para>
		All the translations were performed using
		<ulink url="http://world.altavista.com/">Babelfish</ulink>, and are probably quite laughable to
		someone who actually speaks the alternate
		languages.
		</para>
      </footnote>
    </para>
    <para>
The Home page of the application allows you to select a new language for the application:
</para>
    <figure>
      <title>Locale Home Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/localize-home-english.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
Selecting "German" from the list and clicking the "Change" button brings you to a new page that 
acknowledges your selection:
</para>
    <figure>
      <title>Locale Changed (German)</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/localize-changed-german.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
Clicking the button (it's labeled "Select Another" in German) returns you to the Home page to 
select a new language:
</para>
    <figure>
      <title>Locale Home Page (German)</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/localize-home-german.jpg" format="JPEG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
The neat thing here is that the <classname>Home</classname> page has been localized into 
German as well; it shows 
equivalent German text, the options in the popup list are in German, and the "Change" button 
has been replaced with a German equivalent.
</para>
    <section id="locale.home">
      <title>Home Page</title>
      <para>
The <classname>Home</classname> page consists of a single component specification, 
four versions of the HTML 
template and four image assets.
</para>
      <figure>
        <title>Home.jwc</title>
        <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE specification PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">
<specification class="tutorial.locale.Home">

  <component id="border" type="Border"/>

  <component id="form" type="Form">
    <binding name="listener" property-path="formListener"/>
    <field-binding name="stateful" field-name="Boolean.FALSE"/>
  </component>

  <component id="inputLocale" type="PropertySelection">
    <binding name="value" property-path="selectedLocale"/>
    <binding name="model" property-path="localeModel"/>
  </component>

  <component id="changeButton" type="ImageSubmit">
    <binding name="image" property-path="assets.change-button"/>
  </component>

  <private-asset name="change-button" resource-path="/tutorial/locale/Change.gif"/>

</specification>
]]></programlisting>
      </figure>
      <para> 
The <varname>changeButton</varname> component is an 
&ImageSubmit;, a Tapestry version of an <sgmltag class="starttag">input 
type="image"</sgmltag> HTML form element.  We provide it with an image, an asset that will be used as 
the src attribute of the HTML tag
</para>
      <para>
The property path <varname>assets.change-button</varname> is a convienience; each component 
may have a number 
of named assets and has an <varname>assets</varname> property that is a 
&Map; of those assets.
</para>
      <para>
We also must define the asset, naming it change-button.  We declare it as a private asset, an asset 
that is not directly visible to the servlet container, but is instead packaged with the Java classes in a 
JAR or in the <filename>WEB-INF/classes</filename> directory of a WAR.
</para>
      <para>
In fact, there are four files in that directory, named <filename>Change.gif</filename>, 
<filename>Change_de.gif</filename>, <filename>Change_fr.gif</filename> and 
<filename>Change_it.gif</filename>.  Those suffixes (_de, _fr, etc.) identify the locale for which the 
image is appropriate.  
</para>
      <para>
More information on those suffixes is available from the <classname>java.util.Locale</classname>
documentation.
</para>
      <para>
When Tapestry is rendering the page, it knows what locale is currently selected
(it's a property of the engine object) and chooses the correct file based on that.
</para>
      <para>
Along with the four images, there are four HTML templates.
</para>
      <figure>
        <title>Home.html (English)</title>
        <programlisting><![CDATA[
<jwc id="border">

This tutorial demonstration how to dynamically change the locale
for the running application.

<p>
Select a new locale:

<jwc id="form">
	<jwc id="inputLocale"/>
	<jwc id="changeButton"/>
</jwc>

</jwc>
]]></programlisting>
      </figure>
      <para> 
The alternate locale versions are named in the same pattern as the image asset files.
</para>
      <figure>
        <title>Home_de.html (German)</title>
        <programlisting><![CDATA[
<jwc id="border">

Diese Referentendemonstration, wie man dynamisch
das locale f&#252;r die laufende Anwendung &#228;ndert.

<p>
W&#228;hlen Sie ein neues locale aus:

<jwc id="form">
	<jwc id="inputLocale"/>
	<jwc id="changeButton"/>
</jwc>

</jwc>
]]></programlisting>
      </figure>
      <para> 
The ids of components are consistent regardless of the locale used; 
these are internal ids (the 
equivalent of variable names) and are not shown to the end user.  
In addition, there's only one 
specification file and the ids here must match the ids in the specification.
</para>
      <para>
The only real different between the files is the static text which, here, is in German.
</para>
      <para>
Again, when Tapestry is rendering the page, it first chooses the correct localized HTML template.  
When it is rendering the <varname>changeButton</varname> component, it finds 
the correct localized file.  It all comes together to consistently display the localized images and text.
</para>
      <para>
What if there isn't a localization of a template or file?  Tapestry will use the more general file.  For 
instance, if we somehow managed to convince the application that we spoke Spanish we would 
see mostly English text since we didn't provide Spanish localized templates or assets.
</para>
      <para>
The Java code for the Home page is simple enough that we can largely skip it.  The only 
interesting parts are providing a property selection model for the inputLocale component and 
responding when the form is submitted:
</para>
      <figure>
        <title>Home.java (excerpt)</title>
        <programlisting><![CDATA[    
  
  public void actionTriggered(IComponent component, IRequestCycle cycle)
    throws RequestCycleException
    {
        getEngine().setLocale(selectedLocale);

        cycle.setPage("Change");
    }
]]></programlisting>
      </figure>
    </section>
    <section id="locale.change">
      <title>Change page</title>
      <para>
After the user selects a language, the application switches to the  
<classname>Change</classname> page for a response, 
which includes a link back to the <classname>Home</classname> page (as a localized image button).
</para>
      <figure>
        <title>Change.html</title>
        <programlisting><![CDATA[
<jwc id="border">

Congratulations, you've changed the locale to <jwc id="insertLocaleName"/>.

<p><jwc id="home"><jwc id="chooseAgainImage"/></jwc>

</jwc>
]]></programlisting>
      </figure>
      <para>
This template combines with the specification that identifies the images.
</para>
      <figure>
        <title>Change.jwc</title>
        <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE specification PUBLIC 
  "-//Howard Ship//Tapestry Specification 1.1//EN" 
  "http://tapestry.sf.net/dtd/Tapestry_1_1.dtd">
<specification class="tutorial.locale.Change">
  
  <component id="border" type="Border"/>
  
  <component id="insertLocaleName" type="Insert">
    <binding name="value" property-path="localeName"/>
  </component>
  
  <component id="home" type="Page">
    <static-binding name="page">Home</static-binding>
  </component>
  
  <component id="chooseAgainImage" type="Image">
    <binding name="image" property-path="assets.choose-again"/>
  </component>
  
  <context-asset name="choose-again" path="/images/locale/ChooseAgain.gif"/>

</specification>
]]></programlisting>
      </figure>
      <para> 
This is similar to the previous example, in that we've provided four versions of the 
<filename>ChooseAgain.gif</filename> image asset.
However, we've put the images in a different place.  This time, the asset is a 
context asset, an asset 
that is visible to the servlet container.  In this example, the file 
<filename>ChooseAgain.gif</filename> is located in the 
<filename>/images/locale</filename> directory of the WAR.  Tapestry makes sure that the correct prefix 
(<filename>/tutorial</filename>) is 
prepended to the path when the HTML is rendered.
</para>
      <para>
Context assets are the most common assets used.  Private assets (as used on the Home page) are 
used mostly when creating libraries of components for reuse.  When building an application that 
stands on its own, context assets are easier and more efficient.
</para>
    </section>
    <section id="locale.other-options">
      <title>Other Options for Localization</title>
      <para>
In some cases, different localizations of the a component will be very similar, perhaps having only 
one or two small snippets of text that is different.
In those cases, it may be easier on the developer to not localize the HTML template, but to 
replace the variant text with an 
&Insert; component.
</para>
      <para>
The page can read a localized strings file (a <filename>.properties</filename> file) to get 
appropriate localized text.  This 
saves the bother of maintaining multiple HTML templates.
</para>
      <para>
All components on a page share the single locale for the page, but each performs its own search 
for its HTML template.  This means that some components may not have to be localized, if they 
never contain any static HTML text.  This is sometimes the case for reusable components, even 
navigational borders.
</para>
    </section>
  </chapter>
  <chapter id="summary">
    <title>Further Study</title>
    <para>
The preceding chapters cover many of the basic aspects of Tapestry.  You should be comfortable 
with basic Tapestry concepts:
</para>
    <itemizedlist>
      <listitem>
        <para>Seperation of presentation, business and control logic
		</para>
      </listitem>
      <listitem>
        <para>Use of JavaBeans properties as the source of dynamic data
		</para>
      </listitem>
      <listitem>
        <para>How bindings access JavaBeans properties to provide data to components
		</para>
      </listitem>
      <listitem>
        <para>How components wrap each other, allowing for the creation of very complicated 
		components through aggregation
		</para>
      </listitem>
      <listitem>
        <para>
		Different types of page properties (transient, dynamic, persistent)
		</para>
      </listitem>
    </itemizedlist>
    <para>
Tapestry is capable of quite a bit more.  Also available within the Tapestry Examples package 
(along with the tutorial code and this document) is the Primix Virtual Library application (Vlib).
</para>
    <para>
Vlib is a full-blown J2EE application, that makes use of Tapestry as its front end, and a set of 
session and entity Enterprise JavaBeans as its back end.
</para>
    <para>
Vlib also demonstrates some of the other aspects of developing a Tapestry application.  It shows 
how to create pages that are bookmarkable (meaning that their URL includes enough information 
to reconstruct them in a subsequent session).  It shows how to handle logging in to an application, 
and how to protect pages from being accessed until the user is logged in.  It has many specialized 
reusable components for creating links to pages about books and people.
</para>
  </chapter>
</book>

